<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Testifier Audit Report</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator_modern.min.css"
    />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.css" />
    <style>
      :root {
        --bg: #f4f7fb;
        --surface: #ffffff;
        --surface-alt: #f8fafc;
        --ink: #0f172a;
        --ink-muted: #475569;
        --line: #d2dbe7;
        --brand: #1d4ed8;
        --ok: #0f766e;
        --warn: #b45309;
        --danger: #b91c1c;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        color: var(--ink);
        background:
          radial-gradient(circle at top left, #dbeafe 0%, transparent 28%),
          radial-gradient(circle at top right, #e2e8f0 0%, transparent 24%),
          var(--bg);
        font-family: "IBM Plex Sans", "Avenir Next", "Segoe UI", sans-serif;
        scroll-padding-top: 84px;
      }

      .page-shell {
        margin: 0 auto;
        max-width: 1640px;
        padding: 1.2rem 1rem 2.2rem;
        position: relative;
      }

      .report-layout {
        position: relative;
      }

      .report-main {
        margin-left: 0;
        min-width: 0;
        transition: margin-left 180ms ease;
      }

      .toc-sidebar {
        position: fixed;
        top: 1rem;
        left: max(1rem, calc((100vw - 1640px) / 2 + 1rem));
        width: 300px;
        max-height: calc(100vh - 2rem);
        overflow: auto;
        z-index: 30;
        transform: translateX(calc(-100% - 1.2rem));
        opacity: 0;
        pointer-events: none;
        transition: transform 180ms ease, opacity 180ms ease;
      }

      .page-shell.sidebar-open .report-main {
        margin-left: 320px;
      }

      .page-shell.sidebar-open .toc-sidebar {
        transform: translateX(0);
        opacity: 1;
        pointer-events: auto;
      }

      .sidebar-toggle {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 45;
        border: 1px solid #bfdbfe;
        border-radius: 999px;
        background: #ffffff;
        color: #0f172a;
        font: inherit;
        font-size: 0.85rem;
        font-weight: 600;
        padding: 0.38rem 0.74rem;
        cursor: pointer;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.1);
      }

      .sidebar-toggle:hover {
        background: #eff6ff;
      }

      .sidebar-backdrop {
        display: none;
      }

      .sidebar-header {
        border-bottom: 1px solid #dbe4ef;
        margin-bottom: 0.72rem;
        padding-bottom: 0.64rem;
      }

      .sidebar-report-title {
        margin: 0;
        font-size: 1.04rem;
      }

      .sidebar-meta {
        margin-top: 0.28rem;
        margin-bottom: 0.12rem;
      }

      .sidebar-close {
        margin-top: 0.48rem;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        background: #ffffff;
        color: #0f172a;
        font: inherit;
        font-size: 0.82rem;
        padding: 0.3rem 0.56rem;
        cursor: pointer;
      }

      .toc-title {
        margin-top: 0;
        margin-bottom: 0.2rem;
        font-size: 1rem;
      }

      .toc-note {
        margin-bottom: 0.48rem;
      }

      #report-toc {
        margin-top: 0.2rem;
      }

      #report-toc .toc-list {
        margin: 0;
        padding: 0;
        list-style: none;
      }

      #report-toc .toc-list-item {
        margin: 0;
      }

      #report-toc .toc-link {
        display: block;
        border-left: 2px solid transparent;
        border-radius: 6px;
        color: #334155;
        font-size: 0.86rem;
        line-height: 1.3;
        padding: 0.34rem 0.5rem;
        text-decoration: none;
        transition: background 120ms ease, border-color 120ms ease, color 120ms ease;
      }

      #report-toc .toc-link:hover {
        background: #eff6ff;
        color: #1e3a8a;
      }

      #report-toc .toc-link.is-active-link {
        border-left-color: #1d4ed8;
        background: #dbeafe;
        color: #1e40af;
        font-weight: 600;
      }

      .toc-heading {
        scroll-margin-top: 90px;
      }

      .hero {
        border: 1px solid #c7d2fe;
        border-radius: 14px;
        background: linear-gradient(128deg, #eff6ff 0%, #f8fafc 60%, #ecfeff 100%);
        padding: 1rem 1rem;
      }

      h1,
      h2,
      h3,
      h4 {
        margin: 0.3rem 0 0.46rem;
        line-height: 1.25;
      }

      h1 {
        font-size: 1.8rem;
      }

      h2 {
        font-size: 1.28rem;
      }

      h3 {
        font-size: 1.04rem;
      }

      h4 {
        font-size: 0.95rem;
      }

      p {
        margin: 0.28rem 0 0.72rem;
      }

      code {
        background: #f1f5f9;
        border: 1px solid #e2e8f0;
        border-radius: 4px;
        padding: 0.1rem 0.28rem;
        font-family: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
        font-size: 0.88em;
      }

      .meta {
        color: var(--ink-muted);
        font-size: 0.92rem;
      }

      .subtle {
        color: var(--ink-muted);
        font-size: 0.88rem;
      }

      .panel {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: var(--surface);
        padding: 0.86rem;
      }

      .report-section {
        margin-top: 1.15rem;
      }

      .definition-callout {
        margin-top: 0.75rem;
        border: 1px solid #bfdbfe;
        border-left: 4px solid #2563eb;
        border-radius: 10px;
        background: #eff6ff;
        padding: 0.65rem 0.72rem;
      }

      .definition-callout p {
        margin: 0.26rem 0;
        color: #1e3a8a;
      }

      .definition-callout strong {
        color: #1e40af;
      }

      .kpi-grid {
        margin-top: 0.75rem;
        display: grid;
        gap: 0.76rem;
        grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
      }

      .kpi-card {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: var(--surface-alt);
        padding: 0.7rem;
      }

      .kpi-label {
        color: var(--ink-muted);
        font-size: 0.84rem;
      }

      .kpi-value {
        margin-top: 0.12rem;
        font-size: 1.58rem;
        font-weight: 650;
        letter-spacing: -0.015em;
      }

      .bucket-sync-panel {
        margin-top: 0.88rem;
      }

      .bucket-tablist {
        display: flex;
        gap: 0.45rem;
        flex-wrap: wrap;
      }

      .bucket-tab {
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #ffffff;
        color: #0f172a;
        font: inherit;
        font-size: 0.86rem;
        padding: 0.27rem 0.65rem;
        cursor: pointer;
      }

      .bucket-tab:hover {
        border-color: #93c5fd;
        background: #eff6ff;
      }

      .bucket-tab[aria-selected="true"] {
        border-color: #1d4ed8;
        background: #dbeafe;
        color: #1e3a8a;
        font-weight: 600;
      }

      .tiny-note {
        color: var(--ink-muted);
        font-size: 0.83rem;
      }

      .analysis-section {
        margin-top: 1.2rem;
        border: 1px solid var(--line);
        border-radius: 12px;
        background: var(--surface);
        padding: 0.9rem;
      }

      .analysis-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        border-radius: 999px;
        padding: 0.14rem 0.58rem;
        font-size: 0.74rem;
        font-weight: 700;
        letter-spacing: 0.01em;
        text-transform: uppercase;
      }

      .status-ready {
        color: #065f46;
        background: #d1fae5;
      }

      .status-empty {
        color: #92400e;
        background: #fef3c7;
      }

      .status-disabled {
        color: #7f1d1d;
        background: #fee2e2;
      }

      .chart-host {
        width: 100%;
      }

      .chart-host-hero {
        min-height: 480px;
      }

      .chart-host-detail {
        min-height: 420px;
      }

      .analysis-hero-block {
        margin-top: 0.66rem;
      }

      .analysis-help-card {
        margin-top: 0.8rem;
        border: 1px solid #dbe4ef;
        border-radius: 10px;
        background: #f8fafc;
        overflow: hidden;
      }

      .analysis-help-card > summary {
        cursor: pointer;
        list-style: none;
        padding: 0.58rem 0.7rem;
        font-weight: 600;
        border-bottom: 1px solid #e2e8f0;
        background: #f8fafc;
      }

      .analysis-help-card > summary::-webkit-details-marker {
        display: none;
      }

      .analysis-help-body {
        padding: 0.62rem 0.7rem;
      }

      .analysis-help-body p {
        margin: 0.3rem 0;
        font-size: 0.9rem;
        color: #334155;
      }

      .analysis-help-body ul {
        margin: 0.35rem 0 0.2rem 1.1rem;
        padding: 0;
      }

      .analysis-help-body li {
        margin: 0.32rem 0;
        color: #334155;
        font-size: 0.9rem;
      }

      .analysis-help-body strong {
        color: #0f172a;
      }

      .analysis-detail-grid {
        margin-top: 0.82rem;
        display: grid;
        gap: 0.82rem;
        grid-template-columns: minmax(0, 1fr);
      }

      .detail-card {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: var(--surface-alt);
        padding: 0.66rem;
      }

      .detail-title {
        margin-bottom: 0.5rem;
      }

      .chart-note {
        margin: 0.28rem 0 0;
      }

      .chart-help-card {
        margin-top: 0.42rem;
        border: 1px solid #dbe4ef;
        border-radius: 8px;
        background: #ffffff;
        overflow: hidden;
      }

      .chart-help-card > summary {
        cursor: pointer;
        list-style: none;
        font-weight: 600;
        padding: 0.46rem 0.56rem;
        background: #f8fafc;
        border-bottom: 1px solid #e2e8f0;
      }

      .chart-help-card > summary::-webkit-details-marker {
        display: none;
      }

      .chart-help-body {
        padding: 0.46rem 0.56rem;
      }

      .chart-help-body p {
        margin: 0.12rem 0 0.38rem;
        font-size: 0.86rem;
        line-height: 1.44;
        color: #334155;
      }

      .chart-help-body ul {
        margin: 0 0 0 1.05rem;
        padding: 0;
      }

      .chart-help-body li {
        margin: 0.24rem 0;
        color: #334155;
        font-size: 0.86rem;
        line-height: 1.4;
      }

      .empty-message {
        margin-top: 0.36rem;
        color: var(--ink-muted);
        font-style: italic;
      }

      .hidden {
        display: none !important;
      }

      .analysis-tables {
        margin-top: 0.85rem;
        display: grid;
        gap: 0.72rem;
        grid-template-columns: minmax(0, 1fr);
      }

      details.table-group {
        border: 1px solid #dbe4ef;
        border-radius: 10px;
        background: #ffffff;
        overflow: hidden;
      }

      details.table-group > summary {
        cursor: pointer;
        list-style: none;
        background: #f8fafc;
        border-bottom: 1px solid #e2e8f0;
        padding: 0.56rem 0.7rem;
        font-weight: 600;
      }

      details.table-group > summary::-webkit-details-marker {
        display: none;
      }

      .table-wrap {
        padding: 0.66rem;
      }

      .column-glossary {
        margin-bottom: 0.58rem;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        background: #f8fafc;
        padding: 0.46rem 0.54rem;
      }

      .column-glossary-title {
        margin: 0 0 0.38rem;
        color: #0f172a;
        font-size: 0.82rem;
      }

      .column-glossary-grid {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 0.36rem 0.62rem;
      }

      .column-glossary-item {
        margin: 0;
      }

      .column-glossary-item dt {
        margin: 0;
        font-family: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
        font-size: 0.76rem;
        color: #1e293b;
      }

      .column-glossary-item dd {
        margin: 0.16rem 0 0;
        color: #475569;
        font-size: 0.78rem;
        line-height: 1.28;
      }

      .table-host {
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        overflow: auto;
        background: #ffffff;
        width: 100%;
      }

      .table-help-card {
        margin-bottom: 0.62rem;
        border: 1px solid #dbe4ef;
        border-radius: 8px;
        background: #ffffff;
        overflow: hidden;
      }

      .table-help-card > summary {
        cursor: pointer;
        list-style: none;
        font-weight: 600;
        padding: 0.5rem 0.58rem;
        border-bottom: 1px solid #e2e8f0;
        background: #f8fafc;
      }

      .table-help-card > summary::-webkit-details-marker {
        display: none;
      }

      .table-help-body {
        padding: 0.5rem 0.58rem;
      }

      .table-help-body p {
        margin: 0.22rem 0;
        color: #334155;
        font-size: 0.86rem;
        line-height: 1.44;
      }

      .tabulator {
        border: none;
        background: #ffffff;
        font-size: 0.9rem;
        color: var(--ink);
      }

      .tabulator .tabulator-header {
        border-bottom: 1px solid #dbe4ef;
        background: linear-gradient(180deg, #fcfdff 0%, #f8fafc 100%);
      }

      .tabulator .tabulator-header .tabulator-col {
        background: transparent;
        border-right: 1px solid #e2e8f0;
        color: #0f172a;
        font-weight: 600;
      }

      .tabulator .tabulator-row {
        background: #ffffff;
        border-bottom: 1px solid #edf2f7;
      }

      .tabulator .tabulator-row:nth-child(even),
      .tabulator-row:nth-child(2n) {
        background: #f6f8fc;
      }

      .tabulator .tabulator-row:hover,
      .tabulator .tabulator-row:hover .tabulator-cell {
        background: #ecf2fb;
      }

      .tabulator .tabulator-cell {
        border-right: 1px solid #edf2f7;
      }

      .tabulator .tabulator-footer {
        border-top: 1px solid #dbe4ef;
        background: #f8fafc;
      }

      .tabulator .tabulator-footer .tabulator-page.active {
        background: #dbeafe;
        color: #1d4ed8;
        border-color: #bfdbfe;
      }

      .tabulator .tabulator-header-filter input {
        border-radius: 6px;
        border: 1px solid #cbd5e1;
        background: #ffffff;
      }

      @media (max-width: 1220px) {
        .toc-sidebar {
          left: 0;
          top: 0;
          width: min(92vw, 360px);
          max-height: 100vh;
          height: 100vh;
          border-radius: 0 12px 12px 0;
        }

        .page-shell.sidebar-open .report-main {
          margin-left: 0;
        }

        .sidebar-backdrop {
          position: fixed;
          inset: 0;
          background: rgba(15, 23, 42, 0.46);
          z-index: 25;
        }

        .page-shell.sidebar-open .sidebar-backdrop {
          display: block;
        }

        .analysis-detail-grid {
          grid-template-columns: minmax(0, 1fr);
        }

        .chart-host-hero {
          min-height: 430px;
        }
      }

      @media (max-width: 820px) {
        .page-shell {
          padding: 0.92rem 0.72rem 1.45rem;
        }

        h1 {
          font-size: 1.52rem;
        }

        h2 {
          font-size: 1.16rem;
        }

        .chart-host-hero {
          min-height: 360px;
        }

        .chart-host-detail {
          min-height: 320px;
        }

        .sidebar-toggle {
          top: 0.72rem;
          left: 0.72rem;
          font-size: 0.82rem;
          padding: 0.32rem 0.62rem;
        }

        .column-glossary-grid {
          grid-template-columns: minmax(0, 1fr);
        }
      }
    </style>
  </head>
  <body>
    <button
      id="sidebar-toggle"
      class="sidebar-toggle"
      type="button"
      aria-controls="toc-sidebar"
      aria-expanded="false"
    >
      â˜° Menu
    </button>
    <div class="page-shell" id="page-shell">
      <div class="sidebar-backdrop" id="sidebar-backdrop"></div>
      <div class="report-layout">
        <aside class="toc-sidebar panel" id="toc-sidebar" aria-label="Section navigation">
          <div class="sidebar-header">
            <h1 class="sidebar-report-title">Testifier Audit Report</h1>
            <p class="tiny-note sidebar-meta">Generated (UTC): <code>{{ generated_at }}</code></p>
            <button id="sidebar-close" class="sidebar-close" type="button">Close</button>
          </div>

          <section class="bucket-sync-panel panel" id="bucket-sync-panel">
            <h3>Linked Bucket Tabs</h3>
            <p class="tiny-note">
              Choose one bucket and all bucket-aware charts update together when that bucket is available.
            </p>
            <div class="bucket-tablist" id="bucket-sync-tabs" role="tablist" aria-label="Linked bucket selector"></div>
            <p class="tiny-note" id="bucket-sync-note"></p>
            <p class="tiny-note" id="cursor-sync-note">Click any absolute-time chart to place a linked vertical cursor.</p>
          </section>

          <h2 class="toc-title">Contents</h2>
          <p class="tiny-note toc-note">Jump between detector sections.</p>
          <nav id="report-toc" class="js-toc" aria-label="Table of contents"></nav>
        </aside>

        <main id="toc-content" class="report-main">
          <header class="hero">
            <p class="subtle">
              Interactive charts are powered by <code>ECharts</code>; data tables use <code>Tabulator</code>.
            </p>
          </header>

          <section id="section-overview" class="report-section panel">
            <h2 id="overview" class="toc-heading">How To Use This Report</h2>
            <p>
              This report is organized detector-first. Start each section with the hero chart to establish the primary signal,
              then use detail charts and tables to validate whether the pattern is sustained, high-power, and corroborated.
            </p>
            <aside class="definition-callout">
              <p>
                <strong>What low power means:</strong> low-support buckets/windows have high proportion uncertainty and can swing
                from random variation.
              </p>
              <p>
                <strong>How to interpret:</strong> prioritize signals that persist into adjacent higher-volume windows or recur at
                similar dayparts across days.
              </p>
            </aside>
            <section class="kpi-grid">
              <article class="kpi-card">
                <div class="kpi-label">Artifacts Tracked</div>
                <div class="kpi-value" id="kpi-artifacts">0</div>
              </article>
              <article class="kpi-card">
                <div class="kpi-label">Detectors Run</div>
                <div class="kpi-value" id="kpi-detectors">0</div>
              </article>
              <article class="kpi-card">
                <div class="kpi-label">Flagged/Significant Windows</div>
                <div class="kpi-value" id="kpi-flagged">0</div>
              </article>
              <article class="kpi-card">
                <div class="kpi-label">Low-power Windows</div>
                <div class="kpi-value" id="kpi-low-power">0</div>
              </article>
            </section>
          </section>

          <section id="analysis-root" class="report-section">
            {% for analysis in interactive_charts.analysis_catalog %}
              <section
                class="analysis-section"
                id="section-{{ analysis.id }}"
                data-analysis-id="{{ analysis.id }}"
                data-analysis-status="{{ analysis.status }}"
                data-analysis-detector="{{ analysis.detector or '' }}"
              >
                <div class="analysis-header">
                  <h2 id="analysis-{{ analysis.id }}" class="toc-heading">{{ analysis.title }}</h2>
                  <span class="status-badge status-{{ analysis.status }}">{{ analysis.status }}</span>
                </div>
                {% if analysis.reason %}
                  <p class="tiny-note">{{ analysis.reason }}</p>
                {% endif %}

                <div class="analysis-hero-block">
                  <div
                    class="chart-host chart-host-hero"
                    data-chart-id="{{ analysis.hero_chart_id }}"
                    data-chart-role="hero"
                  ></div>
                  <p class="empty-message hidden" data-chart-empty-for="{{ analysis.hero_chart_id }}">
                    No chartable records for this run.
                  </p>
                  <p class="tiny-note chart-note" data-chart-note-for="{{ analysis.hero_chart_id }}"></p>
                  {% set hero_help = interactive_charts.chart_help_docs.get(analysis.hero_chart_id) if interactive_charts.chart_help_docs else None %}
                  {% set hero_legend = interactive_charts.chart_legend_docs.get(analysis.hero_chart_id) if interactive_charts.chart_legend_docs else None %}
                  {% if hero_help or hero_legend %}
                    <details class="chart-help-card">
                      <summary>Chart Help</summary>
                      <div class="chart-help-body">
                        {% if hero_help %}
                          <p><strong>What is this?</strong> {{ hero_help.what_is_this }}</p>
                          <p><strong>Why this matters:</strong> {{ hero_help.why_it_matters }}</p>
                          <p><strong>How to interpret:</strong> {{ hero_help.how_to_interpret }}</p>
                          <p><strong>What to look for:</strong> {{ hero_help.what_to_look_for }}</p>
                          <p><strong>Momentary high/low:</strong> {{ hero_help.momentary_high_low }}</p>
                          <p><strong>Extended high/low:</strong> {{ hero_help.extended_high_low }}</p>
                        {% endif %}
                        {% if hero_legend %}
                          <p><strong>Legend guide:</strong> {{ hero_legend.summary }}</p>
                          {% if hero_legend["items"] %}
                            <ul>
                              {% for item in hero_legend["items"] %}
                                <li><strong>{{ item.label }}:</strong> {{ item.description }}</li>
                              {% endfor %}
                            </ul>
                          {% endif %}
                        {% endif %}
                      </div>
                    </details>
                  {% endif %}
                </div>

                <details class="analysis-help-card">
                  <summary>Analysis Help</summary>
                  <div class="analysis-help-body">
                    {% if analysis.help_sections %}
                      <p><strong>What is this?</strong> {{ analysis.help_sections.what_is_this }}</p>
                      <p><strong>Why this data matters:</strong> {{ analysis.help_sections.why_it_matters }}</p>
                      <p><strong>How do I interpret this data?</strong> {{ analysis.help_sections.how_to_interpret }}</p>
                      <p><strong>What do I look for?</strong> {{ analysis.help_sections.what_to_look_for }}</p>
                      <p><strong>What could a momentary high/low mean?</strong> {{ analysis.help_sections.momentary_high_low }}</p>
                      <p><strong>What could an extended high/low mean?</strong> {{ analysis.help_sections.extended_high_low }}</p>
                    {% else %}
                      <p><strong>How to read:</strong> {{ analysis.how_to_read }}</p>
                      <p><strong>What to look for:</strong> {{ analysis.what_to_look_for }}</p>
                    {% endif %}
                    {% if analysis.what_to_look_for_details %}
                      <ul>
                        {% for detail in analysis.what_to_look_for_details %}
                          <li>{{ detail }}</li>
                        {% endfor %}
                      </ul>
                    {% endif %}
                    <p><strong>Common benign causes:</strong> {{ analysis.common_benign_causes }}</p>
                  </div>
                </details>

                {% if analysis.detail_chart_ids %}
                  <div class="analysis-detail-grid">
                    {% for chart_id in analysis.detail_chart_ids %}
                      <article class="detail-card">
                        <h3 class="detail-title"><code>{{ chart_id }}</code></h3>
                        <div
                          class="chart-host chart-host-detail"
                          data-chart-id="{{ chart_id }}"
                          data-chart-role="detail"
                        ></div>
                        <p class="empty-message hidden" data-chart-empty-for="{{ chart_id }}">No chartable records for this run.</p>
                        <p class="tiny-note chart-note" data-chart-note-for="{{ chart_id }}"></p>
                        {% set detail_help = interactive_charts.chart_help_docs.get(chart_id) if interactive_charts.chart_help_docs else None %}
                        {% set detail_legend = interactive_charts.chart_legend_docs.get(chart_id) if interactive_charts.chart_legend_docs else None %}
                        {% if detail_help or detail_legend %}
                          <details class="chart-help-card">
                            <summary>Chart Help</summary>
                            <div class="chart-help-body">
                              {% if detail_help %}
                                <p><strong>What is this?</strong> {{ detail_help.what_is_this }}</p>
                                <p><strong>Why this matters:</strong> {{ detail_help.why_it_matters }}</p>
                                <p><strong>How to interpret:</strong> {{ detail_help.how_to_interpret }}</p>
                                <p><strong>What to look for:</strong> {{ detail_help.what_to_look_for }}</p>
                                <p><strong>Momentary high/low:</strong> {{ detail_help.momentary_high_low }}</p>
                                <p><strong>Extended high/low:</strong> {{ detail_help.extended_high_low }}</p>
                              {% endif %}
                              {% if detail_legend %}
                                <p><strong>Legend guide:</strong> {{ detail_legend.summary }}</p>
                                {% if detail_legend["items"] %}
                                  <ul>
                                    {% for item in detail_legend["items"] %}
                                      <li><strong>{{ item.label }}:</strong> {{ item.description }}</li>
                                    {% endfor %}
                                  </ul>
                                {% endif %}
                              {% endif %}
                            </div>
                          </details>
                        {% endif %}
                      </article>
                    {% endfor %}
                  </div>
                {% endif %}

                <div class="analysis-tables" data-analysis-tables-for="{{ analysis.id }}"></div>
              </section>
            {% endfor %}
          </section>
        </main>
      </div>
    </div>

    <script id="report-data" type="application/json">
      {{
        {
          "artifact_rows": artifact_rows,
          "detector_summaries": detector_summaries,
          "table_previews": table_previews,
          "evidence_bundle_preview": evidence_bundle_preview,
          "rarity_coverage_preview": rarity_coverage_preview,
          "rarity_unmatched_first_preview": rarity_unmatched_first_preview,
          "rarity_unmatched_last_preview": rarity_unmatched_last_preview,
          "clockface_top_preview": clockface_top_preview,
          "table_column_docs": table_column_docs,
          "table_help_docs": table_help_docs,
          "interactive_charts": interactive_charts
        } | tojson
      }}
    </script>
    <script src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.js"></script>
    <script>
      (function () {
        const dataElement = document.getElementById("report-data");
        const reportData = dataElement ? JSON.parse(dataElement.textContent || "{}") : {};
        const interactive = reportData.interactive_charts || {};
        const analysisCatalog = Array.isArray(interactive.analysis_catalog) ? interactive.analysis_catalog : [];
        const analysisById = new Map(analysisCatalog.map((analysis) => [String(analysis.id || ""), analysis]));
        const chartRowsMap = interactive.charts || {};
        const controls = interactive.controls || {};
        const tableColumnDocs = reportData.table_column_docs || {};
        const tableHelpDocs = reportData.table_help_docs || {};

        const hasEcharts = typeof window.echarts !== "undefined";
        const hasTabulator = typeof window.Tabulator !== "undefined";

        const chartInstances = [];
        const mountedSections = new Set();
        const chartMounts = new Map();

        const state = {
          activeBucket: null,
          cursorX: null,
          activeTocHeading: null,
          zoom: {
            minTime: null,
            maxTime: null,
            syncing: false,
            raf: null,
            pending: null,
          },
          timeCharts: new Set(),
          absoluteTimeSet: new Set(
            ((controls.zoom_sync_groups || {}).absolute_time || []).map((id) => String(id || ""))
          ),
        };

        function toNumber(value) {
          if (typeof value === "number" && Number.isFinite(value)) {
            return value;
          }
          if (typeof value === "string") {
            const parsed = Number(value);
            return Number.isFinite(parsed) ? parsed : 0;
          }
          return 0;
        }

        function toFiniteNumberOrNull(value) {
          if (typeof value === "number" && Number.isFinite(value)) {
            return value;
          }
          if (typeof value === "boolean") {
            return value ? 1 : 0;
          }
          if (typeof value === "string") {
            const parsed = Number(value);
            return Number.isFinite(parsed) ? parsed : null;
          }
          return null;
        }

        function toBool(value) {
          if (typeof value === "boolean") {
            return value;
          }
          if (typeof value === "number") {
            return value !== 0;
          }
          if (typeof value === "string") {
            const normalized = value.trim().toLowerCase();
            return normalized === "true" || normalized === "1" || normalized === "yes";
          }
          return false;
        }

        function toEpochMillis(value) {
          if (typeof value === "number" && Number.isFinite(value)) {
            return value;
          }
          if (!value) {
            return null;
          }
          const parsed = Date.parse(value);
          return Number.isFinite(parsed) ? parsed : null;
        }

        function normalizeHashId(rawValue) {
          const stripped = String(rawValue || "")
            .replace(/^#/, "")
            .trim();
          if (!stripped) {
            return "";
          }
          try {
            return decodeURIComponent(stripped);
          } catch (_error) {
            return stripped;
          }
        }

        function replaceUrlHashWithoutHistory(headingId) {
          const normalized = normalizeHashId(headingId);
          if (!normalized) {
            return;
          }
          const nextHash = "#" + normalized;
          if (window.location.hash === nextHash) {
            return;
          }
          if (window.history && typeof window.history.replaceState === "function") {
            const nextUrl = window.location.pathname + window.location.search + nextHash;
            window.history.replaceState(window.history.state || null, "", nextUrl);
            return;
          }
          window.location.hash = nextHash;
        }

        function setActiveTocHeading(headingId, syncUrl) {
          const normalized = normalizeHashId(headingId);
          if (!normalized || state.activeTocHeading === normalized) {
            return;
          }
          state.activeTocHeading = normalized;

          const links = Array.from(document.querySelectorAll('#report-toc a[href^="#"]'));
          links.forEach((link) => {
            const isActive = normalizeHashId(link.getAttribute("href")) === normalized;
            link.classList.toggle("is-active-link", isActive);
            if (isActive) {
              link.setAttribute("aria-current", "true");
            } else {
              link.removeAttribute("aria-current");
            }
          });

          if (syncUrl) {
            replaceUrlHashWithoutHistory(normalized);
          }
        }

        function renderFallbackToc(headings, tocRoot) {
          if (!tocRoot) {
            return false;
          }
          const list = document.createElement("ul");
          list.className = "toc-list";

          headings.forEach((heading) => {
            if (!heading || !heading.id) {
              return;
            }
            const item = document.createElement("li");
            item.className = "toc-list-item";

            const link = document.createElement("a");
            link.className = "toc-link";
            link.href = "#" + heading.id;
            link.textContent = heading.textContent || heading.id;

            item.appendChild(link);
            list.appendChild(item);
          });

          tocRoot.innerHTML = "";
          tocRoot.appendChild(list);
          return list.childElementCount > 0;
        }

        function seriesData(rows, xField, yField) {
          return rows
            .map((row) => {
              const x = toEpochMillis(row[xField]);
              const y = toFiniteNumberOrNull(row[yField]);
              return x === null ? null : [x, y];
            })
            .filter((entry) => entry !== null)
            .sort((left, right) => left[0] - right[0]);
        }

        function inferTimeField(rows) {
          if (!rows.length) {
            return null;
          }
          const candidates = [
            "minute_bucket",
            "bucket_start",
            "start_minute",
            "first_seen",
            "change_minute",
            "date",
          ];
          const row = rows[0] || {};
          for (const field of candidates) {
            if (Object.prototype.hasOwnProperty.call(row, field)) {
              if (field === "date" && Object.prototype.hasOwnProperty.call(row, "slot_start_minute")) {
                continue;
              }
              return field;
            }
          }
          return null;
        }

        function numericFields(row) {
          return Object.keys(row || {}).filter((key) => typeof row[key] === "number" && Number.isFinite(row[key]));
        }

        function setEmptyForChart(chartId, isEmpty) {
          const element = document.querySelector('[data-chart-empty-for="' + chartId + '"]');
          if (!element) {
            return;
          }
          element.classList.toggle("hidden", !isEmpty);
        }

        function setChartNote(chartId, text) {
          const element = document.querySelector('[data-chart-note-for="' + chartId + '"]');
          if (!element) {
            return;
          }
          element.textContent = text || "";
        }

        function getChartRows(chartId) {
          const rows = chartRowsMap[chartId];
          return Array.isArray(rows) ? rows : [];
        }

        function uniqueBucketOptions(rows) {
          const values = new Set();
          rows.forEach((row) => {
            const value = toFiniteNumberOrNull(row.bucket_minutes);
            if (value !== null) {
              values.add(value);
            }
          });
          return Array.from(values).sort((left, right) => left - right);
        }

        function filterRowsByBucket(rows, chartId) {
          const options = uniqueBucketOptions(rows);
          if (!options.length) {
            return { rows: rows, bucket: null, options: options, note: "" };
          }

          let target = state.activeBucket;
          if (!Number.isFinite(target)) {
            target = options.includes(30) ? 30 : options[0];
          }

          if (!options.includes(target)) {
            const nearest = options
              .slice()
              .sort((left, right) => Math.abs(left - target) - Math.abs(right - target))[0];
            const subset = rows.filter((row) => toFiniteNumberOrNull(row.bucket_minutes) === nearest);
            return {
              rows: subset,
              bucket: nearest,
              options: options,
              note:
                "Requested " +
                target +
                "m is unavailable for this chart; showing " +
                nearest +
                "m instead.",
            };
          }

          return {
            rows: rows.filter((row) => toFiniteNumberOrNull(row.bucket_minutes) === target),
            bucket: target,
            options: options,
            note: "",
          };
        }

        function appendCursorMarkLine(baseLines) {
          const lines = Array.isArray(baseLines) ? baseLines.slice() : [];
          if (Number.isFinite(state.cursorX)) {
            lines.push({
              xAxis: state.cursorX,
              lineStyle: { color: "#0f172a", width: 1.2, opacity: 0.95, type: "solid" },
              label: { show: false },
            });
          }
          if (!lines.length) {
            return { data: [] };
          }
          return {
            silent: true,
            symbol: ["none", "none"],
            lineStyle: { color: "#7c3aed", width: 1, opacity: 0.55, type: "dashed" },
            label: { show: false },
            data: lines,
          };
        }

        function updateCursorAcrossTimeCharts() {
          chartMounts.forEach((mount) => {
            if (!mount.isTimeSeries || !mount.chart || !mount.seriesId) {
              return;
            }
            const markLine = appendCursorMarkLine(mount.baseMarkLines || []);
            mount.chart.setOption({
              series: [{ id: mount.seriesId, markLine: markLine }],
            });
          });

          const cursorNote = document.getElementById("cursor-sync-note");
          if (!cursorNote) {
            return;
          }
          if (!Number.isFinite(state.cursorX)) {
            cursorNote.textContent = "Click any absolute-time chart to place a linked vertical cursor.";
            return;
          }
          cursorNote.textContent = "Linked cursor: " + new Date(state.cursorX).toLocaleString() + ".";
        }

        function extractCursorFromEvent(chart, params) {
          if (!params || !chart) {
            return null;
          }
          if (Object.prototype.hasOwnProperty.call(params, "value")) {
            const value = params.value;
            if (Array.isArray(value) && value.length) {
              const parsed = toEpochMillis(value[0]);
              if (parsed !== null) {
                return parsed;
              }
            }
            const parsedDirect = toEpochMillis(value);
            if (parsedDirect !== null) {
              return parsedDirect;
            }
          }

          if (!params.event) {
            return null;
          }
          const evt = params.event.event || params.event;
          if (!evt || !Number.isFinite(evt.offsetX) || !Number.isFinite(evt.offsetY)) {
            return null;
          }
          try {
            if (!chart.containPixel({ gridIndex: 0 }, [evt.offsetX, evt.offsetY])) {
              return null;
            }
            const converted = chart.convertFromPixel({ gridIndex: 0 }, [evt.offsetX, evt.offsetY]);
            const raw = Array.isArray(converted) ? converted[0] : converted;
            return toEpochMillis(raw);
          } catch (_error) {
            return null;
          }
        }

        function attachCursorHandlers(mount) {
          if (!mount.chart || !mount.isTimeSeries) {
            return;
          }
          mount.chart.on("click", (params) => {
            const xValue = extractCursorFromEvent(mount.chart, params);
            if (xValue !== null) {
              state.cursorX = xValue;
              updateCursorAcrossTimeCharts();
            }
          });
        }

        function extentFromRows(rows, timeField) {
          const values = rows
            .map((row) => toEpochMillis(row[timeField]))
            .filter((value) => Number.isFinite(value));
          if (!values.length) {
            return null;
          }
          return {
            min: Math.min.apply(null, values),
            max: Math.max.apply(null, values),
          };
        }

        function extractZoomRange(chart, extent) {
          const option = chart.getOption ? chart.getOption() : {};
          const dataZoom = Array.isArray(option.dataZoom) ? option.dataZoom : [];

          for (const item of dataZoom) {
            const startValue = toFiniteNumberOrNull(item.startValue);
            const endValue = toFiniteNumberOrNull(item.endValue);
            if (startValue !== null && endValue !== null && endValue > startValue) {
              return { min: startValue, max: endValue, reset: false };
            }
          }

          if (!extent) {
            return null;
          }
          for (const item of dataZoom) {
            const start = toFiniteNumberOrNull(item.start);
            const end = toFiniteNumberOrNull(item.end);
            if (start === null || end === null) {
              continue;
            }
            if (start <= 0 && end >= 100) {
              return { min: extent.min, max: extent.max, reset: true };
            }
            const span = extent.max - extent.min;
            if (!(span > 0)) {
              continue;
            }
            const min = extent.min + (Math.max(0, Math.min(100, start)) / 100) * span;
            const max = extent.min + (Math.max(0, Math.min(100, end)) / 100) * span;
            if (max > min) {
              return { min: min, max: max, reset: false };
            }
          }
          return null;
        }

        function applyZoomToChart(mount) {
          if (!mount || !mount.chart || !mount.isAbsoluteTime) {
            return;
          }
          if (!Number.isFinite(state.zoom.minTime) || !Number.isFinite(state.zoom.maxTime)) {
            mount.chart.dispatchAction({ type: "dataZoom", xAxisIndex: 0, start: 0, end: 100 });
            return;
          }
          mount.chart.dispatchAction({
            type: "dataZoom",
            xAxisIndex: 0,
            startValue: state.zoom.minTime,
            endValue: state.zoom.maxTime,
          });
        }

        function propagateZoom(minTime, maxTime, sourceChartId, isReset) {
          if (state.zoom.syncing) {
            return;
          }
          state.zoom.syncing = true;
          try {
            if (isReset) {
              state.zoom.minTime = null;
              state.zoom.maxTime = null;
            } else {
              state.zoom.minTime = minTime;
              state.zoom.maxTime = maxTime;
            }
            chartMounts.forEach((mount, chartId) => {
              if (!mount.isAbsoluteTime || chartId === sourceChartId) {
                return;
              }
              applyZoomToChart(mount);
            });
          } finally {
            state.zoom.syncing = false;
          }
        }

        function scheduleZoomSync(minTime, maxTime, sourceChartId, isReset) {
          state.zoom.pending = {
            minTime: minTime,
            maxTime: maxTime,
            sourceChartId: sourceChartId,
            isReset: isReset,
          };
          if (state.zoom.raf !== null) {
            return;
          }
          state.zoom.raf = window.requestAnimationFrame(() => {
            state.zoom.raf = null;
            const pending = state.zoom.pending;
            state.zoom.pending = null;
            if (!pending) {
              return;
            }
            propagateZoom(pending.minTime, pending.maxTime, pending.sourceChartId, pending.isReset);
          });
        }

        function attachZoomHandlers(mount) {
          if (!mount.chart || !mount.isAbsoluteTime) {
            return;
          }
          mount.chart.on("dataZoom", () => {
            if (state.zoom.syncing) {
              return;
            }
            const range = extractZoomRange(mount.chart, mount.timeExtent);
            if (!range) {
              return;
            }
            scheduleZoomSync(range.min, range.max, mount.chartId, range.reset);
          });
        }

        function chartTitleFor(chartId) {
          return String(chartId || "").replace(/_/g, " ");
        }

        function barColor(index) {
          const palette = ["#1d4ed8", "#0f766e", "#b45309", "#b91c1c", "#334155"];
          return palette[index % palette.length];
        }

        function renderTimeBarLine(mount, rows, config) {
          const timeField = config.timeField;
          const barField = config.barField;
          const lineField = config.lineField;
          const lineLow = config.lineLow;
          const lineHigh = config.lineHigh;
          const extraLines = Array.isArray(config.extraLines) ? config.extraLines : [];
          const lowPowerField = config.lowPowerField;
          const flaggedField = config.flaggedField;

          const sorted = rows
            .map((row) => Object.assign({}, row, { __time: toEpochMillis(row[timeField]) }))
            .filter((row) => row.__time !== null)
            .sort((left, right) => left.__time - right.__time);

          if (!sorted.length) {
            return false;
          }

          mount.timeExtent = extentFromRows(sorted, "__time");
          const mainSeriesId = "main-" + mount.chartId;

          const barData = barField ? sorted.map((row) => [row.__time, toFiniteNumberOrNull(row[barField])]) : [];
          const lineData = lineField ? sorted.map((row) => [row.__time, toFiniteNumberOrNull(row[lineField])]) : [];
          const lowData = lineLow ? sorted.map((row) => [row.__time, toFiniteNumberOrNull(row[lineLow])]) : [];
          const highData = lineHigh ? sorted.map((row) => [row.__time, toFiniteNumberOrNull(row[lineHigh])]) : [];

          const lowPowerData = lowPowerField
            ? sorted
                .filter((row) => toBool(row[lowPowerField]) && toFiniteNumberOrNull(row[lineField]) !== null)
                .map((row) => [row.__time, toFiniteNumberOrNull(row[lineField])])
            : [];
          const flaggedData = flaggedField
            ? sorted
                .filter((row) => toBool(row[flaggedField]) && toFiniteNumberOrNull(row[lineField]) !== null)
                .map((row) => [row.__time, toFiniteNumberOrNull(row[lineField])])
            : [];

          const option = {
            animation: false,
            tooltip: { trigger: "axis", axisPointer: { type: "cross" } },
            legend: { bottom: 0 },
            grid: { left: 56, right: 56, top: 18, bottom: 88 },
            xAxis: { type: "time" },
            yAxis: [
              barField ? { type: "value", name: config.barAxisName || "Volume" } : { type: "value", name: config.lineAxisName || "Value" },
              {
                type: "value",
                name: config.lineAxisName || "Value",
                min: config.lineMin,
                max: config.lineMax,
              },
            ],
            dataZoom: [
              {
                type: "inside",
                xAxisIndex: [0],
                startValue: Number.isFinite(state.zoom.minTime) ? state.zoom.minTime : undefined,
                endValue: Number.isFinite(state.zoom.maxTime) ? state.zoom.maxTime : undefined,
              },
              {
                type: "slider",
                xAxisIndex: [0],
                bottom: 30,
                startValue: Number.isFinite(state.zoom.minTime) ? state.zoom.minTime : undefined,
                endValue: Number.isFinite(state.zoom.maxTime) ? state.zoom.maxTime : undefined,
              },
            ],
            series: [],
          };

          if (barField) {
            option.series.push({
              id: mainSeriesId,
              name: config.barSeriesName || "Volume",
              type: "bar",
              yAxisIndex: 0,
              data: barData,
              barMaxWidth: 11,
              itemStyle: { color: config.barColor || "#64748b", opacity: 0.45 },
              markLine: appendCursorMarkLine(mount.baseMarkLines || []),
            });
          } else {
            option.series.push({
              id: mainSeriesId,
              name: config.lineSeriesName || "Value",
              type: "line",
              yAxisIndex: 0,
              data: lineData,
              showSymbol: false,
              lineStyle: { color: config.lineColor || "#1d4ed8", width: 1.6 },
              markLine: appendCursorMarkLine(mount.baseMarkLines || []),
            });
          }

          if (lineField) {
            option.series.push({
              name: config.lineSeriesName || "Value",
              type: "line",
              yAxisIndex: barField ? 1 : 0,
              data: lineData,
              showSymbol: false,
              lineStyle: { color: config.lineColor || "#1d4ed8", width: 1.6 },
            });
          }
          if (lineLow) {
            option.series.push({
              name: "Wilson low",
              type: "line",
              yAxisIndex: barField ? 1 : 0,
              data: lowData,
              showSymbol: false,
              lineStyle: { color: "#60a5fa", width: 1, opacity: 0.7 },
            });
          }
          if (lineHigh) {
            option.series.push({
              name: "Wilson high",
              type: "line",
              yAxisIndex: barField ? 1 : 0,
              data: highData,
              showSymbol: false,
              lineStyle: { color: "#60a5fa", width: 1, opacity: 0.7 },
            });
          }

          extraLines.forEach((field, index) => {
            option.series.push({
              name: field.replace(/_/g, " "),
              type: "line",
              yAxisIndex: barField ? 1 : 0,
              data: sorted.map((row) => [row.__time, toFiniteNumberOrNull(row[field])]),
              showSymbol: false,
              lineStyle: {
                color: ["#0f172a", "#64748b", "#334155"][index % 3],
                width: 1.1,
                type: index === 0 ? "dashed" : "solid",
                opacity: 0.78,
              },
            });
          });

          if (flaggedData.length) {
            option.series.push({
              name: "Flagged",
              type: "scatter",
              yAxisIndex: barField ? 1 : 0,
              data: flaggedData,
              symbolSize: 9,
              itemStyle: { color: "#dc2626" },
            });
          }
          if (lowPowerData.length) {
            option.series.push({
              name: "Low-power",
              type: "scatter",
              yAxisIndex: barField ? 1 : 0,
              data: lowPowerData,
              symbolSize: 7,
              itemStyle: { color: "#f59e0b" },
            });
          }

          mount.chart.setOption(option, true);
          mount.seriesId = mainSeriesId;
          mount.isTimeSeries = true;
          mount.isAbsoluteTime = state.absoluteTimeSet.has(mount.chartId);
          return true;
        }

        function renderShiftHeatmap(mount, rows) {
          const subset = rows
            .map((row) => ({
              date: String(row.date || ""),
              slot: toNumber(row.slot_start_minute),
              value: toFiniteNumberOrNull(row.delta_from_slot_pro_rate),
              outlier: toBool(row.is_slot_outlier),
            }))
            .filter((row) => row.date && row.value !== null);

          if (!subset.length) {
            return false;
          }

          const dates = Array.from(new Set(subset.map((row) => row.date))).sort();
          const slots = Array.from(new Set(subset.map((row) => row.slot))).sort((a, b) => a - b);
          const dateMap = new Map(dates.map((value, index) => [value, index]));
          const slotMap = new Map(slots.map((value, index) => [value, index]));

          const values = [];
          const outliers = [];
          subset.forEach((row) => {
            const x = slotMap.get(row.slot);
            const y = dateMap.get(row.date);
            if (typeof x !== "number" || typeof y !== "number") {
              return;
            }
            values.push([x, y, row.value]);
            if (row.outlier) {
              outliers.push([x, y, row.value]);
            }
          });

          const maxAbs = Math.max(
            0.05,
            ...values.map((entry) => Math.abs(toNumber(entry[2]))).filter((value) => Number.isFinite(value))
          );

          mount.chart.setOption(
            {
              animation: false,
              tooltip: {
                position: "top",
                formatter: (params) => {
                  if (!Array.isArray(params.value)) {
                    return "";
                  }
                  const xIndex = params.value[0];
                  const yIndex = params.value[1];
                  const slotMinutes = slots[xIndex];
                  const hour = Math.floor(slotMinutes / 60);
                  const minute = slotMinutes % 60;
                  return (
                    "<strong>" +
                    dates[yIndex] +
                    " " +
                    String(hour).padStart(2, "0") +
                    ":" +
                    String(minute).padStart(2, "0") +
                    "</strong><br/>Delta: " +
                    toNumber(params.value[2]).toFixed(4)
                  );
                },
              },
              grid: { left: 72, right: 34, top: 20, bottom: 62 },
              xAxis: {
                type: "category",
                data: slots.map((slotMinutes) => {
                  const hour = Math.floor(slotMinutes / 60);
                  const minute = slotMinutes % 60;
                  return String(hour).padStart(2, "0") + ":" + String(minute).padStart(2, "0");
                }),
                axisLabel: { interval: Math.ceil(slots.length / 18) },
                splitArea: { show: true },
              },
              yAxis: {
                type: "category",
                data: dates,
                splitArea: { show: true },
              },
              visualMap: {
                min: -maxAbs,
                max: maxAbs,
                calculable: true,
                orient: "horizontal",
                left: "center",
                bottom: 10,
                inRange: { color: ["#1e3a8a", "#e2e8f0", "#b91c1c"] },
              },
              series: [
                {
                  name: "shift",
                  type: "heatmap",
                  data: values,
                  emphasis: { itemStyle: { shadowBlur: 10, shadowColor: "rgba(0,0,0,0.35)" } },
                },
                {
                  name: "slot outlier",
                  type: "scatter",
                  data: outliers,
                  symbolSize: 10,
                  itemStyle: { color: "#0f172a" },
                },
              ],
            },
            true
          );

          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        function renderDayHourHeatmap(mount, rows, valueField) {
          const subset = rows
            .map((row) => ({
              day: String(row.day_of_week || ""),
              hour: toNumber(row.hour),
              value: toFiniteNumberOrNull(row[valueField]),
            }))
            .filter((row) => row.day && row.value !== null);
          if (!subset.length) {
            return false;
          }

          const dayOrder = [
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
            "Sunday",
          ];
          const days = Array.from(new Set(subset.map((row) => row.day))).sort(
            (left, right) => dayOrder.indexOf(left) - dayOrder.indexOf(right)
          );
          const hours = Array.from(new Set(subset.map((row) => row.hour))).sort((a, b) => a - b);
          const dayMap = new Map(days.map((value, index) => [value, index]));
          const hourMap = new Map(hours.map((value, index) => [value, index]));

          const values = subset
            .map((row) => {
              const x = hourMap.get(row.hour);
              const y = dayMap.get(row.day);
              if (typeof x !== "number" || typeof y !== "number") {
                return null;
              }
              return [x, y, row.value];
            })
            .filter((entry) => entry !== null);

          mount.chart.setOption(
            {
              animation: false,
              tooltip: {
                position: "top",
                formatter: (params) => {
                  if (!Array.isArray(params.value)) {
                    return "";
                  }
                  return (
                    "<strong>" +
                    days[params.value[1]] +
                    " " +
                    String(hours[params.value[0]]).padStart(2, "0") +
                    ":00</strong><br/>Value: " +
                    toNumber(params.value[2]).toFixed(4)
                  );
                },
              },
              grid: { left: 76, right: 30, top: 18, bottom: 56 },
              xAxis: {
                type: "category",
                data: hours.map((hour) => String(hour).padStart(2, "0")),
                splitArea: { show: true },
              },
              yAxis: {
                type: "category",
                data: days,
                splitArea: { show: true },
              },
              visualMap: {
                min: Math.min.apply(
                  null,
                  values.map((entry) => toNumber(entry[2]))
                ),
                max: Math.max.apply(
                  null,
                  values.map((entry) => toNumber(entry[2]))
                ),
                orient: "horizontal",
                left: "center",
                bottom: 10,
                calculable: true,
                inRange: { color: ["#e2e8f0", "#93c5fd", "#1d4ed8"] },
              },
              series: [
                {
                  type: "heatmap",
                  data: values,
                  emphasis: { itemStyle: { shadowBlur: 8, shadowColor: "rgba(0,0,0,0.3)" } },
                },
              ],
            },
            true
          );
          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        function renderSimpleBar(mount, rows, xField, yField, title) {
          const subset = rows
            .map((row) => ({
              x: row[xField],
              y: toFiniteNumberOrNull(row[yField]),
            }))
            .filter((row) => row.x !== undefined && row.x !== null && row.y !== null)
            .slice(0, 200);
          if (!subset.length) {
            return false;
          }

          mount.chart.setOption(
            {
              animation: false,
              tooltip: { trigger: "axis", axisPointer: { type: "shadow" } },
              grid: { left: 64, right: 20, top: 26, bottom: 86 },
              xAxis: {
                type: "category",
                data: subset.map((row) => String(row.x)),
                axisLabel: { interval: 0, rotate: 34, color: "#334155" },
              },
              yAxis: { type: "value", name: title || "value", axisLabel: { color: "#334155" } },
              series: [
                {
                  type: "bar",
                  data: subset.map((row) => row.y),
                  itemStyle: { color: "#1d4ed8" },
                },
              ],
            },
            true
          );
          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        function renderScatter(mount, rows, xField, yField, colorField, sizeField) {
          const subset = rows
            .map((row) => {
              const x = toFiniteNumberOrNull(row[xField]);
              const y = toFiniteNumberOrNull(row[yField]);
              const c = colorField ? toFiniteNumberOrNull(row[colorField]) : null;
              const s = sizeField ? toFiniteNumberOrNull(row[sizeField]) : null;
              if (x === null || y === null) {
                return null;
              }
              return [x, y, c, s];
            })
            .filter((row) => row !== null)
            .slice(0, 15000);

          if (!subset.length) {
            return false;
          }

          const visualMap = colorField
            ? {
                min: Math.min.apply(
                  null,
                  subset.map((entry) => (entry[2] === null ? 0 : entry[2]))
                ),
                max: Math.max.apply(
                  null,
                  subset.map((entry) => (entry[2] === null ? 0 : entry[2]))
                ),
                orient: "horizontal",
                left: "center",
                bottom: 10,
                calculable: true,
              }
            : null;

          mount.chart.setOption(
            {
              animation: false,
              tooltip: {
                formatter: (params) => {
                  if (!Array.isArray(params.value)) {
                    return "";
                  }
                  return (
                    "<strong>x:</strong> " +
                    toNumber(params.value[0]).toFixed(4) +
                    "<br/><strong>y:</strong> " +
                    toNumber(params.value[1]).toFixed(4)
                  );
                },
              },
              grid: { left: 62, right: 24, top: 24, bottom: colorField ? 80 : 44 },
              xAxis: { type: "value", name: xField },
              yAxis: { type: "value", name: yField },
              visualMap: visualMap,
              series: [
                {
                  type: "scatter",
                  data: subset,
                  symbolSize: (value) => {
                    if (!sizeField || value[3] === null) {
                      return 7;
                    }
                    return Math.max(5, Math.min(18, Math.sqrt(Math.max(1, toNumber(value[3])))));
                  },
                  itemStyle: { color: colorField ? undefined : "#1d4ed8", opacity: 0.72 },
                },
              ],
            },
            true
          );

          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        function renderAutoChart(mount, rows) {
          if (!rows.length) {
            return false;
          }

          if (mount.chartId === "procon_swings_shift_heatmap") {
            return renderShiftHeatmap(mount, rows);
          }
          if (mount.chartId === "procon_swings_day_hour_heatmap") {
            return renderDayHourHeatmap(mount, rows, "pro_rate");
          }
          if (mount.chartId === "baseline_day_hour_volume") {
            return renderDayHourHeatmap(mount, rows, "n_total");
          }

          const timeOverrides = {
            baseline_volume_pro_rate: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "pro_rate",
              lineLow: "pro_rate_wilson_low",
              lineHigh: "pro_rate_wilson_high",
              lowPowerField: "is_low_power",
              lineAxisName: "Pro rate",
              lineMin: 0,
              lineMax: 1,
            },
            procon_swings_hero_bucket_trend: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "pro_rate",
              lineLow: "pro_rate_wilson_low",
              lineHigh: "pro_rate_wilson_high",
              lowPowerField: "is_low_power",
              flaggedField: "is_flagged",
              extraLines: ["baseline_pro_rate", "stable_lower", "stable_upper"],
              lineAxisName: "Pro rate",
              lineMin: 0,
              lineMax: 1,
            },
            changepoints_hero_timeline: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "pro_rate",
              lineLow: "pro_rate_wilson_low",
              lineHigh: "pro_rate_wilson_high",
              lowPowerField: "is_low_power",
              flaggedField: "is_changepoint",
              lineAxisName: "Pro rate",
              lineMin: 0,
              lineMax: 1,
            },
            rare_names_unique_ratio: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "unique_ratio",
              extraLines: ["threshold_unique_ratio"],
              lowPowerField: "is_low_power",
              lineAxisName: "Unique ratio",
              lineMin: 0,
              lineMax: 1,
            },
            org_anomalies_blank_rate: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "blank_org_rate",
              lineLow: "blank_org_rate_wilson_low",
              lineHigh: "blank_org_rate_wilson_high",
              extraLines: ["pro_blank_org_rate", "con_blank_org_rate"],
              lowPowerField: "is_low_power",
              lineAxisName: "Blank org rate",
              lineMin: 0,
              lineMax: 1,
            },
            voter_registry_match_rates: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "match_rate",
              lineLow: "match_rate_wilson_low",
              lineHigh: "match_rate_wilson_high",
              extraLines: ["pro_match_rate", "con_match_rate"],
              lowPowerField: "is_low_power",
              lineAxisName: "Match rate",
              lineMin: 0,
              lineMax: 1,
            },
            multivariate_score_timeline: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "anomaly_score",
              extraLines: ["anomaly_score_percentile"],
              lowPowerField: "is_low_power",
              lineAxisName: "Anomaly score",
            },
            composite_score_timeline: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "composite_score",
              lowPowerField: "is_low_power",
              lineAxisName: "Composite score",
            },
            duplicates_exact_bucket_concentration: {
              timeField: "bucket_start",
              barField: "n",
              lineField: null,
              barAxisName: "Duplicate count",
            },
            duplicates_near_cluster_timeline: {
              timeField: "first_seen",
              barField: "cluster_size",
              lineField: "n_records",
              lineAxisName: "Records",
              barAxisName: "Cluster size",
            },
            sortedness_bucket_ratio: {
              timeField: "bucket_start",
              barField: "n_records",
              lineField: "is_alphabetical",
              lineAxisName: "Alphabetical (0/1)",
              lineMin: 0,
              lineMax: 1,
            },
            org_anomalies_position_rates: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "blank_org_rate",
              lineLow: "blank_org_rate_wilson_low",
              lineHigh: "blank_org_rate_wilson_high",
              lowPowerField: "is_low_power",
              lineAxisName: "Blank org rate",
              lineMin: 0,
              lineMax: 1,
            },
            voter_registry_position_buckets: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "match_rate",
              lineLow: "match_rate_wilson_low",
              lineHigh: "match_rate_wilson_high",
              lowPowerField: "is_low_power",
              lineAxisName: "Match rate",
              lineMin: 0,
              lineMax: 1,
            },
            rare_names_singletons: {
              timeField: "first_seen",
              barField: "n_pro",
              lineField: "n_con",
              lineAxisName: "Counts",
              barAxisName: "Pro count",
            },
            rare_names_rarity_timeline: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "rarity_median",
              extraLines: ["rarity_p95"],
              lowPowerField: "is_low_power",
              lineAxisName: "Rarity",
            },
            bursts_hero_timeline: {
              timeField: "start_minute",
              barField: "observed_count",
              lineField: "rate_ratio",
              lineAxisName: "Rate ratio",
              barAxisName: "Observed count",
            },
          };

          if (Object.prototype.hasOwnProperty.call(timeOverrides, mount.chartId)) {
            return renderTimeBarLine(mount, rows, timeOverrides[mount.chartId]);
          }

          if (mount.chartId === "multivariate_feature_projection") {
            return renderScatter(mount, rows, "log_n_total", "pro_rate", "anomaly_score", "n_total");
          }
          if (mount.chartId === "multivariate_top_buckets") {
            return renderScatter(mount, rows, "n_total", "anomaly_score", "anomaly_score_percentile", "n_total");
          }
          if (mount.chartId === "duplicates_near_similarity") {
            return renderSimpleBar(mount, rows, "left_display_name", "similarity", "similarity");
          }
          if (mount.chartId === "composite_evidence_flags") {
            return renderSimpleBar(mount, rows, "flag", "count", "count");
          }
          if (mount.chartId === "off_hours_hourly_profile") {
            return renderSimpleBar(mount, rows, "hour", "n_total", "submissions");
          }
          if (mount.chartId === "off_hours_summary_compare") {
            return renderSimpleBar(mount, rows, "off_hours", "off_hours_pro_rate", "pro rate");
          }
          if (mount.chartId === "periodicity_clockface") {
            return renderSimpleBar(mount, rows, "minute_of_hour", "n_events", "events");
          }
          if (mount.chartId === "periodicity_autocorr") {
            return renderSimpleBar(mount, rows, "lag_minutes", "autocorr", "autocorr");
          }
          if (mount.chartId === "periodicity_spectrum") {
            return renderSimpleBar(mount, rows, "period_minutes", "power", "power");
          }
          if (mount.chartId === "baseline_top_names") {
            return renderSimpleBar(mount, rows, "display_name", "n", "count");
          }
          if (mount.chartId === "baseline_name_length_distribution") {
            return renderSimpleBar(mount, rows, "name_length", "n_names", "names");
          }
          if (mount.chartId === "bursts_significance_by_window") {
            return renderSimpleBar(mount, rows, "window_minutes", "n_significant", "significant windows");
          }
          if (mount.chartId === "bursts_null_distribution") {
            return renderSimpleBar(mount, rows, "iteration", "max_window_count", "max count");
          }
          if (mount.chartId === "procon_swings_null_distribution") {
            return renderSimpleBar(mount, rows, "iteration", "max_abs_delta_pro_rate", "max abs delta");
          }
          if (mount.chartId === "changepoints_magnitude") {
            return renderSimpleBar(mount, rows, "change_index", "abs_delta", "abs delta");
          }
          if (mount.chartId === "changepoints_hour_hist") {
            return renderSimpleBar(mount, rows, "change_hour", "n_changes", "changes");
          }
          if (mount.chartId === "duplicates_exact_top_names") {
            return renderSimpleBar(mount, rows, "display_name", "n", "count");
          }
          if (mount.chartId === "duplicates_exact_position_switch") {
            return renderSimpleBar(mount, rows, "display_name", "n", "count");
          }
          if (mount.chartId === "duplicates_near_cluster_size") {
            return renderSimpleBar(mount, rows, "cluster_size", "n_clusters", "clusters");
          }
          if (mount.chartId === "sortedness_bucket_summary") {
            return renderSimpleBar(mount, rows, "bucket_minutes", "alphabetical_ratio", "alphabetical ratio");
          }
          if (mount.chartId === "sortedness_minute_spikes") {
            return renderSimpleBar(mount, rows, "minute_bucket", "n_records", "records");
          }
          if (mount.chartId === "rare_names_weird_scores") {
            return renderSimpleBar(mount, rows, "sample_name", "weirdness_score", "weirdness");
          }
          if (mount.chartId === "org_anomalies_bursts") {
            return renderSimpleBar(mount, rows, "minute_bucket", "n", "count");
          }
          if (mount.chartId === "org_anomalies_top_orgs") {
            return renderSimpleBar(mount, rows, "organization_clean", "n", "count");
          }
          if (mount.chartId === "voter_registry_match_by_position") {
            return renderSimpleBar(mount, rows, "position_normalized", "match_rate", "match rate");
          }
          if (mount.chartId === "voter_registry_unmatched_names") {
            return renderSimpleBar(mount, rows, "canonical_name", "n_records", "count");
          }
          if (mount.chartId === "procon_swings_time_of_day_profile") {
            return renderSimpleBar(mount, rows, "slot_start_minute", "pro_rate", "pro rate");
          }
          if (mount.chartId === "composite_high_priority") {
            return renderSimpleBar(mount, rows, "minute_bucket", "composite_score", "score");
          }

          const timeField = inferTimeField(rows);
          if (timeField) {
            const fields = numericFields(rows[0]);
            const lineField = fields.find((field) => field !== "bucket_minutes") || null;
            if (lineField) {
              return renderTimeBarLine(mount, rows, {
                timeField: timeField,
                barField: null,
                lineField: lineField,
                lineAxisName: lineField,
              });
            }
          }

          const row = rows[0] || {};
          const numeric = numericFields(row);
          const stringField = Object.keys(row).find(
            (key) => typeof row[key] === "string" || typeof row[key] === "boolean"
          );

          if (stringField && numeric.length) {
            return renderSimpleBar(mount, rows, stringField, numeric[0], numeric[0]);
          }

          if (numeric.length >= 2) {
            return renderScatter(mount, rows, numeric[0], numeric[1], null, null);
          }

          return false;
        }

        function humanizeFieldName(field) {
          return String(field || "")
            .replace(/_/g, " ")
            .replace(/\s+/g, " ")
            .trim();
        }

        function fallbackColumnDescription(field) {
          const normalized = String(field || "").trim();
          const label = humanizeFieldName(normalized);
          if (!normalized) {
            return "Column value from detector output.";
          }
          if (normalized.startsWith("n_")) {
            return "Count of " + humanizeFieldName(normalized.slice(2)) + " in this row grouping.";
          }
          if (normalized.endsWith("_rate")) {
            return "Proportion metric for " + label + " on a 0 to 1 scale.";
          }
          if (normalized.endsWith("_ratio")) {
            return "Ratio metric for " + label + ".";
          }
          if (normalized.endsWith("_wilson_low")) {
            return "Lower Wilson confidence bound for " + humanizeFieldName(normalized.replace(/_wilson_low$/, "")) + ".";
          }
          if (normalized.endsWith("_wilson_high")) {
            return "Upper Wilson confidence bound for " + humanizeFieldName(normalized.replace(/_wilson_high$/, "")) + ".";
          }
          if (normalized.startsWith("is_")) {
            return "Boolean indicator for " + label + ".";
          }
          if (
            normalized.includes("minute") ||
            normalized.includes("hour") ||
            normalized.endsWith("_time") ||
            normalized.endsWith("_date")
          ) {
            return "Time coordinate for " + label + ".";
          }
          return "Detector output field for " + label + ".";
        }

        function tableColumnsFromRows(rows) {
          const columns = [];
          const seen = new Set();
          (Array.isArray(rows) ? rows : []).forEach((row) => {
            Object.keys(row || {}).forEach((field) => {
              if (seen.has(field)) {
                return;
              }
              seen.add(field);
              columns.push(field);
            });
          });
          return columns;
        }

        function renderColumnGlossary(parent, tableKey, rows) {
          if (!parent) {
            return;
          }
          const fields = tableColumnsFromRows(rows);
          if (!fields.length) {
            return;
          }
          const docsByTable = tableKey && tableColumnDocs[tableKey] ? tableColumnDocs[tableKey] : {};

          const glossary = document.createElement("section");
          glossary.className = "column-glossary";

          const title = document.createElement("p");
          title.className = "column-glossary-title";
          title.innerHTML = "<strong>Column glossary:</strong> what each field means in this table.";
          glossary.appendChild(title);

          const list = document.createElement("dl");
          list.className = "column-glossary-grid";
          fields.forEach((field) => {
            const wrapper = document.createElement("div");
            wrapper.className = "column-glossary-item";

            const key = document.createElement("dt");
            const code = document.createElement("code");
            code.textContent = field;
            key.appendChild(code);

            const value = document.createElement("dd");
            value.textContent = docsByTable[field] || fallbackColumnDescription(field);

            wrapper.appendChild(key);
            wrapper.appendChild(value);
            list.appendChild(wrapper);
          });
          glossary.appendChild(list);
          parent.appendChild(glossary);
        }

        function fallbackTableHelp(tableKey, rows) {
          const columns = tableColumnsFromRows(rows);
          const hasRates = columns.some((name) => name.endsWith("_rate") || name.includes("ratio"));
          const hasCounts = columns.some((name) => name.startsWith("n_") || name === "count" || name === "n");
          const hasTime = columns.some(
            (name) =>
              name.includes("minute") ||
              name.includes("hour") ||
              name.includes("bucket") ||
              name.includes("date")
          );
          const context = [];
          if (hasRates) {
            context.push("rate/proportion fields");
          }
          if (hasCounts) {
            context.push("count/volume fields");
          }
          if (hasTime) {
            context.push("time keys");
          }
          const contextText = context.length ? context.join(", ") : "detector-specific fields";
          const tableLabel = humanizeFieldName((tableKey || "table").replace(/\./g, " "));

          return {
            what_is_this:
              "This table preview shows row-level values for " +
              tableLabel +
              ", including " +
              contextText +
              ". It is the direct evidence layer behind chart summaries and is the best place to verify exact records.",
            why_it_matters:
              "The table is the audit source of truth behind chart aggregates. It confirms whether chart patterns are backed by real support and helps catch low-power or contradictory rows that can mislead visual interpretation.",
            how_to_interpret:
              "Sort and filter around flagged windows or categories, then compare neighboring rows to distinguish random outliers from consistent structure. Read identifier/time keys first, then volume and rate fields, then flags and derived scores.",
            what_to_look_for:
              "Look for multiple indicators moving together, especially when elevated values persist across adjacent rows with adequate support. Repeated combinations are stronger evidence than one extreme field in one row.",
            momentary_high_low:
              "A single high/low row can be event noise or low-support variance; verify in nearby rows and linked charts. Momentary highs often map to reminders or queue releases, while momentary lows often map to normal lulls or ingest timing.",
            extended_high_low:
              "Sustained high/low runs across many rows suggest process-level behavior and deserve higher confidence. Extended highs can indicate durable mobilization or process skew; extended lows can indicate reduced activity or missing data segments.",
            column_highlight:
              "Primary columns in preview: " +
              (columns.slice(0, 6).join(", ") || "none") +
              ". Use the glossary below for per-column definitions before drawing conclusions.",
          };
        }

        function renderTableHelpCard(parent, tableKey, rows) {
          if (!parent) {
            return;
          }
          const explicit = tableKey && tableHelpDocs[tableKey] ? tableHelpDocs[tableKey] : null;
          const help = explicit || fallbackTableHelp(tableKey, rows);

          const details = document.createElement("details");
          details.className = "table-help-card";

          const summary = document.createElement("summary");
          summary.textContent = "Table Help";
          details.appendChild(summary);

          const body = document.createElement("div");
          body.className = "table-help-body";

          const fields = [
            ["What is this?", help.what_is_this],
            ["Why this data matters", help.why_it_matters],
            ["How do I interpret this data?", help.how_to_interpret],
            ["What do I look for?", help.what_to_look_for],
            ["What could a momentary high/low mean?", help.momentary_high_low],
            ["What could an extended high/low mean?", help.extended_high_low],
            ["Column focus", help.column_highlight],
          ];
          fields.forEach((entry) => {
            if (!entry[1]) {
              return;
            }
            const p = document.createElement("p");
            p.innerHTML = "<strong>" + entry[0] + ":</strong> " + entry[1];
            body.appendChild(p);
          });

          renderColumnGlossary(body, tableKey, rows);
          details.appendChild(body);
          parent.appendChild(details);
        }

        function mountTable(container, rows, options) {
          const dataset = Array.isArray(rows) ? rows : [];
          if (!container || !dataset.length) {
            if (container) {
              container.innerHTML = "";
            }
            return false;
          }

          const columns = Array.from(
            new Set(dataset.flatMap((row) => Object.keys(row || {})))
          ).map((field) => ({
            title: field,
            field: field,
            headerFilter: "input",
          }));

          if (hasTabulator) {
            container.innerHTML = "";
            // eslint-disable-next-line no-new
            new window.Tabulator(
              container,
              Object.assign(
                {
                  data: dataset,
                  columns: columns,
                  layout: "fitDataStretch",
                  reactiveData: false,
                  pagination: true,
                  paginationSize: 8,
                  paginationCounter: "rows",
                  maxHeight: "340px",
                  placeholder: "No rows",
                  movableColumns: true,
                },
                options || {}
              )
            );
            return true;
          }

          const table = document.createElement("table");
          table.style.borderCollapse = "collapse";
          table.style.width = "100%";

          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");
          columns.forEach((column) => {
            const th = document.createElement("th");
            th.textContent = column.title;
            th.style.border = "1px solid #cbd5e1";
            th.style.padding = "0.35rem 0.45rem";
            th.style.background = "#f8fafc";
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          dataset.forEach((row) => {
            const tr = document.createElement("tr");
            columns.forEach((column) => {
              const td = document.createElement("td");
              const value = row[column.field];
              td.textContent = value === null || value === undefined ? "" : String(value);
              td.style.border = "1px solid #e2e8f0";
              td.style.padding = "0.3rem 0.45rem";
              tr.appendChild(td);
            });
            tbody.appendChild(tr);
          });
          table.appendChild(tbody);

          container.innerHTML = "";
          container.appendChild(table);
          return true;
        }

        function renderTablesForAnalysis(section, analysis) {
          const container = section.querySelector('[data-analysis-tables-for="' + analysis.id + '"]');
          if (!container) {
            return;
          }
          container.innerHTML = "";

          const detectorKey = analysis.detector;
          const detectorTables = detectorKey ? (reportData.table_previews || {})[detectorKey] || {} : {};
          const tableNames = Object.keys(detectorTables).sort();

          if (analysis.id === "baseline_profile") {
            const baselineCard = document.createElement("details");
            baselineCard.className = "table-group";
            baselineCard.open = true;
            const summary = document.createElement("summary");
            summary.textContent = "artifact_rows";
            baselineCard.appendChild(summary);
            const wrap = document.createElement("div");
            wrap.className = "table-wrap";
            const host = document.createElement("div");
            host.className = "table-host";
            const artifactRows = Object.entries(reportData.artifact_rows || {}).map((entry) => ({
              artifact: entry[0],
              rows: toNumber(entry[1]),
            }));
            renderTableHelpCard(wrap, "artifacts.artifact_rows", artifactRows);
            wrap.appendChild(host);
            baselineCard.appendChild(wrap);
            mountTable(host, artifactRows, { paginationSize: 10, maxHeight: "360px" });
            container.appendChild(baselineCard);
          }

          if (analysis.id === "composite_score" && Array.isArray(reportData.evidence_bundle_preview || [])) {
            const evidenceDetails = document.createElement("details");
            evidenceDetails.className = "table-group";
            evidenceDetails.open = true;
            const evidenceSummary = document.createElement("summary");
            evidenceSummary.textContent = "evidence_bundle_preview";
            evidenceDetails.appendChild(evidenceSummary);
            const evidenceWrap = document.createElement("div");
            evidenceWrap.className = "table-wrap";
            const evidenceHost = document.createElement("div");
            evidenceHost.className = "table-host";
            const evidenceRows = reportData.evidence_bundle_preview || [];
            renderTableHelpCard(
              evidenceWrap,
              "composite_score.evidence_bundle_preview",
              evidenceRows
            );
            evidenceWrap.appendChild(evidenceHost);
            evidenceDetails.appendChild(evidenceWrap);
            mountTable(evidenceHost, evidenceRows, {
              paginationSize: 10,
              maxHeight: "380px",
            });
            container.appendChild(evidenceDetails);
          }

          if (analysis.id === "rare_names") {
            const rarityTables = [
              ["rarity_coverage_preview", reportData.rarity_coverage_preview || []],
              ["rarity_unmatched_first_preview", reportData.rarity_unmatched_first_preview || []],
              ["rarity_unmatched_last_preview", reportData.rarity_unmatched_last_preview || []],
            ];
            const rarityTableKeys = {
              rarity_coverage_preview: "rare_names.rarity_coverage_preview",
              rarity_unmatched_first_preview: "rare_names.rarity_unmatched_first_preview",
              rarity_unmatched_last_preview: "rare_names.rarity_unmatched_last_preview",
            };
            rarityTables.forEach((entry, index) => {
              const rows = Array.isArray(entry[1]) ? entry[1] : [];
              if (!rows.length) {
                return;
              }
              const details = document.createElement("details");
              details.className = "table-group";
              details.open = index === 0;
              const summary = document.createElement("summary");
              summary.textContent = entry[0];
              details.appendChild(summary);
              const wrap = document.createElement("div");
              wrap.className = "table-wrap";
              const host = document.createElement("div");
              host.className = "table-host";
              renderTableHelpCard(wrap, rarityTableKeys[entry[0]] || "", rows);
              wrap.appendChild(host);
              details.appendChild(wrap);
              mountTable(host, rows, { paginationSize: 8, maxHeight: "320px" });
              container.appendChild(details);
            });
          }

          if (analysis.id === "periodicity" && Array.isArray(reportData.clockface_top_preview || [])) {
            const rows = reportData.clockface_top_preview || [];
            if (rows.length) {
              const details = document.createElement("details");
              details.className = "table-group";
              details.open = true;
              const summary = document.createElement("summary");
              summary.textContent = "clockface_top_preview";
              details.appendChild(summary);
              const wrap = document.createElement("div");
              wrap.className = "table-wrap";
              const host = document.createElement("div");
              host.className = "table-host";
              renderTableHelpCard(wrap, "periodicity.clockface_top_preview", rows);
              wrap.appendChild(host);
              details.appendChild(wrap);
              mountTable(host, rows, { paginationSize: 8, maxHeight: "300px" });
              container.appendChild(details);
            }
          }

          tableNames.forEach((tableName, index) => {
            const details = document.createElement("details");
            details.className = "table-group";
            details.open = index === 0 && container.childElementCount === 0;

            const summary = document.createElement("summary");
            summary.textContent = tableName;
            details.appendChild(summary);

            const wrap = document.createElement("div");
            wrap.className = "table-wrap";
            details.appendChild(wrap);

            const host = document.createElement("div");
            host.className = "table-host";
            wrap.appendChild(host);

            const rows = detectorTables[tableName] || [];
            const tableKey = detectorKey ? detectorKey + "." + tableName : tableName;
            renderTableHelpCard(wrap, tableKey, rows);
            mountTable(host, rows, {
              paginationSize: 8,
              maxHeight: "340px",
            });

            container.appendChild(details);
          });

          if (!container.childElementCount) {
            const empty = document.createElement("p");
            empty.className = "empty-message";
            empty.textContent = "No preview tables available for this analysis.";
            container.appendChild(empty);
          }
        }

        function renderChartMount(mount) {
          const rawRows = getChartRows(mount.chartId);
          if (!rawRows.length) {
            setEmptyForChart(mount.chartId, true);
            setChartNote(mount.chartId, "");
            return;
          }

          const bucketSelection = filterRowsByBucket(rawRows, mount.chartId);
          const rows = bucketSelection.rows;
          setChartNote(mount.chartId, bucketSelection.note || "");

          if (!rows.length) {
            setEmptyForChart(mount.chartId, true);
            return;
          }
          setEmptyForChart(mount.chartId, false);

          if (!hasEcharts) {
            return;
          }

          const didRender = renderAutoChart(mount, rows);
          setEmptyForChart(mount.chartId, !didRender);
          if (!didRender) {
            return;
          }

          updateCursorAcrossTimeCharts();
          if (mount.isAbsoluteTime) {
            applyZoomToChart(mount);
          }
        }

        function mountChartHost(host) {
          const chartId = String(host.getAttribute("data-chart-id") || "").trim();
          if (!chartId || chartMounts.has(chartId)) {
            return;
          }

          const mount = {
            chartId: chartId,
            host: host,
            chart: hasEcharts ? window.echarts.init(host) : null,
            isTimeSeries: false,
            isAbsoluteTime: false,
            seriesId: null,
            baseMarkLines: [],
            timeExtent: null,
          };
          chartMounts.set(chartId, mount);
          if (mount.chart) {
            chartInstances.push(mount.chart);
          }

          renderChartMount(mount);

          if (mount.chart && mount.isTimeSeries) {
            attachCursorHandlers(mount);
            attachZoomHandlers(mount);
            state.timeCharts.add(chartId);
          }
        }

        function mountSection(section, analysis) {
          if (!section || !analysis) {
            return;
          }
          const sectionId = String(analysis.id || "");
          if (!sectionId || mountedSections.has(sectionId)) {
            return;
          }

          const hosts = Array.from(section.querySelectorAll("[data-chart-id]"));
          hosts.forEach((host) => mountChartHost(host));
          renderTablesForAnalysis(section, analysis);
          mountedSections.add(sectionId);
        }

        function rerenderBucketAwareCharts() {
          chartMounts.forEach((mount) => {
            const rows = getChartRows(mount.chartId);
            if (!rows.length) {
              return;
            }
            if (!uniqueBucketOptions(rows).length) {
              return;
            }
            renderChartMount(mount);
          });
        }

        function initBucketTabs() {
          const root = document.getElementById("bucket-sync-tabs");
          const panel = document.getElementById("bucket-sync-panel");
          const note = document.getElementById("bucket-sync-note");
          const optionsRaw = Array.isArray(controls.global_bucket_options) ? controls.global_bucket_options : [];
          const options = Array.from(
            new Set(optionsRaw.map((value) => toFiniteNumberOrNull(value)).filter((value) => value !== null))
          ).sort((left, right) => left - right);

          if (!root || !panel || !options.length) {
            if (panel) {
              panel.classList.add("hidden");
            }
            return;
          }

          panel.classList.remove("hidden");
          const preferredDefault = toFiniteNumberOrNull(controls.default_bucket_minutes);
          state.activeBucket =
            preferredDefault !== null && options.includes(preferredDefault)
              ? preferredDefault
              : options.includes(30)
                ? 30
                : options[0];

          root.innerHTML = "";
          options.forEach((bucket) => {
            const tab = document.createElement("button");
            tab.type = "button";
            tab.className = "bucket-tab";
            tab.setAttribute("role", "tab");
            tab.setAttribute("aria-selected", state.activeBucket === bucket ? "true" : "false");
            tab.textContent = String(bucket) + "m";
            tab.addEventListener("click", () => {
              state.activeBucket = bucket;
              Array.from(root.querySelectorAll(".bucket-tab")).forEach((node) => {
                node.setAttribute("aria-selected", node.textContent === String(bucket) + "m" ? "true" : "false");
              });
              if (note) {
                note.textContent = "Applied " + bucket + "m across mounted bucket-aware charts.";
              }
              rerenderBucketAwareCharts();
            });
            root.appendChild(tab);
          });

          if (note) {
            note.textContent = "Default bucket: " + state.activeBucket + "m.";
          }
        }

        function initSidebarToggle() {
          const shell = document.getElementById("page-shell");
          const sidebar = document.getElementById("toc-sidebar");
          const toggle = document.getElementById("sidebar-toggle");
          const closeButton = document.getElementById("sidebar-close");
          const backdrop = document.getElementById("sidebar-backdrop");
          if (!shell || !sidebar || !toggle || !backdrop) {
            return;
          }

          const isMobile = () => window.matchMedia("(max-width: 1220px)").matches;
          const applyState = (open) => {
            shell.classList.toggle("sidebar-open", open);
            toggle.setAttribute("aria-expanded", open ? "true" : "false");
            toggle.textContent = open ? "Hide Menu" : "â˜° Menu";
          };

          applyState(!isMobile());

          toggle.addEventListener("click", () => {
            applyState(!shell.classList.contains("sidebar-open"));
          });
          if (closeButton) {
            closeButton.addEventListener("click", () => applyState(false));
          }
          backdrop.addEventListener("click", () => applyState(false));

          window.addEventListener("resize", () => {
            if (isMobile()) {
              if (!shell.classList.contains("sidebar-open")) {
                applyState(false);
              }
              return;
            }
            if (!shell.classList.contains("sidebar-open")) {
              applyState(true);
            }
          });
        }

        function initSidebarToc() {
          const sidebar = document.getElementById("toc-sidebar");
          const tocRoot = document.getElementById("report-toc");
          const contentRoot = document.getElementById("toc-content");
          if (!sidebar || !tocRoot || !contentRoot) {
            return;
          }

          const headings = Array.from(contentRoot.querySelectorAll(".toc-heading[id]"));
          if (!headings.length) {
            sidebar.classList.add("hidden");
            return;
          }

          let rendered = false;
          if (window.tocbot && typeof window.tocbot.init === "function") {
            if (typeof window.tocbot.destroy === "function") {
              window.tocbot.destroy();
            }
            window.tocbot.init({
              tocSelector: "#report-toc",
              contentSelector: "#toc-content",
              headingSelector: ".toc-heading",
              orderedList: false,
              collapseDepth: 6,
              scrollSmooth: false,
              disableTocScrollSync: true,
              listClass: "toc-list",
              linkClass: "toc-link",
              activeLinkClass: "tocbot-active-link",
            });
            rendered = tocRoot.querySelectorAll('a[href^="#"]').length > 0;
          }

          if (!rendered) {
            rendered = renderFallbackToc(headings, tocRoot);
          }

          if (!rendered) {
            sidebar.classList.add("hidden");
            return;
          }

          const links = Array.from(tocRoot.querySelectorAll('a[href^="#"]'));
          const trackedHeadings = links
            .map((link) => normalizeHashId(link.getAttribute("href")))
            .map((id) => document.getElementById(id))
            .filter((node) => !!node);
          if (!trackedHeadings.length) {
            sidebar.classList.add("hidden");
            return;
          }

          const pickActiveHeading = () => {
            const topOffset = 120;
            const lastHeading = trackedHeadings[trackedHeadings.length - 1];
            const doc = document.documentElement;
            const hashHeadingId = normalizeHashId(window.location.hash);
            const hashHeading = hashHeadingId ? document.getElementById(hashHeadingId) : null;
            if (hashHeading && trackedHeadings.includes(hashHeading)) {
              const rect = hashHeading.getBoundingClientRect();
              if (rect.top >= -24 && rect.top <= window.innerHeight * 1.5) {
                return hashHeading.id;
              }
            }
            if (window.scrollY + window.innerHeight >= doc.scrollHeight - 4) {
              return lastHeading ? lastHeading.id : "";
            }

            let active = trackedHeadings[0];
            let foundAboveOffset = false;
            trackedHeadings.forEach((heading) => {
              if (heading.getBoundingClientRect().top <= topOffset) {
                active = heading;
                foundAboveOffset = true;
              }
            });
            if (!foundAboveOffset) {
              const nearest = trackedHeadings
                .slice()
                .sort(
                  (left, right) =>
                    Math.abs(left.getBoundingClientRect().top - topOffset) -
                    Math.abs(right.getBoundingClientRect().top - topOffset)
                )[0];
              active = nearest || active;
            }
            return active ? active.id : "";
          };

          tocRoot.addEventListener("click", (event) => {
            const link = event.target.closest('a[href^="#"]');
            if (!link) {
              return;
            }
            if (event.button !== 0 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {
              return;
            }

            const headingId = normalizeHashId(link.getAttribute("href"));
            const target = headingId ? document.getElementById(headingId) : null;
            if (!target) {
              return;
            }

            const targetSection = target.closest("[data-analysis-id]");
            if (targetSection) {
              const allSections = Array.from(document.querySelectorAll("[data-analysis-id]"));
              for (const section of allSections) {
                const analysisId = String(section.getAttribute("data-analysis-id") || "");
                mountSection(section, analysisById.get(analysisId));
                if (section === targetSection) {
                  break;
                }
              }
            }

            event.preventDefault();
            const alignToTarget = (behavior) => {
              const nextTop = Math.max(0, target.getBoundingClientRect().top + window.scrollY - 76);
              window.scrollTo({ top: nextTop, behavior: behavior });
            };
            alignToTarget("smooth");
            window.setTimeout(() => alignToTarget("auto"), 320);
            window.setTimeout(() => alignToTarget("auto"), 920);
            setActiveTocHeading(headingId, true);
          });

          let ticking = false;
          const updateActiveHeading = () => {
            const headingId = pickActiveHeading();
            if (headingId) {
              setActiveTocHeading(headingId, true);
            }
          };
          const onScroll = () => {
            if (ticking) {
              return;
            }
            ticking = true;
            window.requestAnimationFrame(() => {
              ticking = false;
              updateActiveHeading();
            });
          };

          window.addEventListener("scroll", onScroll, { passive: true });
          window.addEventListener("hashchange", () => {
            const headingId = normalizeHashId(window.location.hash);
            if (headingId && document.getElementById(headingId)) {
              setActiveTocHeading(headingId, false);
            }
          });

          const initialHash = normalizeHashId(window.location.hash);
          if (initialHash && document.getElementById(initialHash)) {
            setActiveTocHeading(initialHash, false);
          } else {
            updateActiveHeading();
          }
        }

        function collectDetectorStats() {
          const summaries = reportData.detector_summaries || {};
          return Object.keys(summaries)
            .sort()
            .map((detectorName) => {
              const summary = summaries[detectorName] || {};
              const flaggedKeys = [
                "n_significant_windows",
                "n_anomaly_buckets",
                "n_high_priority_windows",
                "n_time_bucket_flags",
                "n_day_slot_outliers",
              ];
              const lowPowerKeys = [
                "n_low_power_windows",
                "n_low_power_buckets",
                "n_low_power_match_buckets",
                "n_low_power_time_buckets",
                "n_low_power_day_slots",
              ];
              return {
                detectorName: detectorName,
                flagged: flaggedKeys.reduce((acc, key) => (Object.prototype.hasOwnProperty.call(summary, key) ? toNumber(summary[key]) : acc), 0),
                lowPower: lowPowerKeys.reduce((acc, key) => (Object.prototype.hasOwnProperty.call(summary, key) ? toNumber(summary[key]) : acc), 0),
              };
            });
        }

        function buildKpis() {
          const artifactRows = Object.values(reportData.artifact_rows || {}).map((value) => toNumber(value));
          const detectorStats = collectDetectorStats();

          const setText = (id, value) => {
            const element = document.getElementById(id);
            if (element) {
              element.textContent = String(value);
            }
          };

          setText(
            "kpi-artifacts",
            artifactRows.reduce((acc, value) => acc + value, 0).toLocaleString()
          );
          setText("kpi-detectors", detectorStats.length.toLocaleString());
          setText(
            "kpi-flagged",
            detectorStats.reduce((acc, item) => acc + toNumber(item.flagged), 0).toLocaleString()
          );
          setText(
            "kpi-low-power",
            detectorStats.reduce((acc, item) => acc + toNumber(item.lowPower), 0).toLocaleString()
          );
        }

        function mountAllSections() {
          const sections = Array.from(document.querySelectorAll("[data-analysis-id]"));
          if (!sections.length) {
            return;
          }
          sections.forEach((section) => {
            const analysisId = String(section.getAttribute("data-analysis-id") || "");
            mountSection(section, analysisById.get(analysisId));
          });
        }

        buildKpis();
        initSidebarToggle();
        initBucketTabs();
        initSidebarToc();
        mountAllSections();
        updateCursorAcrossTimeCharts();

        window.addEventListener("resize", () => {
          chartInstances.forEach((instance) => {
            if (instance && typeof instance.resize === "function") {
              instance.resize();
            }
          });
        });
      })();
    </script>
  </body>
</html>
