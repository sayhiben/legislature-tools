<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Testifier Audit Report</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator_modern.min.css"
    />
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6.3.7/dist/tippy.css" />
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6.3.7/themes/light-border.css" />
    <style>
      :root {
        --bg: #f4f7fb;
        --surface: #ffffff;
        --surface-alt: #f8fafc;
        --ink: #0f172a;
        --ink-muted: #475569;
        --line: #d2dbe7;
        --brand: #1d4ed8;
        --ok: #0f766e;
        --warn: #b45309;
        --danger: #b91c1c;
        --bg-accent-a: #dbeafe;
        --bg-accent-b: #e2e8f0;
        --table-bg: #ffffff;
        --table-bg-alt: #f6f8fc;
        --table-bg-hover: #ecf2fb;
        --table-bg-selected: #dbeafe;
        --table-header-bg: linear-gradient(180deg, #fcfdff 0%, #f8fafc 100%);
        --table-header-text: #0f172a;
        --table-row-text: #0f172a;
        --table-border: #dbe4ef;
        --table-cell-border: #edf2f7;
        --table-footer-bg: #f8fafc;
        --table-muted-text: #475569;
        --table-input-bg: #ffffff;
        --table-input-text: #0f172a;
        --table-input-border: #cbd5e1;
        --table-page-active-bg: #dbeafe;
        --table-page-active-text: #1d4ed8;
        --table-page-hover-bg: #eff6ff;
        --table-page-border: #bfdbfe;
        --table-semantic-alert-bg: rgba(213, 94, 0, 0.1);
        --table-semantic-warn-bg: rgba(230, 159, 0, 0.1);
        --table-semantic-context-bg: rgba(0, 158, 115, 0.1);
      }

      * {
        box-sizing: border-box;
      }

      :root[data-theme="dark"] {
        --bg: #0a1220;
        --surface: #0f1b2d;
        --surface-alt: #112036;
        --ink: #e2e8f0;
        --ink-muted: #94a3b8;
        --line: #223147;
        --brand: #60a5fa;
        --ok: #34d399;
        --warn: #f59e0b;
        --danger: #f87171;
        --bg-accent-a: #1e293b;
        --bg-accent-b: #0f172a;
        --table-bg: #0f1e33;
        --table-bg-alt: #12253c;
        --table-bg-hover: #17304b;
        --table-bg-selected: #1d4f82;
        --table-header-bg: #15273f;
        --table-header-text: #e2e8f0;
        --table-row-text: #dbe5f2;
        --table-border: #2a425f;
        --table-cell-border: #2a425f;
        --table-footer-bg: #12253c;
        --table-muted-text: #94a3b8;
        --table-input-bg: #10223a;
        --table-input-text: #e2e8f0;
        --table-input-border: #365175;
        --table-page-active-bg: #1d4f82;
        --table-page-active-text: #dbeafe;
        --table-page-hover-bg: #17304b;
        --table-page-border: #60a5fa;
        --table-semantic-alert-bg: rgba(255, 138, 61, 0.16);
        --table-semantic-warn-bg: rgba(242, 193, 78, 0.16);
        --table-semantic-context-bg: rgba(47, 199, 154, 0.16);
      }

      body {
        margin: 0;
        color: var(--ink);
        background:
          radial-gradient(circle at top left, var(--bg-accent-a) 0%, transparent 28%),
          radial-gradient(circle at top right, var(--bg-accent-b) 0%, transparent 24%),
          var(--bg);
        font-family: "IBM Plex Sans", "Avenir Next", "Segoe UI", sans-serif;
        scroll-padding-top: 84px;
      }

      .page-shell {
        margin: 0 auto;
        max-width: 1640px;
        padding: 1.2rem 1rem 2.2rem;
        position: relative;
      }

      .report-layout {
        position: relative;
      }

      .report-main {
        margin-left: 0;
        min-width: 0;
        transition: margin-left 180ms ease;
      }

      .toc-sidebar {
        position: fixed;
        top: 1rem;
        left: max(1rem, calc((100vw - 1640px) / 2 + 1rem));
        width: 300px;
        max-height: calc(100vh - 2rem);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        z-index: 30;
        transform: translateX(calc(-100% - 1.2rem));
        opacity: 0;
        pointer-events: none;
        transition: transform 180ms ease, opacity 180ms ease;
      }

      .page-shell.sidebar-open .report-main {
        margin-left: 320px;
      }

      .page-shell.sidebar-open .toc-sidebar {
        transform: translateX(0);
        opacity: 1;
        pointer-events: auto;
      }

      .sidebar-launcher {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 45;
        border: 1px solid #bfdbfe;
        border-radius: 999px;
        background: #ffffff;
        color: #0f172a;
        font: inherit;
        font-size: 1rem;
        font-weight: 600;
        width: 2.2rem;
        height: 2.2rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.1);
        transition: opacity 140ms ease, transform 140ms ease, background 120ms ease;
      }

      .sidebar-launcher:hover {
        background: #eff6ff;
      }

      .page-shell.sidebar-open .sidebar-launcher {
        opacity: 0;
        pointer-events: none;
        transform: scale(0.95);
      }

      .sidebar-backdrop {
        display: none;
      }

      .sidebar-header {
        border-bottom: 1px solid #dbe4ef;
        margin-bottom: 0.72rem;
        padding-bottom: 0.64rem;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .sidebar-title-block {
        min-width: 0;
      }

      .sidebar-report-title {
        margin: 0;
        font-size: 1.04rem;
      }

      .sidebar-meta {
        margin-top: 0.28rem;
        margin-bottom: 0;
      }

      .sidebar-icon-button {
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #ffffff;
        color: #0f172a;
        font: inherit;
        font-size: 0.96rem;
        width: 2rem;
        height: 2rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      .sidebar-icon-button:hover {
        border-color: #93c5fd;
        background: #eff6ff;
      }

      .toc-title {
        margin-top: 0;
        margin-bottom: 0.2rem;
        font-size: 1rem;
        display: inline-flex;
        align-items: center;
        gap: 0.38rem;
      }

      .toc-note {
        margin-bottom: 0.48rem;
      }

      .sidebar-controls-panel {
        margin-top: 0.84rem;
        padding: 0.72rem;
      }

      .sidebar-controls-title {
        margin: 0 0 0.42rem;
        font-size: 0.94rem;
        display: inline-flex;
        align-items: center;
        gap: 0.38rem;
      }

      .sidebar-control-group {
        margin-top: 0.58rem;
      }

      .sidebar-control-group.zoom-state-active {
        border: 1px solid #bfdbfe;
        border-radius: 10px;
        padding: 0.42rem 0.46rem;
        background: #eff6ff;
      }

      .sidebar-control-row {
        display: flex;
        align-items: center;
        gap: 0.42rem;
        flex-wrap: wrap;
      }

      .sidebar-control-label {
        color: var(--ink-muted);
        font-size: 0.8rem;
        font-weight: 600;
        margin: 0;
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
      }

      .sidebar-divider {
        border: none;
        border-top: 1px solid var(--line);
        margin: 0.7rem 0 0.52rem;
      }

      .sidebar-toc-scroll {
        flex: 1 1 auto;
        min-height: 0;
        overflow-y: auto;
        padding-right: 0.16rem;
      }

      #report-toc {
        margin-top: 0.2rem;
      }

      #report-toc .toc-list {
        margin: 0;
        padding: 0;
        list-style: none;
      }

      #report-toc .toc-list-item {
        margin: 0;
      }

      #report-toc .toc-list-children {
        margin: 0.08rem 0 0.34rem 0.85rem;
        padding: 0;
        list-style: none;
      }

      #report-toc .toc-link {
        display: block;
        border-left: 2px solid transparent;
        border-radius: 6px;
        color: #334155;
        font-size: 0.86rem;
        line-height: 1.3;
        padding: 0.34rem 0.5rem;
        text-decoration: none;
        transition: background 120ms ease, border-color 120ms ease, color 120ms ease;
      }

      #report-toc .toc-link:hover {
        background: #eff6ff;
        color: #1e3a8a;
      }

      #report-toc .toc-link.is-active-link {
        border-left-color: #1d4ed8;
        background: #dbeafe;
        color: #1e40af;
        font-weight: 600;
      }

      #report-toc .toc-link-child {
        font-size: 0.8rem;
        padding-left: 0.62rem;
      }

      .help-tip {
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #ffffff;
        color: #334155;
        width: 1.15rem;
        height: 1.15rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.72rem;
        font-weight: 700;
        cursor: pointer;
        line-height: 1;
        padding: 0;
      }

      .help-tip:hover {
        border-color: #93c5fd;
        background: #eff6ff;
        color: #1e3a8a;
      }

      .theme-icon-controls {
        display: inline-flex;
        align-items: center;
        gap: 0.36rem;
      }

      .theme-icon-button {
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #ffffff;
        color: #0f172a;
        width: 2rem;
        height: 2rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.96rem;
        cursor: pointer;
      }

      .theme-icon-button:hover {
        border-color: #93c5fd;
        background: #eff6ff;
      }

      .theme-icon-button.is-active {
        border-color: #1d4ed8;
        background: #dbeafe;
        color: #1e3a8a;
      }

      .toc-heading {
        scroll-margin-top: 90px;
      }

      .hero {
        border: 1px solid #c7d2fe;
        border-radius: 14px;
        background: linear-gradient(128deg, #eff6ff 0%, #f8fafc 60%, #ecfeff 100%);
        padding: 1rem 1rem;
      }

      .report-attribution {
        margin-top: 1.15rem;
        padding-top: 0.72rem;
        padding-bottom: 0.72rem;
      }

      .report-attribution p {
        margin: 0;
      }

      .report-attribution a {
        color: #1d4ed8;
        font-weight: 600;
        text-decoration: underline;
        text-underline-offset: 2px;
      }

      h1,
      h2,
      h3,
      h4 {
        margin: 0.3rem 0 0.46rem;
        line-height: 1.25;
      }

      h1 {
        font-size: 1.8rem;
      }

      h2 {
        font-size: 1.28rem;
      }

      h3 {
        font-size: 1.04rem;
      }

      h4 {
        font-size: 0.95rem;
      }

      p {
        margin: 0.28rem 0 0.72rem;
      }

      code {
        background: #f1f5f9;
        border: 1px solid #e2e8f0;
        border-radius: 4px;
        padding: 0.1rem 0.28rem;
        font-family: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
        font-size: 0.88em;
      }

      .meta {
        color: var(--ink-muted);
        font-size: 0.92rem;
      }

      .subtle {
        color: var(--ink-muted);
        font-size: 0.88rem;
      }

      .panel {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: var(--surface);
        padding: 0.86rem;
      }

      .report-section {
        margin-top: 1.15rem;
      }

      .workflow-tabs {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.52rem;
      }

      .workflow-tab {
        display: inline-flex;
        align-items: center;
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #ffffff;
        color: #0f172a;
        font-size: 0.84rem;
        font-weight: 600;
        padding: 0.34rem 0.68rem;
        text-decoration: none;
      }

      .workflow-tab:hover {
        background: #eff6ff;
        border-color: #93c5fd;
      }

      .triage-actions {
        margin-top: 0.8rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.48rem;
      }

      .triage-lens-controls {
        margin-top: 0.72rem;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.5rem 0.8rem;
      }

      .triage-lens-label {
        color: var(--ink-muted);
        font-size: 0.82rem;
        font-weight: 600;
      }

      .triage-lens-select {
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        background: #ffffff;
        color: #0f172a;
        font: inherit;
        font-size: 0.84rem;
        padding: 0.3rem 0.5rem;
      }

      .warning-banner {
        margin-top: 0.5rem;
        border: 1px solid #fde68a;
        border-left: 4px solid #d97706;
        border-radius: 8px;
        background: #fffbeb;
        color: #92400e;
        padding: 0.5rem 0.62rem;
        font-size: 0.84rem;
      }

      .warning-banner.ok {
        border-color: #99f6e4;
        border-left-color: #0f766e;
        background: #f0fdfa;
        color: #115e59;
      }

      .definition-callout {
        margin-top: 0.75rem;
        border: 1px solid #bfdbfe;
        border-left: 4px solid #2563eb;
        border-radius: 10px;
        background: #eff6ff;
        padding: 0.65rem 0.72rem;
      }

      .definition-callout p {
        margin: 0.26rem 0;
        color: #1e3a8a;
      }

      .definition-callout strong {
        color: #1e40af;
      }

      .kpi-grid {
        margin-top: 0.75rem;
        display: grid;
        gap: 0.76rem;
        grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
      }

      .kpi-card {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: var(--surface-alt);
        padding: 0.7rem;
      }

      .kpi-label {
        color: var(--ink-muted);
        font-size: 0.84rem;
      }

      .kpi-value {
        margin-top: 0.12rem;
        font-size: 1.58rem;
        font-weight: 650;
        letter-spacing: -0.015em;
      }

      .kpi-meta {
        margin-top: 0.24rem;
        color: var(--ink-muted);
        font-size: 0.78rem;
        line-height: 1.35;
        min-height: 1.08rem;
      }

      .offhours-evidence-tier {
        margin-top: 0.72rem;
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #f8fafc;
        color: #334155;
        display: inline-flex;
        align-items: center;
        font-size: 0.83rem;
        font-weight: 620;
        padding: 0.28rem 0.66rem;
      }

      .offhours-evidence-tier.tier-strong {
        border-color: #0f766e;
        background: #ecfdf5;
        color: #065f46;
      }

      .offhours-evidence-tier.tier-descriptive {
        border-color: #b45309;
        background: #fffbeb;
        color: #92400e;
      }

      .offhours-evidence-tier.tier-none {
        border-color: #94a3b8;
        background: #f8fafc;
        color: #475569;
      }

      .zoom-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.48rem 0.72rem;
      }

      .control-button {
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        background: #ffffff;
        color: #0f172a;
        font: inherit;
        font-size: 0.82rem;
        font-weight: 600;
        padding: 0.34rem 0.58rem;
        cursor: pointer;
      }

      .control-button:hover {
        border-color: #93c5fd;
        background: #eff6ff;
      }

      .control-button:disabled {
        cursor: not-allowed;
        opacity: 0.55;
      }

      .zoom-range-label {
        margin: 0;
      }

      .zoom-status-chip {
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #f8fafc;
        color: #334155;
        font-size: 0.72rem;
        font-weight: 700;
        line-height: 1.35;
        padding: 0.12rem 0.48rem;
        white-space: nowrap;
      }

      .zoom-status-chip.is-active {
        border-color: #93c5fd;
        background: #dbeafe;
        color: #1e3a8a;
      }

      .zoom-active-banner {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.72rem;
        margin-bottom: 0.72rem;
        padding: 0.72rem 0.86rem;
        border: 1px solid #bfdbfe;
        border-left: 4px solid #1d4ed8;
        border-radius: 12px;
        background: #eff6ff;
        color: #1e3a8a;
        position: sticky;
        top: 0.76rem;
        z-index: 12;
      }

      .zoom-active-banner.hidden {
        display: none;
      }

      .zoom-active-banner-title {
        margin: 0;
        font-size: 0.8rem;
        font-weight: 700;
        letter-spacing: 0.02em;
        text-transform: uppercase;
      }

      .zoom-active-banner-text {
        margin: 0.2rem 0 0;
        font-size: 0.92rem;
        color: #1e3a8a;
      }

      .zoom-active-banner-meta {
        margin: 0.24rem 0 0;
        font-size: 0.8rem;
        color: #1e40af;
      }

      .zoom-active-banner-actions {
        display: inline-flex;
        align-items: center;
        gap: 0.46rem;
        flex-wrap: wrap;
      }

      .zoom-active-banner-chip {
        border: 1px solid #93c5fd;
        border-radius: 999px;
        background: #dbeafe;
        color: #1e3a8a;
        font-size: 0.78rem;
        font-weight: 700;
        padding: 0.2rem 0.52rem;
        white-space: nowrap;
      }

      .zoom-banner-button {
        border: 1px solid #93c5fd;
        border-radius: 999px;
        background: #ffffff;
        color: #1d4ed8;
        font: inherit;
        font-size: 0.82rem;
        font-weight: 600;
        padding: 0.24rem 0.62rem;
        cursor: pointer;
      }

      .zoom-banner-button:hover:not(:disabled) {
        background: #dbeafe;
      }

      .zoom-banner-button:disabled {
        cursor: not-allowed;
        opacity: 0.55;
      }

      .bucket-tablist {
        display: flex;
        gap: 0.45rem;
        flex-wrap: wrap;
      }

      .bucket-tab {
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #ffffff;
        color: #0f172a;
        font: inherit;
        font-size: 0.86rem;
        padding: 0.27rem 0.65rem;
        cursor: pointer;
      }

      .bucket-tab:hover {
        border-color: #93c5fd;
        background: #eff6ff;
      }

      .bucket-tab[aria-selected="true"] {
        border-color: #1d4ed8;
        background: #dbeafe;
        color: #1e3a8a;
        font-weight: 600;
      }

      .tiny-note {
        color: var(--ink-muted);
        font-size: 0.83rem;
      }

      .analysis-section {
        margin-top: 1.2rem;
        border: 1px solid var(--line);
        border-radius: 12px;
        background: var(--surface);
        padding: 0.9rem;
      }

      .analysis-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        border-radius: 999px;
        padding: 0.14rem 0.58rem;
        font-size: 0.74rem;
        font-weight: 700;
        letter-spacing: 0.01em;
        text-transform: uppercase;
      }

      .status-empty {
        color: #92400e;
        background: #fef3c7;
      }

      .status-disabled {
        color: #7f1d1d;
        background: #fee2e2;
      }

      .chart-host {
        width: 100%;
      }

      .chart-host-hero {
        min-height: 480px;
      }

      .chart-host-detail {
        min-height: 420px;
      }

      .chart-host.is-loading {
        position: relative;
        border: 1px solid #dbe4ef;
        border-radius: 10px;
        background: linear-gradient(90deg, #f8fafc 0%, #eef2f7 50%, #f8fafc 100%);
        background-size: 200% 100%;
        overflow: hidden;
      }

      .chart-host.is-loading::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          110deg,
          rgba(255, 255, 255, 0) 15%,
          rgba(255, 255, 255, 0.55) 48%,
          rgba(255, 255, 255, 0) 85%
        );
        transform: translateX(-120%);
        animation: chart-skeleton-shimmer 1.15s ease-in-out infinite;
        pointer-events: none;
      }

      .chart-host.is-loading::after {
        content: "Loading data...";
        position: absolute;
        left: 0.72rem;
        bottom: 0.6rem;
        color: #475569;
        font-size: 0.78rem;
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      @keyframes chart-skeleton-shimmer {
        0% {
          transform: translateX(-120%);
        }
        100% {
          transform: translateX(120%);
        }
      }

      .analysis-hero-block {
        margin-top: 0.66rem;
      }

      .analysis-help-card {
        margin-top: 0.8rem;
        border: 1px solid #dbe4ef;
        border-radius: 10px;
        background: #f8fafc;
        overflow: hidden;
      }

      .analysis-help-card > summary {
        cursor: pointer;
        list-style: none;
        padding: 0.58rem 0.7rem;
        font-weight: 600;
        border-bottom: 1px solid #e2e8f0;
        background: #f8fafc;
      }

      .analysis-help-card > summary::-webkit-details-marker {
        display: none;
      }

      .analysis-help-body {
        padding: 0.62rem 0.7rem;
      }

      .analysis-help-body p {
        margin: 0.3rem 0;
        font-size: 0.9rem;
        color: #334155;
      }

      .analysis-help-body ul {
        margin: 0.35rem 0 0.2rem 1.1rem;
        padding: 0;
      }

      .analysis-help-body li {
        margin: 0.32rem 0;
        color: #334155;
        font-size: 0.9rem;
      }

      .analysis-help-body strong {
        color: #0f172a;
      }

      .analysis-detail-grid {
        margin-top: 0.82rem;
        display: grid;
        gap: 0.82rem;
        grid-template-columns: minmax(0, 1fr);
      }

      .detail-card {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: var(--surface-alt);
        padding: 0.66rem;
      }

      .detail-title {
        margin-bottom: 0.5rem;
      }

      .chart-note {
        margin: 0.28rem 0 0;
      }

      .chart-help-card {
        margin-top: 0.42rem;
        border: 1px solid #dbe4ef;
        border-radius: 8px;
        background: #ffffff;
        overflow: hidden;
      }

      .chart-help-card > summary {
        cursor: pointer;
        list-style: none;
        font-weight: 600;
        padding: 0.46rem 0.56rem;
        background: #f8fafc;
        border-bottom: 1px solid #e2e8f0;
      }

      .chart-help-card > summary::-webkit-details-marker {
        display: none;
      }

      .chart-help-body {
        padding: 0.46rem 0.56rem;
      }

      .chart-help-body p {
        margin: 0.12rem 0 0.38rem;
        font-size: 0.86rem;
        line-height: 1.44;
        color: #334155;
      }

      .chart-help-body ul {
        margin: 0 0 0 1.05rem;
        padding: 0;
      }

      .chart-help-body li {
        margin: 0.24rem 0;
        color: #334155;
        font-size: 0.86rem;
        line-height: 1.4;
      }

      .empty-message {
        margin-top: 0.36rem;
        color: var(--ink-muted);
        font-style: italic;
      }

      .report-busy-indicator {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 60;
        display: inline-flex;
        align-items: center;
        gap: 0.48rem;
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 8px 22px rgba(15, 23, 42, 0.14);
        color: #0f172a;
        font-size: 0.82rem;
        font-weight: 600;
        padding: 0.38rem 0.7rem;
        backdrop-filter: blur(2px);
      }

      .busy-spinner {
        width: 0.92rem;
        height: 0.92rem;
        border: 2px solid #bfdbfe;
        border-top-color: #1d4ed8;
        border-radius: 50%;
        animation: busy-spin 760ms linear infinite;
      }

      @keyframes busy-spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .hidden {
        display: none !important;
      }

      .analysis-tables {
        margin-top: 0.85rem;
        display: grid;
        gap: 0.72rem;
        grid-template-columns: minmax(0, 1fr);
      }

      details.table-group {
        border: 1px solid #dbe4ef;
        border-radius: 10px;
        background: #ffffff;
        overflow: hidden;
      }

      details.table-group > summary {
        cursor: pointer;
        list-style: none;
        background: #f8fafc;
        border-bottom: 1px solid #e2e8f0;
        padding: 0.56rem 0.7rem;
        font-weight: 600;
      }

      details.table-group > summary::-webkit-details-marker {
        display: none;
      }

      .table-wrap {
        padding: 0.66rem;
      }

      .column-glossary {
        margin-bottom: 0.58rem;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        background: #f8fafc;
        padding: 0.46rem 0.54rem;
      }

      .column-glossary-title {
        margin: 0 0 0.38rem;
        color: #0f172a;
        font-size: 0.82rem;
      }

      .column-glossary-grid {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 0.36rem 0.62rem;
      }

      .column-glossary-item {
        margin: 0;
      }

      .column-glossary-item dt {
        margin: 0;
        font-family: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
        font-size: 0.76rem;
        color: #1e293b;
      }

      .column-glossary-item dd {
        margin: 0.16rem 0 0;
        color: #475569;
        font-size: 0.78rem;
        line-height: 1.28;
      }

      .table-host {
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        overflow: auto;
        background: #ffffff;
        width: 100%;
      }

      .table-help-card {
        margin-bottom: 0.62rem;
        border: 1px solid #dbe4ef;
        border-radius: 8px;
        background: #ffffff;
        overflow: hidden;
      }

      .table-help-card > summary {
        cursor: pointer;
        list-style: none;
        font-weight: 600;
        padding: 0.5rem 0.58rem;
        border-bottom: 1px solid #e2e8f0;
        background: #f8fafc;
      }

      .table-help-card > summary::-webkit-details-marker {
        display: none;
      }

      .table-help-body {
        padding: 0.5rem 0.58rem;
      }

      .table-help-body p {
        margin: 0.22rem 0;
        color: #334155;
        font-size: 0.86rem;
        line-height: 1.44;
      }

      .methodology-list {
        margin: 0.2rem 0 0;
        padding-left: 1.1rem;
      }

      .methodology-list li {
        margin: 0.3rem 0;
        color: #334155;
        font-size: 0.86rem;
        line-height: 1.44;
      }

      .tabulator {
        border: 1px solid var(--table-border);
        background: var(--table-bg);
        font-size: 0.9rem;
        color: var(--table-row-text);
      }

      .tabulator .tabulator-header {
        border-bottom: 1px solid var(--table-border);
        background: var(--table-header-bg);
        color: var(--table-header-text);
      }

      .tabulator .tabulator-header .tabulator-col {
        background: var(--table-header-bg);
        border-right: 1px solid var(--table-border);
        color: var(--table-header-text);
        font-weight: 600;
      }

      .tabulator .tabulator-header .tabulator-col:hover,
      .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
        background: var(--table-bg-hover);
      }

      .tabulator .tabulator-header .tabulator-col .tabulator-col-title {
        color: inherit;
      }

      .tabulator .tabulator-tableholder .tabulator-table {
        background: var(--table-bg);
        color: var(--table-row-text);
      }

      .tabulator .tabulator-tableholder .tabulator-table .tabulator-row {
        --table-row-bg: var(--table-bg);
        background: var(--table-row-bg);
        border-bottom: 1px solid var(--table-cell-border);
        color: var(--table-row-text);
        margin-bottom: 0;
      }

      .tabulator .tabulator-tableholder .tabulator-table .tabulator-row:nth-child(even),
      .tabulator .tabulator-tableholder .tabulator-table .tabulator-row:nth-child(even) .tabulator-cell,
      .tabulator-row:nth-child(2n),
      .tabulator-row:nth-child(2n) .tabulator-cell {
        --table-row-bg: var(--table-bg-alt);
        background: var(--table-row-bg);
      }

      .tabulator .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
        background: var(--table-row-bg);
        border-right: 1px solid var(--table-cell-border);
        color: var(--table-row-text);
      }

      .tabulator .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell:first-child {
        background: var(--table-row-bg) !important;
        border-left: 1px solid var(--table-cell-border);
      }

      .tabulator
        .tabulator-tableholder
        .tabulator-table
        .tabulator-row
        .tabulator-cell:first-child.table-cell-semantic-alert,
      .tabulator
        .tabulator-tableholder
        .tabulator-table
        .tabulator-row
        .tabulator-cell:first-child.table-cell-semantic-warn,
      .tabulator
        .tabulator-tableholder
        .tabulator-table
        .tabulator-row
        .tabulator-cell:first-child.table-cell-semantic-context {
        border-left: 1px solid var(--table-cell-border);
      }

      .tabulator .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell.tabulator-row-header {
        background: var(--table-bg-alt);
        color: var(--table-row-text);
      }

      .tabulator .tabulator-row:hover,
      .tabulator .tabulator-row.tabulator-selectable:hover,
      .tabulator .tabulator-row:hover .tabulator-cell {
        background: var(--table-bg-hover);
      }

      .tabulator .tabulator-row.tabulator-selected,
      .tabulator .tabulator-row.tabulator-selected .tabulator-cell,
      .tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-selected .tabulator-cell {
        background: var(--table-bg-selected);
      }

      .tabulator .tabulator-cell {
        border-right: 1px solid var(--table-cell-border);
        color: var(--table-row-text);
      }

      .tabulator .tabulator-cell.table-cell-semantic-alert,
      .table-wrap table td.table-cell-semantic-alert {
        background: var(--table-semantic-alert-bg) !important;
        font-weight: 600;
      }

      .tabulator .tabulator-cell.table-cell-semantic-warn,
      .table-wrap table td.table-cell-semantic-warn {
        background: var(--table-semantic-warn-bg) !important;
      }

      .tabulator .tabulator-cell.table-cell-semantic-context,
      .table-wrap table td.table-cell-semantic-context {
        background: var(--table-semantic-context-bg) !important;
      }

      .tabulator .tabulator-footer {
        border-top: 1px solid var(--table-border);
        background: var(--table-footer-bg);
        color: var(--table-muted-text);
      }

      .tabulator .tabulator-footer .tabulator-page {
        border: 1px solid transparent;
        border-radius: 6px;
        color: var(--table-row-text);
      }

      .tabulator .tabulator-footer .tabulator-page:hover {
        background: var(--table-page-hover-bg);
        border-color: var(--table-page-border);
      }

      .tabulator .tabulator-footer .tabulator-page.active {
        background: var(--table-page-active-bg);
        color: var(--table-page-active-text);
        border-color: var(--table-page-border);
      }

      .tabulator .tabulator-footer .tabulator-page-counter,
      .tabulator .tabulator-footer .tabulator-page-size,
      .tabulator .tabulator-footer .tabulator-paginator,
      .tabulator .tabulator-footer label {
        color: var(--table-muted-text);
      }

      .tabulator .tabulator-footer select {
        border: 1px solid var(--table-input-border);
        background: var(--table-input-bg);
        color: var(--table-input-text);
        border-radius: 6px;
      }

      .tabulator .tabulator-header-filter input {
        border-radius: 6px;
        border: 1px solid var(--table-input-border);
        background: var(--table-input-bg);
        color: var(--table-input-text);
      }

      .tabulator .tabulator-header-filter input::placeholder {
        color: var(--table-muted-text);
        opacity: 1;
      }

      .tabulator .tabulator-group {
        background: var(--table-header-bg);
        color: var(--table-header-text);
      }

      :root[data-theme="dark"] .hero {
        border-color: #1e3a5f;
        background: linear-gradient(128deg, #10223a 0%, #101b2e 60%, #102932 100%);
      }

      :root[data-theme="dark"] .chart-host.is-loading {
        border-color: #355274;
        background: linear-gradient(90deg, #102236 0%, #142b44 50%, #102236 100%);
      }

      :root[data-theme="dark"] .chart-host.is-loading::before {
        background: linear-gradient(
          110deg,
          rgba(226, 232, 240, 0) 15%,
          rgba(226, 232, 240, 0.26) 48%,
          rgba(226, 232, 240, 0) 85%
        );
      }

      :root[data-theme="dark"] .chart-host.is-loading::after {
        color: #cbd5e1;
      }

      :root[data-theme="dark"] .report-attribution a {
        color: #93c5fd;
      }

      :root[data-theme="dark"] .panel,
      :root[data-theme="dark"] .analysis-section,
      :root[data-theme="dark"] .kpi-card,
      :root[data-theme="dark"] .detail-card,
      :root[data-theme="dark"] .toc-sidebar,
      :root[data-theme="dark"] .analysis-help-card,
      :root[data-theme="dark"] details.table-group,
      :root[data-theme="dark"] .table-host,
      :root[data-theme="dark"] .table-help-card,
      :root[data-theme="dark"] .chart-help-card {
        background: var(--surface);
        border-color: var(--line);
      }

      :root[data-theme="dark"] .analysis-help-card > summary,
      :root[data-theme="dark"] details.table-group > summary,
      :root[data-theme="dark"] .table-help-card > summary,
      :root[data-theme="dark"] .chart-help-card > summary {
        background: #15273f;
        border-color: var(--line);
      }

      :root[data-theme="dark"] .sidebar-launcher,
      :root[data-theme="dark"] .sidebar-icon-button,
      :root[data-theme="dark"] .help-tip,
      :root[data-theme="dark"] .theme-icon-button,
      :root[data-theme="dark"] .control-button,
      :root[data-theme="dark"] .bucket-tab,
      :root[data-theme="dark"] .workflow-tab,
      :root[data-theme="dark"] .triage-lens-select {
        background: #0f1e33;
        color: var(--ink);
        border-color: #365175;
      }

      :root[data-theme="dark"] .workflow-tab:hover,
      :root[data-theme="dark"] .bucket-tab:hover,
      :root[data-theme="dark"] .control-button:hover,
      :root[data-theme="dark"] .sidebar-launcher:hover,
      :root[data-theme="dark"] .sidebar-icon-button:hover,
      :root[data-theme="dark"] .help-tip:hover,
      :root[data-theme="dark"] .theme-icon-button:hover,
      :root[data-theme="dark"] .theme-icon-button:hover {
        background: #17304b;
      }

      :root[data-theme="dark"] .bucket-tab[aria-selected="true"] {
        border-color: #60a5fa;
        background: #1d4f82;
        color: #dbeafe;
      }

      :root[data-theme="dark"] .theme-icon-button.is-active {
        border-color: #60a5fa;
        background: #1d4f82;
        color: #dbeafe;
      }

      :root[data-theme="dark"] .sidebar-control-group.zoom-state-active {
        border-color: rgba(96, 165, 250, 0.42);
        background: rgba(29, 79, 130, 0.2);
      }

      :root[data-theme="dark"] .zoom-status-chip {
        border-color: #365175;
        background: #0f1e33;
        color: #cbd5e1;
      }

      :root[data-theme="dark"] .zoom-status-chip.is-active {
        border-color: rgba(96, 165, 250, 0.62);
        background: rgba(29, 79, 130, 0.56);
        color: #dbeafe;
      }

      :root[data-theme="dark"] .zoom-active-banner {
        border-color: #2a4365;
        border-left-color: #60a5fa;
        background: #12253c;
        color: #dbeafe;
      }

      :root[data-theme="dark"] .zoom-active-banner-text {
        color: #dbeafe;
      }

      :root[data-theme="dark"] .zoom-active-banner-meta {
        color: #bfdbfe;
      }

      :root[data-theme="dark"] .zoom-active-banner-chip {
        background: #1d4f82;
        color: #dbeafe;
        border-color: #60a5fa;
      }

      :root[data-theme="dark"] .zoom-banner-button {
        background: #0f1e33;
        color: #dbeafe;
        border-color: #365175;
      }

      :root[data-theme="dark"] .zoom-banner-button:hover:not(:disabled) {
        background: #17304b;
      }

      :root[data-theme="dark"] #report-toc .toc-link {
        color: #d1d9e6;
      }

      :root[data-theme="dark"] #report-toc .toc-link:hover {
        background: #17304b;
        color: #dbeafe;
      }

      :root[data-theme="dark"] #report-toc .toc-link.is-active-link {
        border-left-color: #60a5fa;
        background: #1d4f82;
        color: #dbeafe;
      }

      :root[data-theme="dark"] .warning-banner {
        background: #3b2f0f;
        border-color: #8c6d1f;
        color: #fcd34d;
      }

      :root[data-theme="dark"] .warning-banner.ok {
        background: #0f2f28;
        border-color: #1f6f63;
        color: #99f6e4;
      }

      :root[data-theme="dark"] .definition-callout {
        background: #10223a;
        border-color: #365175;
      }

      :root[data-theme="dark"] .offhours-evidence-tier {
        border-color: #334155;
        background: #15273f;
        color: #cbd5e1;
      }

      :root[data-theme="dark"] .offhours-evidence-tier.tier-strong {
        border-color: #0f766e;
        background: rgba(15, 118, 110, 0.2);
        color: #99f6e4;
      }

      :root[data-theme="dark"] .offhours-evidence-tier.tier-descriptive {
        border-color: #b45309;
        background: rgba(180, 83, 9, 0.24);
        color: #fcd34d;
      }

      :root[data-theme="dark"] .offhours-evidence-tier.tier-none {
        border-color: #475569;
        background: #15273f;
        color: #94a3b8;
      }

      :root[data-theme="dark"] .definition-callout p,
      :root[data-theme="dark"] .methodology-list li,
      :root[data-theme="dark"] .table-help-body p,
      :root[data-theme="dark"] .analysis-help-body p,
      :root[data-theme="dark"] .analysis-help-body li,
      :root[data-theme="dark"] .chart-help-body p,
      :root[data-theme="dark"] .chart-help-body li {
        color: #cbd5e1;
      }

      :root[data-theme="dark"] code,
      :root[data-theme="dark"] .column-glossary {
        background: #12253c;
        border-color: #2a425f;
      }

      @media (max-width: 1220px) {
        .toc-sidebar {
          left: 0;
          top: 0;
          width: min(92vw, 360px);
          max-height: 100vh;
          height: 100vh;
          border-radius: 0 12px 12px 0;
        }

        .page-shell.sidebar-open .report-main {
          margin-left: 0;
        }

        .sidebar-backdrop {
          position: fixed;
          inset: 0;
          background: rgba(15, 23, 42, 0.46);
          z-index: 25;
        }

        .page-shell.sidebar-open .sidebar-backdrop {
          display: block;
        }

        .analysis-detail-grid {
          grid-template-columns: minmax(0, 1fr);
        }

        .chart-host-hero {
          min-height: 430px;
        }
      }

      @media (max-width: 820px) {
        .page-shell {
          padding: 0.92rem 0.72rem 1.45rem;
        }

        h1 {
          font-size: 1.52rem;
        }

        h2 {
          font-size: 1.16rem;
        }

        .chart-host-hero {
          min-height: 360px;
        }

        .chart-host-detail {
          min-height: 320px;
        }

        .zoom-active-banner {
          top: 0.64rem;
          flex-direction: column;
          align-items: flex-start;
        }

        .sidebar-launcher {
          top: 0.72rem;
          left: 0.72rem;
          width: 2.1rem;
          height: 2.1rem;
          font-size: 0.95rem;
        }

        .column-glossary-grid {
          grid-template-columns: minmax(0, 1fr);
        }

        .report-busy-indicator {
          top: 0.72rem;
          right: 0.72rem;
          max-width: calc(100vw - 1.44rem);
        }
      }
    </style>
  </head>
  <body>
    <div class="page-shell" id="page-shell">
      <button
        id="sidebar-launcher"
        class="sidebar-launcher"
        type="button"
        aria-controls="toc-sidebar"
        aria-expanded="false"
        aria-label="Show menu"
      >
        ☰
      </button>
      <div class="sidebar-backdrop" id="sidebar-backdrop"></div>
      <div class="report-layout">
        <aside class="toc-sidebar panel" id="toc-sidebar" aria-label="Section navigation">
          <div class="sidebar-header">
            <div class="sidebar-title-block">
              <h1 class="sidebar-report-title">Testifier Audit Report</h1>
              <p class="tiny-note sidebar-meta">Generated (America/Los_Angeles): <code>2026-02-21T22:33:54.522472-08:00</code></p>
            </div>
            <button
              id="sidebar-toggle"
              class="sidebar-icon-button"
              type="button"
              aria-controls="toc-sidebar"
              aria-expanded="false"
              aria-label="Hide menu"
            >
              ←
            </button>
          </div>

          <section class="sidebar-controls-panel panel" id="sidebar-controls-panel">
            <h3 class="sidebar-controls-title">
              Linked Controls
              <button
                class="help-tip"
                type="button"
                data-tooltip="Bucket changes rerender bucket-aware charts; absolute-time charts share linked zoom and cursor context."
                aria-label="Linked controls help"
              >
                ?
              </button>
            </h3>
            <div class="sidebar-control-group" id="bucket-sync-panel">
              <p class="sidebar-control-label">
                Bucket
                <button
                  class="help-tip"
                  type="button"
                  data-tooltip="Choose one bucket and all bucket-aware charts update together when that bucket exists."
                  aria-label="Bucket selector help"
                >
                  ?
                </button>
              </p>
              <div class="bucket-tablist" id="bucket-sync-tabs" role="tablist" aria-label="Linked bucket selector"></div>
            </div>
            <div class="sidebar-control-group hidden" id="zoom-sync-panel">
              <div class="sidebar-control-row">
                <p class="sidebar-control-label">
                  Zoom
                  <button
                    class="help-tip"
                    type="button"
                    data-tooltip="Absolute-time charts share one zoom range. Reset returns all linked charts to full timeline."
                    aria-label="Linked zoom help"
                  >
                    ?
                  </button>
                </p>
                <span id="zoom-status-chip" class="zoom-status-chip">Full timeline</span>
                <button id="zoom-reset-button" class="control-button" type="button">Reset</button>
              </div>
              <p class="tiny-note zoom-range-label" id="zoom-range-label"></p>
            </div>
            <div class="sidebar-control-group">
              <div class="sidebar-control-row">
                <p class="sidebar-control-label">
                  Theme
                  <button
                    class="help-tip"
                    type="button"
                    data-tooltip="Theme changes only appearance; detector semantics and alert logic are unchanged."
                    aria-label="Theme selector help"
                  >
                    ?
                  </button>
                </p>
                <div class="theme-icon-controls" id="theme-controls" role="group" aria-label="Theme controls">
                  <button
                    id="theme-light-button"
                    class="theme-icon-button"
                    type="button"
                    data-theme-option="light"
                    aria-label="Use light theme"
                    title="Light theme"
                  >
                    ☀
                  </button>
                  <button
                    id="theme-dark-button"
                    class="theme-icon-button"
                    type="button"
                    data-theme-option="dark"
                    aria-label="Use dark theme"
                    title="Dark theme"
                  >
                    ☾
                  </button>
                </div>
              </div>
            </div>
          </section>

          <hr class="sidebar-divider" />
          <h2 class="toc-title">
            Contents
            <button
              class="help-tip"
              type="button"
              data-tooltip="Active section updates while scrolling. Clicking links updates the URL hash without adding browser history entries."
              aria-label="Contents help"
            >
              ?
            </button>
          </h2>
          <div class="sidebar-toc-scroll" id="sidebar-toc-scroll">
            <nav id="report-toc" class="js-toc" aria-label="Table of contents"></nav>
          </div>
        </aside>

        <main id="toc-content" class="report-main">


          <section id="zoom-active-banner" class="zoom-active-banner hidden" role="status" aria-live="polite" aria-atomic="true">
            <div class="zoom-active-banner-copy">
              <p class="zoom-active-banner-title">Filtered Timeline View</p>
              <p id="zoom-active-banner-text" class="zoom-active-banner-text"></p>
              <p id="zoom-active-banner-meta" class="zoom-active-banner-meta"></p>
            </div>
            <div class="zoom-active-banner-actions">
              <span id="zoom-active-banner-chip" class="zoom-active-banner-chip"></span>
              <button id="zoom-banner-copy-button" class="zoom-banner-button" type="button">Copy link</button>
              <button id="zoom-banner-reset-button" class="zoom-banner-button" type="button">Reset zoom</button>
            </div>
          </section>

          <section id="section-overview" class="report-section panel">
            <h2 id="overview" class="toc-heading">How To Use This Report</h2>
              <p>
                This temporary focused view shows only the off-hours shift anomaly analysis so methodology and chart behavior can be refined in isolation.
              </p>
            <aside class="definition-callout">
              <p>
                <strong>What low power means:</strong> low-support buckets/windows have high proportion uncertainty and can swing
                from random variation.
              </p>
              <p>
                <strong>How to interpret:</strong> prioritize signals that persist into adjacent higher-volume windows or recur at
                similar dayparts across days.
              </p>
            </aside>
            <p class="tiny-note" id="report-timezone-summary"></p>
              <div id="off-hours-evidence-tier" class="offhours-evidence-tier hidden"></div>
              <div id="off-hours-inference-banner" class="warning-banner hidden"></div>
            <section class="kpi-grid">
              <article class="kpi-card">
                <div class="kpi-label">
Off-Hours Records                </div>
                <div class="kpi-value" id="kpi-artifacts">0</div>
                <div class="kpi-meta" id="kpi-artifacts-meta"></div>
              </article>
              <article class="kpi-card">
                <div class="kpi-label">
Analyses Shown                </div>
                <div class="kpi-value" id="kpi-detectors">0</div>
                <div class="kpi-meta" id="kpi-detectors-meta"></div>
              </article>
              <article class="kpi-card">
                <div class="kpi-label">
Robust Primary Alerts                </div>
                <div class="kpi-value" id="kpi-flagged">0</div>
                <div class="kpi-meta" id="kpi-flagged-meta"></div>
              </article>
              <article class="kpi-card">
                <div class="kpi-label">
Primary-Bucket Low-Power Off-Hours                </div>
                <div class="kpi-value" id="kpi-low-power">0</div>
                <div class="kpi-meta" id="kpi-low-power-meta"></div>
              </article>
            </section>
          </section>


          <section id="analysis-root" class="report-section">
              <section
                class="analysis-section"
                id="section-off_hours"
                data-analysis-id="off_hours"
                data-analysis-status="ready"
                data-analysis-detector="off_hours"
              >
                <div class="analysis-header">
                  <h2 id="analysis-off_hours" class="toc-heading">Off-Hours Profile</h2>
                </div>

                <div class="analysis-hero-block">
                  <div
                    class="chart-host chart-host-hero"
                    data-chart-id="off_hours_control_timeline"
                    data-chart-role="hero"
                  ></div>
                  <p class="empty-message hidden" data-chart-empty-for="off_hours_control_timeline">
                    No chartable records for this run.
                  </p>
                  <p class="tiny-note chart-note" data-chart-note-for="off_hours_control_timeline"></p>
                    <details class="chart-help-card">
                      <summary>Chart Help</summary>
                      <div class="chart-help-body">
                          <p><strong>What is this?</strong> Off-hours control timeline with primary baseline overlays (model when available, day-adjusted fallback otherwise). This time-aligned view shows how the measured signal changes across chronological buckets. It is the primary lens for identifying sequence, duration, and coincidence with external events.</p>
                          <p><strong>Why this matters:</strong> Time-series structure distinguishes transient spikes from sustained regime changes and helps align detector evidence by timestamp. Without duration context, it is easy to overreact to one-bucket noise and miss broad shifts.</p>
                          <p><strong>How to interpret:</strong> Read left to right, compare volume with rate/score overlays, and pay attention to uncertainty bounds and low-power markers where available. When zoomed in, verify whether local extremes persist across neighboring buckets and remain visible at wider scales.</p>
                          <p><strong>What to look for:</strong> Look for repeated peaks, troughs, trend breaks, and persistent drifts across adjacent windows. Patterns that recur at the same daypart across dates are usually stronger than one isolated wave. Legend components: Submission count, Pro rate, Wilson low / Wilson high, Robust primary alert, Low-power.</p>
                          <p><strong>Momentary high/low:</strong> Short highs/lows can reflect event timing, random variance, or small-sample effects. Confirm with neighboring buckets before treating them as material anomalies. A momentary high near a known outreach time can be benign; a momentary low during expected peak periods may indicate data lag.</p>
                          <p><strong>Extended high/low:</strong> Extended highs/lows are stronger indicators of behavioral shifts, especially when they persist across multiple bucket sizes and coincide with corroborating detector outputs. Extended highs may indicate sustained mobilization or systematic bias; extended lows may indicate prolonged inactivity or missing segments.</p>
                          <p><strong>Legend guide:</strong> Off-hours control timeline with primary baseline overlays (model when available, day-adjusted fallback otherwise).</p>
                            <ul>
                                <li><strong>Submission count:</strong> Total records per bucket for support context.</li>
                                <li><strong>Pro rate:</strong> Observed pro share by bucket, with Wilson uncertainty and primary expected/control-band overlays.</li>
                                <li><strong>Wilson low / Wilson high:</strong> Confidence band for the proportion metric; wider bands indicate higher uncertainty.</li>
                                <li><strong>Robust primary alert:</strong> Alert-eligible windows below the primary 99.8% lower control limit with lower-tail FDR support and material effect size. Shaded spans mark contiguous robust-alert runs.</li>
                                <li><strong>Low-power:</strong> Markers for buckets with insufficient support where rates can swing from noise.</li>
                            </ul>
                      </div>
                    </details>
                </div>

                <details class="analysis-help-card">
                  <summary>Analysis Help</summary>
                  <div class="analysis-help-body">
                      <p><strong>What is this?</strong> Off-Hours Profile focuses on model-aware off-hours composition shift with volume context. This section combines a hero chart, supporting charts, and tables to separate one-off noise from meaningful sustained behavior. Treat it as a detector notebook: start broad, then drill into specific windows with evidence context.</p>
                      <p><strong>Why this data matters:</strong> This data matters because it changes how confident you should be in an anomaly narrative. Strong claims should come from persistent, well-supported patterns rather than isolated spikes. It also prevents both over-calling benign fluctuations and missing slow-burn anomalies that only emerge over longer runs.</p>
                      <p><strong>How do I interpret this data?</strong> Read the hero chart first for the dominant temporal structure, then use detail charts to test whether the signal repeats across scales, dayparts, or subgroup splits. Use tables to verify exact values and support counts behind flagged windows. When uncertainty bands or low-power markers are present, discount single-window jumps unless they recur with stronger support.</p>
                      <p><strong>What do I look for?</strong> Sustained robust primary alerts (alert-eligible, below primary 99.8% lower control band, lower-tail FDR-supported, and materially negative) at adequate support, then verify whether the pattern repeats or clusters in specific dates/hours. Prioritize robust primary alerts (below primary 99.8% lower limit, lower-tail FDR-significant, and materially negative delta at adequate support); avoid interpreting low-n windows even if raw rates look extreme. If tested off-hours windows are zero after low-power filtering, treat the section as descriptive-only and avoid inferential conclusions. Use the funnel view to compare primary and global expected bands; treat primary-baseline breaches as the decision metric and global bands as context. Investigation priority should increase when multiple independent views tell the same story at the same time.</p>
                      <p><strong>What could a momentary high/low mean?</strong> Momentary highs can indicate short overnight swings that stay within primary control limits after day/hour adjustment. Momentary lows can indicate small support windows where apparent extremes are likely sampling noise. Treat both cautiously when low-power flags are present. A practical rule: do not escalate on a single bucket unless a nearby table row and at least one companion chart support the same direction.</p>
                      <p><strong>What could an extended high/low mean?</strong> Extended highs can indicate repeating robust primary alerts across adjacent windows or nights at moderate/high support. Extended lows can indicate stable overnight behavior that remains inside expected primary control bands. Persistence across adjacent windows and corroborating detectors raises confidence that the shift is meaningful. Extended runs deserve timeline annotation and root-cause notes so later reviewers can separate operational context from suspicious behavior.</p>
                      <ul>
                          <li>Prioritize robust primary alerts (below primary 99.8% lower limit, lower-tail FDR-significant, and materially negative delta at adequate support); avoid interpreting low-n windows even if raw rates look extreme.</li>
                          <li>If tested off-hours windows are zero after low-power filtering, treat the section as descriptive-only and avoid inferential conclusions.</li>
                          <li>Use the funnel view to compare primary and global expected bands; treat primary-baseline breaches as the decision metric and global bands as context.</li>
                          <li>In date-hour heatmaps, repeated overnight blocks across multiple dates are stronger than a single-night dip; corroborate with burst, periodicity, and duplicate detectors before escalation.</li>
                      </ul>
                    <p><strong>Common benign causes:</strong> Time-zone spillover, campaign scheduling, and hearing-deadline pushes can produce legitimate overnight composition shifts.</p>
                  </div>
                </details>

                  <div class="analysis-detail-grid">
                      <article class="detail-card">
                        <h3 class="detail-title">Off Hours Funnel Plot</h3>
                        <p class="tiny-note"><code>off_hours_funnel_plot</code></p>
                        <div
                          class="chart-host chart-host-detail"
                          data-chart-id="off_hours_funnel_plot"
                          data-chart-role="detail"
                        ></div>
                        <p class="empty-message hidden" data-chart-empty-for="off_hours_funnel_plot">No chartable records for this run.</p>
                        <p class="tiny-note chart-note" data-chart-note-for="off_hours_funnel_plot"></p>
                          <details class="chart-help-card">
                            <summary>Chart Help</summary>
                            <div class="chart-help-body">
                                <p><strong>What is this?</strong> Funnel plot of pro share versus support with primary and global control references. This scatter plot maps each bucket as a point in feature space, often with color and size as additional signals. It is a relationship view, showing joint behavior rather than a single metric over time.</p>
                                <p><strong>Why this matters:</strong> Scatter views expose joint-feature structure, clusters, and outliers that are not visible in one-dimensional summaries. They help determine whether anomalies are isolated outliers or part of a broader feature-space regime.</p>
                                <p><strong>How to interpret:</strong> Read axis meaning first, then evaluate whether outliers are isolated or part of a cluster. Use color/size encodings to understand confidence and support. Cross-reference extreme points with time-based charts to determine whether they are single events or repeated states.</p>
                                <p><strong>What to look for:</strong> Look for detached point clouds, extreme tails, and dense anomaly clusters that align with flagged windows. A compact cluster far from baseline often carries more weight than one far-away point with low support. Legend components: Point, Control curves, Color.</p>
                                <p><strong>Momentary high/low:</strong> A single extreme point may be a one-off event or model artifact. Validate with timeline charts and table support counts. Momentary lows are usually returns toward baseline and are often benign unless paired with abrupt nearby outliers.</p>
                                <p><strong>Extended high/low:</strong> Large persistent outlier clusters imply broad feature-space drift. Extended low-intensity clustering implies stable baseline behavior. Sustained dual-cluster structure can indicate mixed populations or alternating operational modes.</p>
                                <p><strong>Legend guide:</strong> Funnel plot of pro share versus support with primary and global control references.</p>
                                  <ul>
                                      <li><strong>Point:</strong> Each point is one time bucket (x = known pro/con count, y = pro share). Inference is strongest when windows are alert-eligible and not low-power.</li>
                                      <li><strong>Control curves:</strong> Curves show global-baseline expected range (95% and 99.8%). Primary baseline is row-specific (model/day-adjusted) and is used for robust-alert scoring and tooltip diagnostics.</li>
                                      <li><strong>Color:</strong> Off-hours-dominant windows are highlighted; red points mark robust primary alerts (99.8% lower breach + lower-tail FDR + material effect size).</li>
                                  </ul>
                            </div>
                          </details>
                      </article>
                      <article class="detail-card">
                        <h3 class="detail-title">Off Hours Primary Residual Timeline</h3>
                        <p class="tiny-note"><code>off_hours_primary_residual_timeline</code></p>
                        <div
                          class="chart-host chart-host-detail"
                          data-chart-id="off_hours_primary_residual_timeline"
                          data-chart-role="detail"
                        ></div>
                        <p class="empty-message hidden" data-chart-empty-for="off_hours_primary_residual_timeline">No chartable records for this run.</p>
                        <p class="tiny-note chart-note" data-chart-note-for="off_hours_primary_residual_timeline"></p>
                          <details class="chart-help-card">
                            <summary>Chart Help</summary>
                            <div class="chart-help-body">
                                <p><strong>What is this?</strong> Primary-baseline residual timeline for inferentially tested off-hours windows with SPC/FDR channel markers. This time-aligned view shows how the measured signal changes across chronological buckets. It is the primary lens for identifying sequence, duration, and coincidence with external events.</p>
                                <p><strong>Why this matters:</strong> Time-series structure distinguishes transient spikes from sustained regime changes and helps align detector evidence by timestamp. Without duration context, it is easy to overreact to one-bucket noise and miss broad shifts.</p>
                                <p><strong>How to interpret:</strong> Read left to right, compare volume with rate/score overlays, and pay attention to uncertainty bounds and low-power markers where available. When zoomed in, verify whether local extremes persist across neighboring buckets and remain visible at wider scales.</p>
                                <p><strong>What to look for:</strong> Look for repeated peaks, troughs, trend breaks, and persistent drifts across adjacent windows. Patterns that recur at the same daypart across dates are usually stronger than one isolated wave. Legend components: Known Pro+Con count, Primary z-score, Day z-score, Z references, Robust primary alert, Low-power.</p>
                                <p><strong>Momentary high/low:</strong> Short highs/lows can reflect event timing, random variance, or small-sample effects. Confirm with neighboring buckets before treating them as material anomalies. A momentary high near a known outreach time can be benign; a momentary low during expected peak periods may indicate data lag.</p>
                                <p><strong>Extended high/low:</strong> Extended highs/lows are stronger indicators of behavioral shifts, especially when they persist across multiple bucket sizes and coincide with corroborating detector outputs. Extended highs may indicate sustained mobilization or systematic bias; extended lows may indicate prolonged inactivity or missing segments.</p>
                                <p><strong>Legend guide:</strong> Primary-baseline residual timeline for inferentially tested off-hours windows with SPC/FDR channel markers.</p>
                                  <ul>
                                      <li><strong>Known Pro+Con count:</strong> Known pro/con records supporting each bucket.</li>
                                      <li><strong>Primary z-score:</strong> Standardized residual of observed pro count versus the primary expected pro-rate baseline (model/day-adjusted).</li>
                                      <li><strong>Day z-score:</strong> Day-adjusted standardized residual shown as comparator context.</li>
                                      <li><strong>Z references:</strong> Reference lines at 0 and +/-3 sigma for residual context.</li>
                                      <li><strong>Robust primary alert:</strong> Alert-eligible windows meeting robust-primary criteria (99.8% lower breach + lower-tail FDR + material effect size).</li>
                                      <li><strong>Low-power:</strong> Markers for buckets with insufficient support where rates can swing from noise.</li>
                                  </ul>
                            </div>
                          </details>
                      </article>
                      <article class="detail-card">
                        <h3 class="detail-title">Off Hours Primary Flag Channels</h3>
                        <p class="tiny-note"><code>off_hours_primary_flag_channels</code></p>
                        <div
                          class="chart-host chart-host-detail"
                          data-chart-id="off_hours_primary_flag_channels"
                          data-chart-role="detail"
                        ></div>
                        <p class="empty-message hidden" data-chart-empty-for="off_hours_primary_flag_channels">No chartable records for this run.</p>
                        <p class="tiny-note chart-note" data-chart-note-for="off_hours_primary_flag_channels"></p>
                          <details class="chart-help-card">
                            <summary>Chart Help</summary>
                            <div class="chart-help-body">
                                <p><strong>What is this?</strong> Channelized flag accounting for tested off-hours windows in the primary bucket. This categorical/ranked chart compares values across labels, groups, or parameter settings. It emphasizes composition and concentration instead of chronology.</p>
                                <p><strong>Why this matters:</strong> Category comparisons show concentration, imbalance, and dominance patterns that can explain why timeline signals moved. They are often the fastest way to identify which subgroup is driving a detector outcome.</p>
                                <p><strong>How to interpret:</strong> Sort by magnitude, compare head vs tail behavior, and relate category concentration to corresponding detector windows. Check both absolute values and relative spacing so you can distinguish true concentration from a uniformly low baseline.</p>
                                <p><strong>What to look for:</strong> Look for heavy concentration in a few categories, abrupt drop-offs, or rare categories with disproportionately high values. A long flat tail with one or two dominant bars often indicates a targeted driver worth validating in tables. Legend components: Bar height, X-axis channel.</p>
                                <p><strong>Momentary high/low:</strong> A single dominant category may come from one campaign event or local data artifact. Check whether the dominance repeats over time. Momentary category suppression can also happen when total volume is temporarily low.</p>
                                <p><strong>Extended high/low:</strong> Persistent dominance/absence across many categories can indicate structural participation effects rather than random variation. Extended concentration deserves follow-up to determine whether it is policy-driven outreach, operational process, or suspicious patterning.</p>
                                <p><strong>Legend guide:</strong> Channelized flag accounting for tested off-hours windows in the primary bucket.</p>
                                  <ul>
                                      <li><strong>Bar height:</strong> Count of tested windows meeting each detection channel (SPC 99.8% breach, two-sided FDR, union/intersection, robust alert).</li>
                                      <li><strong>X-axis channel:</strong> Channel labels are ordered from denominator context to stricter intersection/robust criteria.</li>
                                  </ul>
                            </div>
                          </details>
                      </article>
                      <article class="detail-card">
                        <h3 class="detail-title">Off Hours Model Fit Diagnostics</h3>
                        <p class="tiny-note"><code>off_hours_model_fit_diagnostics</code></p>
                        <div
                          class="chart-host chart-host-detail"
                          data-chart-id="off_hours_model_fit_diagnostics"
                          data-chart-role="detail"
                        ></div>
                        <p class="empty-message hidden" data-chart-empty-for="off_hours_model_fit_diagnostics">No chartable records for this run.</p>
                        <p class="tiny-note chart-note" data-chart-note-for="off_hours_model_fit_diagnostics"></p>
                          <details class="chart-help-card">
                            <summary>Chart Help</summary>
                            <div class="chart-help-body">
                                <p><strong>What is this?</strong> Model-fit coverage diagnostics by off-hours bucket size. This categorical/ranked chart compares values across labels, groups, or parameter settings. It emphasizes composition and concentration instead of chronology.</p>
                                <p><strong>Why this matters:</strong> Category comparisons show concentration, imbalance, and dominance patterns that can explain why timeline signals moved. They are often the fastest way to identify which subgroup is driving a detector outcome.</p>
                                <p><strong>How to interpret:</strong> Sort by magnitude, compare head vs tail behavior, and relate category concentration to corresponding detector windows. Check both absolute values and relative spacing so you can distinguish true concentration from a uniformly low baseline.</p>
                                <p><strong>What to look for:</strong> Look for heavy concentration in a few categories, abrupt drop-offs, or rare categories with disproportionately high values. A long flat tail with one or two dominant bars often indicates a targeted driver worth validating in tables. Legend components: Bar height, X-axis bucket.</p>
                                <p><strong>Momentary high/low:</strong> A single dominant category may come from one campaign event or local data artifact. Check whether the dominance repeats over time. Momentary category suppression can also happen when total volume is temporarily low.</p>
                                <p><strong>Extended high/low:</strong> Persistent dominance/absence across many categories can indicate structural participation effects rather than random variation. Extended concentration deserves follow-up to determine whether it is policy-driven outreach, operational process, or suspicious patterning.</p>
                                <p><strong>Legend guide:</strong> Model-fit coverage diagnostics by off-hours bucket size.</p>
                                  <ul>
                                      <li><strong>Bar height:</strong> Fraction of windows in each bucket size where model-based expected rates were available.</li>
                                      <li><strong>X-axis bucket:</strong> Bucket size in minutes; use with table diagnostics for fit method, row support, and convergence context.</li>
                                  </ul>
                            </div>
                          </details>
                      </article>
                      <article class="detail-card">
                        <h3 class="detail-title">Off Hours Date Hour Pro Heatmap</h3>
                        <p class="tiny-note"><code>off_hours_date_hour_pro_heatmap</code></p>
                        <div
                          class="chart-host chart-host-detail"
                          data-chart-id="off_hours_date_hour_pro_heatmap"
                          data-chart-role="detail"
                        ></div>
                        <p class="empty-message hidden" data-chart-empty-for="off_hours_date_hour_pro_heatmap">No chartable records for this run.</p>
                        <p class="tiny-note chart-note" data-chart-note-for="off_hours_date_hour_pro_heatmap"></p>
                          <details class="chart-help-card">
                            <summary>Chart Help</summary>
                            <div class="chart-help-body">
                                <p><strong>What is this?</strong> Date x hour heatmap for off-hours composition. This is a matrix view where color encodes magnitude across paired axes such as date/hour or slot/day. Each cell is a compact summary of one intersection, so the chart is optimized for pattern shape over exact per-cell precision.</p>
                                <p><strong>Why this matters:</strong> Heatmaps reveal spatially contiguous patterns that line charts can hide, especially repeated daypart behavior and slot-level drift. They are especially useful for finding regime-like blocks that persist across many adjacent cells.</p>
                                <p><strong>How to interpret:</strong> Scan for contiguous blocks before focusing on single cells. Compare high-intensity and low-intensity regions with bucket support and related detector outputs. Then check whether color transitions occur at meaningful boundaries such as day changes, hearing windows, or slot shifts.</p>
                                <p><strong>What to look for:</strong> Look for coherent blocks, repeated stripes, or abrupt regime boundaries that persist across adjacent rows/columns. Short isolated hot/cold cells are weaker evidence; long bands or rectangles are stronger. Legend components: Cell color, Axes.</p>
                                <p><strong>Momentary high/low:</strong> A single hot/cold cell can reflect transient activity or low support. Interpret isolated cells cautiously, especially if they do not repeat in neighboring slots. Momentary highs can map to one reminder wave; momentary lows can map to ordinary quiet periods.</p>
                                <p><strong>Extended high/low:</strong> Extended hot/cold regions typically indicate sustained behavioral mode shifts. Persistence across multiple dates/slots is stronger evidence than one transition point. Extended hot regions may indicate durable mobilization or process bias; extended cold regions may indicate suppression or inactivity.</p>
                                <p><strong>Legend guide:</strong> Date x hour heatmap for off-hours composition.</p>
                                  <ul>
                                      <li><strong>Cell color:</strong> Pro share for that date/hour cell; low-power cells are marked in tooltip.</li>
                                      <li><strong>Axes:</strong> X-axis is hour of day; Y-axis is calendar date in chronological top-down order (earliest at top).</li>
                                  </ul>
                            </div>
                          </details>
                      </article>
                      <article class="detail-card">
                        <h3 class="detail-title">Off Hours Date Hour Primary Residual Heatmap</h3>
                        <p class="tiny-note"><code>off_hours_date_hour_primary_residual_heatmap</code></p>
                        <div
                          class="chart-host chart-host-detail"
                          data-chart-id="off_hours_date_hour_primary_residual_heatmap"
                          data-chart-role="detail"
                        ></div>
                        <p class="empty-message hidden" data-chart-empty-for="off_hours_date_hour_primary_residual_heatmap">No chartable records for this run.</p>
                        <p class="tiny-note chart-note" data-chart-note-for="off_hours_date_hour_primary_residual_heatmap"></p>
                          <details class="chart-help-card">
                            <summary>Chart Help</summary>
                            <div class="chart-help-body">
                                <p><strong>What is this?</strong> Date x hour heatmap for primary-baseline standardized residuals across the full 24-hour timeline. This is a matrix view where color encodes magnitude across paired axes such as date/hour or slot/day. Each cell is a compact summary of one intersection, so the chart is optimized for pattern shape over exact per-cell precision.</p>
                                <p><strong>Why this matters:</strong> Heatmaps reveal spatially contiguous patterns that line charts can hide, especially repeated daypart behavior and slot-level drift. They are especially useful for finding regime-like blocks that persist across many adjacent cells.</p>
                                <p><strong>How to interpret:</strong> Scan for contiguous blocks before focusing on single cells. Compare high-intensity and low-intensity regions with bucket support and related detector outputs. Then check whether color transitions occur at meaningful boundaries such as day changes, hearing windows, or slot shifts.</p>
                                <p><strong>What to look for:</strong> Look for coherent blocks, repeated stripes, or abrupt regime boundaries that persist across adjacent rows/columns. Short isolated hot/cold cells are weaker evidence; long bands or rectangles are stronger. Legend components: Cell color, Support, Off-hours emphasis, Axes.</p>
                                <p><strong>Momentary high/low:</strong> A single hot/cold cell can reflect transient activity or low support. Interpret isolated cells cautiously, especially if they do not repeat in neighboring slots. Momentary highs can map to one reminder wave; momentary lows can map to ordinary quiet periods.</p>
                                <p><strong>Extended high/low:</strong> Extended hot/cold regions typically indicate sustained behavioral mode shifts. Persistence across multiple dates/slots is stronger evidence than one transition point. Extended hot regions may indicate durable mobilization or process bias; extended cold regions may indicate suppression or inactivity.</p>
                                <p><strong>Legend guide:</strong> Date x hour heatmap for primary-baseline standardized residuals across the full 24-hour timeline.</p>
                                  <ul>
                                      <li><strong>Cell color:</strong> Average support-window primary z-score for that date/hour cell (blue = below baseline, warm = above baseline).</li>
                                      <li><strong>Support:</strong> Tooltips show inferential tested-window counts and robust-alert counts so isolated low-support cells are not over-weighted.</li>
                                      <li><strong>Off-hours emphasis:</strong> Off-hours hours are highlighted on the X-axis label to preserve off-hours focus while retaining all-hour context.</li>
                                      <li><strong>Axes:</strong> X-axis is hour of day; Y-axis is calendar date in chronological top-down order (earliest at top).</li>
                                  </ul>
                            </div>
                          </details>
                      </article>
                      <article class="detail-card">
                        <h3 class="detail-title">Off Hours Date Hour Volume Heatmap</h3>
                        <p class="tiny-note"><code>off_hours_date_hour_volume_heatmap</code></p>
                        <div
                          class="chart-host chart-host-detail"
                          data-chart-id="off_hours_date_hour_volume_heatmap"
                          data-chart-role="detail"
                        ></div>
                        <p class="empty-message hidden" data-chart-empty-for="off_hours_date_hour_volume_heatmap">No chartable records for this run.</p>
                        <p class="tiny-note chart-note" data-chart-note-for="off_hours_date_hour_volume_heatmap"></p>
                          <details class="chart-help-card">
                            <summary>Chart Help</summary>
                            <div class="chart-help-body">
                                <p><strong>What is this?</strong> Date x hour heatmap for off-hours volume. This is a matrix view where color encodes magnitude across paired axes such as date/hour or slot/day. Each cell is a compact summary of one intersection, so the chart is optimized for pattern shape over exact per-cell precision.</p>
                                <p><strong>Why this matters:</strong> Heatmaps reveal spatially contiguous patterns that line charts can hide, especially repeated daypart behavior and slot-level drift. They are especially useful for finding regime-like blocks that persist across many adjacent cells.</p>
                                <p><strong>How to interpret:</strong> Scan for contiguous blocks before focusing on single cells. Compare high-intensity and low-intensity regions with bucket support and related detector outputs. Then check whether color transitions occur at meaningful boundaries such as day changes, hearing windows, or slot shifts.</p>
                                <p><strong>What to look for:</strong> Look for coherent blocks, repeated stripes, or abrupt regime boundaries that persist across adjacent rows/columns. Short isolated hot/cold cells are weaker evidence; long bands or rectangles are stronger. Legend components: Cell color, Axes.</p>
                                <p><strong>Momentary high/low:</strong> A single hot/cold cell can reflect transient activity or low support. Interpret isolated cells cautiously, especially if they do not repeat in neighboring slots. Momentary highs can map to one reminder wave; momentary lows can map to ordinary quiet periods.</p>
                                <p><strong>Extended high/low:</strong> Extended hot/cold regions typically indicate sustained behavioral mode shifts. Persistence across multiple dates/slots is stronger evidence than one transition point. Extended hot regions may indicate durable mobilization or process bias; extended cold regions may indicate suppression or inactivity.</p>
                                <p><strong>Legend guide:</strong> Date x hour heatmap for off-hours volume.</p>
                                  <ul>
                                      <li><strong>Cell color:</strong> Submission count for that date/hour cell.</li>
                                      <li><strong>Axes:</strong> X-axis is hour of day; Y-axis is calendar date in chronological top-down order (earliest at top).</li>
                                  </ul>
                            </div>
                          </details>
                      </article>
                  </div>

                <div class="analysis-tables" data-analysis-tables-for="off_hours"></div>
              </section>
          </section>


          <footer class="panel report-attribution">
            <p class="subtle">
              Interactive charts are powered by
              <a href="https://echarts.apache.org/" target="_blank" rel="noopener noreferrer">ECharts</a>;
              data tables use
              <a href="https://tabulator.info/" target="_blank" rel="noopener noreferrer">Tabulator</a>.
            </p>
          </footer>
        </main>
      </div>
    </div>
    <div id="report-busy-indicator" class="report-busy-indicator hidden" role="status" aria-live="polite">
      <span class="busy-spinner" aria-hidden="true"></span>
      <span id="report-busy-text">Updating charts...</span>
    </div>

    <script id="report-data-source" type="application/json">
      {"report_data_url": "report_data/index.json"}
    </script>
    <script src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/dark.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/gray.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/cool.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/helianthus.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/caravan.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/vintage.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/macarons.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/infographic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/shine.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/theme/roma.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.7/dist/tippy-bundle.umd.min.js"></script>
    <script>
      (async function () {
        const sourceElement = document.getElementById("report-data-source");
        const sourceConfig = sourceElement ? JSON.parse(sourceElement.textContent || "{}") : {};
        const reportDataUrl =
          typeof sourceConfig.report_data_url === "string" && sourceConfig.report_data_url.trim()
            ? sourceConfig.report_data_url.trim()
            : "";
        async function loadReportData() {
          if (!reportDataUrl) {
            return {};
          }
          try {
            const response = await fetch(reportDataUrl);
            if (!response.ok) {
              throw new Error(
                "HTTP " + String(response.status || "") + " while loading " + reportDataUrl
              );
            }
            const payload = await response.json();
            return payload && typeof payload === "object" ? payload : {};
          } catch (error) {
            console.error("Failed to load report data payload.", error);
            const busyIndicator = document.getElementById("report-busy-indicator");
            const busyText = document.getElementById("report-busy-text");
            if (busyText) {
              busyText.textContent =
                "Unable to load report data. Serve this report directory over HTTP and refresh.";
            }
            if (busyIndicator) {
              busyIndicator.classList.remove("hidden");
            }
            return null;
          }
        }
        const reportData = await loadReportData();
        if (!reportData) {
          return;
        }
        const interactive = reportData.interactive_charts || {};
        const analysisCatalog = Array.isArray(interactive.analysis_catalog) ? interactive.analysis_catalog : [];
        const analysisById = new Map(analysisCatalog.map((analysis) => [String(analysis.id || ""), analysis]));
        const chartDataManifest =
          interactive.chart_data_manifest && typeof interactive.chart_data_manifest === "object"
            ? interactive.chart_data_manifest
            : {};
        const chartShardManifestByAnalysis =
          chartDataManifest.analysis && typeof chartDataManifest.analysis === "object"
            ? chartDataManifest.analysis
            : {};
        const chartBaseRowsMap =
          interactive.charts && typeof interactive.charts === "object"
            ? Object.assign({}, interactive.charts)
            : {};
        const chartBucketRowsMap = new Map();
        const chartBucketOptionsByChart = new Map();
        const chartToAnalysis = new Map();
        const loadedAnalysisBase = new Set();
        const loadingAnalysisBase = new Map();
        const loadedAnalysisBuckets = new Map();
        const loadingAnalysisBuckets = new Map();

        const rawChartToAnalysis =
          chartDataManifest.chart_to_analysis && typeof chartDataManifest.chart_to_analysis === "object"
            ? chartDataManifest.chart_to_analysis
            : {};
        Object.keys(rawChartToAnalysis).forEach((chartIdRaw) => {
          const chartId = String(chartIdRaw || "").trim();
          const analysisId = String(rawChartToAnalysis[chartIdRaw] || "").trim();
          if (!chartId || !analysisId) {
            return;
          }
          chartToAnalysis.set(chartId, analysisId);
        });
        analysisCatalog.forEach((analysis) => {
          const analysisId = String((analysis || {}).id || "").trim();
          if (!analysisId) {
            return;
          }
          const chartIds = [];
          const hero = String((analysis || {}).hero_chart_id || "").trim();
          if (hero) {
            chartIds.push(hero);
          }
          if (Array.isArray((analysis || {}).detail_chart_ids)) {
            analysis.detail_chart_ids.forEach((chartIdRaw) => {
              const chartId = String(chartIdRaw || "").trim();
              if (chartId) {
                chartIds.push(chartId);
              }
            });
          }
          chartIds.forEach((chartId) => {
            if (!chartToAnalysis.has(chartId)) {
              chartToAnalysis.set(chartId, analysisId);
            }
          });
        });
        Object.keys(chartShardManifestByAnalysis).forEach((analysisIdRaw) => {
          const analysisId = String(analysisIdRaw || "").trim();
          if (!analysisId) {
            return;
          }
          const entry = chartShardManifestByAnalysis[analysisIdRaw];
          const chartOptions =
            entry && typeof entry.chart_bucket_options === "object"
              ? entry.chart_bucket_options
              : {};
          Object.keys(chartOptions || {}).forEach((chartIdRaw) => {
            const chartId = String(chartIdRaw || "").trim();
            if (!chartId) {
              return;
            }
            const valuesRaw = chartOptions[chartIdRaw];
            const options = Array.isArray(valuesRaw)
              ? Array.from(
                  new Set(
                    valuesRaw
                      .map((value) => {
                        const parsed =
                          typeof value === "number"
                            ? value
                            : typeof value === "string"
                              ? Number(value)
                              : null;
                        return Number.isFinite(parsed) && parsed > 0 ? Math.round(parsed) : null;
                      })
                      .filter((value) => value !== null)
                  )
                ).sort((left, right) => left - right)
              : [];
            chartBucketOptionsByChart.set(chartId, options);
            if (!chartToAnalysis.has(chartId)) {
              chartToAnalysis.set(chartId, analysisId);
            }
          });
        });

        function shouldForcePreloadAllData() {
          if (typeof window.URLSearchParams === "undefined") {
            return false;
          }
          const params = new window.URLSearchParams(window.location.search || "");
          const preloadRaw = String(
            params.get("preload_data") || params.get("preload") || params.get("load") || ""
          )
            .trim()
            .toLowerCase();
          if (["1", "true", "yes", "on", "all"].includes(preloadRaw)) {
            return true;
          }
          const preloadAllRaw = String(params.get("preload_all_data") || "")
            .trim()
            .toLowerCase();
          return ["1", "true", "yes", "on", "all"].includes(preloadAllRaw);
        }

        const forcePreloadAllData = shouldForcePreloadAllData();
        const triageViews = interactive.triage_views || {};
        const triageSummary = interactive.triage_summary || {};
        const windowEvidenceQueue = Array.isArray(interactive.window_evidence_queue)
          ? interactive.window_evidence_queue
          : [];
        const recordEvidenceQueue = Array.isArray(interactive.record_evidence_queue)
          ? interactive.record_evidence_queue
          : [];
        const clusterEvidenceQueue = Array.isArray(interactive.cluster_evidence_queue)
          ? interactive.cluster_evidence_queue
          : [];
        const dataQualityPanel = interactive.data_quality_panel || {};
        const hearingContextPanel = interactive.hearing_context_panel || {};
        const crossHearingBaseline = interactive.cross_hearing_baseline || {};
        const controls = interactive.controls || {};
        const focusAnalysisIds = Array.isArray(controls.focus_analysis_ids)
          ? controls.focus_analysis_ids
              .map((analysisId) => String(analysisId || "").trim())
              .filter((analysisId) => !!analysisId)
          : [];
        const isOffHoursFocusOnly =
          focusAnalysisIds.length === 1 && focusAnalysisIds[0] === "off_hours";
        const methodology = controls.methodology || {};
        const themeOptions = Array.isArray(controls.theme_options)
          ? controls.theme_options
          : [];
        const defaultTheme =
          typeof controls.default_theme === "string" && controls.default_theme.trim()
            ? controls.default_theme.trim()
            : "light";
        const colorSemantics =
          controls.color_semantics && typeof controls.color_semantics === "object"
            ? controls.color_semantics
            : {};
        const tableColumnDocs = reportData.table_column_docs || {};
        const tableHelpDocs = reportData.table_help_docs || {};
        const reportTimezone =
          typeof controls.timezone === "string" && controls.timezone.trim()
            ? controls.timezone.trim()
            : "America/Los_Angeles";
        const reportTimezoneLabel =
          typeof controls.timezone_label === "string" && controls.timezone_label.trim()
            ? controls.timezone_label.trim()
            : reportTimezone;
        const dedupModes = Array.isArray(controls.dedup_modes)
          ? controls.dedup_modes.map((mode) => String(mode || "").trim()).filter((mode) => !!mode)
          : [];
        const processMarkers = Array.isArray(controls.process_markers)
          ? controls.process_markers
          : [];
        const crossHearingComparatorRows = Array.isArray(crossHearingBaseline.metric_comparators)
          ? crossHearingBaseline.metric_comparators
          : [];
        const crossHearingComparatorByMetric = new Map(
          crossHearingComparatorRows
            .filter((row) => row && typeof row.metric === "string")
            .map((row) => [String(row.metric), row])
        );
        const defaultDedupMode =
          typeof controls.default_dedup_mode === "string" && dedupModes.includes(controls.default_dedup_mode)
            ? controls.default_dedup_mode
            : dedupModes.includes("side_by_side")
              ? "side_by_side"
              : dedupModes.includes("raw")
                ? "raw"
                : dedupModes[0] || "raw";

        const hasEcharts = typeof window.echarts !== "undefined";
        const hasTabulator = typeof window.Tabulator !== "undefined";

        const chartInstances = [];
        const mountedSections = new Set();
        const chartMounts = new Map();
        const drilldownState = {
          activeWindow: null,
          windowTable: null,
          selectedWindowIds: [],
        };
        let investigationActionsBound = false;

        const state = {
          activeBucket: null,
          defaultBucket: null,
          activeDedupMode: defaultDedupMode,
          cursorX: null,
          activeTocHeading: null,
          renderToc: null,
          selectedWindowRange: null,
          zoom: {
            minTime: null,
            maxTime: null,
            syncing: false,
            raf: null,
            pending: null,
          },
          timeCharts: new Set(),
          absoluteTimeSet: new Set(
            ((controls.zoom_sync_groups || {}).absolute_time || []).map((id) => String(id || ""))
          ),
        };
        const linkedZoomFilterChartIds = new Set([
          "off_hours_funnel_plot",
          "off_hours_date_hour_pro_heatmap",
          "off_hours_date_hour_primary_residual_heatmap",
          "off_hours_date_hour_volume_heatmap",
          "procon_swings_shift_heatmap",
        ]);
        const zonedDateTimeEpochCache = new Map();
        const semanticTokenCache = new Map();
        const fallbackColorSemantics = {
          light: {
            axisText: "#334155",
            axisLine: "#94a3b8",
            axisName: "#0f172a",
            markerLabel: "#334155",
            cursor: "#475569",
            series: {
              primary: "#0072b2",
              volume: "#94a3b8",
              context: "#009e73",
              interval: "#8b99a8",
              reference: "#475569",
            },
            alert: { lower: "#d55e00", upper: "#cc79a7" },
            state: { low_power: "#e69f00", outlier: "#56b4e9" },
            band: {
              alert_run: "rgba(213, 94, 0, 0.12)",
              comparator: "rgba(0, 114, 178, 0.1)",
            },
            heatmap: {
              rate_diverging: ["#2c7fb8", "#9ecae1", "#f7f7f7", "#fdd49e", "#d95f0e"],
              residual_diverging: ["#b13a00", "#f4a259", "#f5f7fa", "#82b1d8", "#1f6aa5"],
              volume_seq: ["#f8fafc", "#cbd5e1", "#475569"],
            },
            categorical_palette: [
              "#0072b2",
              "#009e73",
              "#e69f00",
              "#cc79a7",
              "#56b4e9",
              "#d55e00",
              "#8b99a8",
              "#475569",
            ],
          },
          dark: {
            axisText: "#d4deeb",
            axisLine: "#6f839b",
            axisName: "#e5edf7",
            markerLabel: "#d4deeb",
            cursor: "#b8c6d8",
            series: {
              primary: "#5ab0ff",
              volume: "#64748b",
              context: "#2fc79a",
              interval: "#a8b5c5",
              reference: "#94a3b8",
            },
            alert: { lower: "#ff8a3d", upper: "#f2a7d4" },
            state: { low_power: "#f2c14e", outlier: "#7cc7ff" },
            band: {
              alert_run: "rgba(255, 138, 61, 0.18)",
              comparator: "rgba(90, 176, 255, 0.14)",
            },
            heatmap: {
              rate_diverging: ["#6baed6", "#2e4c66", "#111827", "#6b4a2d", "#f4a259"],
              residual_diverging: ["#ff8a3d", "#c9723a", "#1e293b", "#5a8db8", "#8cc7ff"],
              volume_seq: ["#0f172a", "#334155", "#94a3b8"],
            },
            categorical_palette: [
              "#5ab0ff",
              "#2fc79a",
              "#f2c14e",
              "#f2a7d4",
              "#7cc7ff",
              "#ff8a3d",
              "#a8b5c5",
              "#94a3b8",
            ],
          },
        };

        function toNumber(value) {
          if (typeof value === "number" && Number.isFinite(value)) {
            return value;
          }
          if (typeof value === "string") {
            const parsed = Number(value);
            return Number.isFinite(parsed) ? parsed : 0;
          }
          return 0;
        }

        function toFiniteNumberOrNull(value) {
          if (typeof value === "number" && Number.isFinite(value)) {
            return value;
          }
          if (typeof value === "boolean") {
            return value ? 1 : 0;
          }
          if (typeof value === "string") {
            const parsed = Number(value);
            return Number.isFinite(parsed) ? parsed : null;
          }
          return null;
        }

        function toBool(value) {
          if (typeof value === "boolean") {
            return value;
          }
          if (typeof value === "number") {
            return value !== 0;
          }
          if (typeof value === "string") {
            const normalized = value.trim().toLowerCase();
            return normalized === "true" || normalized === "1" || normalized === "yes";
          }
          return false;
        }

        function activeThemeId() {
          const value = String(document.documentElement.getAttribute("data-theme") || "").trim();
          return value || "light";
        }

        function toArray(value, fallback) {
          if (!Array.isArray(value)) {
            return fallback.slice();
          }
          const normalized = value
            .map((entry) => (typeof entry === "string" ? entry.trim() : ""))
            .filter((entry) => !!entry);
          return normalized.length ? normalized : fallback.slice();
        }

        function resolveColorSemanticTheme(themeId) {
          const normalizedTheme = String(themeId || "").toLowerCase() === "dark" ? "dark" : "light";
          const fallback = fallbackColorSemantics[normalizedTheme] || fallbackColorSemantics.light;
          const provided =
            colorSemantics && typeof colorSemantics[normalizedTheme] === "object"
              ? colorSemantics[normalizedTheme]
              : {};
          const providedSeries =
            provided.series && typeof provided.series === "object" ? provided.series : {};
          const providedAlert =
            provided.alert && typeof provided.alert === "object" ? provided.alert : {};
          const providedState =
            provided.state && typeof provided.state === "object" ? provided.state : {};
          const providedBand =
            provided.band && typeof provided.band === "object" ? provided.band : {};
          const providedHeatmap =
            provided.heatmap && typeof provided.heatmap === "object" ? provided.heatmap : {};
          return {
            axisText:
              typeof provided.axisText === "string" && provided.axisText.trim()
                ? provided.axisText.trim()
                : fallback.axisText,
            axisLine:
              typeof provided.axisLine === "string" && provided.axisLine.trim()
                ? provided.axisLine.trim()
                : fallback.axisLine,
            axisName:
              typeof provided.axisName === "string" && provided.axisName.trim()
                ? provided.axisName.trim()
                : fallback.axisName,
            markerLabel:
              typeof provided.markerLabel === "string" && provided.markerLabel.trim()
                ? provided.markerLabel.trim()
                : fallback.markerLabel,
            cursor:
              typeof provided.cursor === "string" && provided.cursor.trim()
                ? provided.cursor.trim()
                : fallback.cursor,
            series: {
              primary:
                typeof providedSeries.primary === "string" && providedSeries.primary.trim()
                  ? providedSeries.primary.trim()
                  : fallback.series.primary,
              volume:
                typeof providedSeries.volume === "string" && providedSeries.volume.trim()
                  ? providedSeries.volume.trim()
                  : fallback.series.volume,
              context:
                typeof providedSeries.context === "string" && providedSeries.context.trim()
                  ? providedSeries.context.trim()
                  : fallback.series.context,
              interval:
                typeof providedSeries.interval === "string" && providedSeries.interval.trim()
                  ? providedSeries.interval.trim()
                  : fallback.series.interval,
              reference:
                typeof providedSeries.reference === "string" && providedSeries.reference.trim()
                  ? providedSeries.reference.trim()
                  : fallback.series.reference,
            },
            alert: {
              lower:
                typeof providedAlert.lower === "string" && providedAlert.lower.trim()
                  ? providedAlert.lower.trim()
                  : fallback.alert.lower,
              upper:
                typeof providedAlert.upper === "string" && providedAlert.upper.trim()
                  ? providedAlert.upper.trim()
                  : fallback.alert.upper,
            },
            state: {
              low_power:
                typeof providedState.low_power === "string" && providedState.low_power.trim()
                  ? providedState.low_power.trim()
                  : fallback.state.low_power,
              outlier:
                typeof providedState.outlier === "string" && providedState.outlier.trim()
                  ? providedState.outlier.trim()
                  : fallback.state.outlier,
            },
            band: {
              alert_run:
                typeof providedBand.alert_run === "string" && providedBand.alert_run.trim()
                  ? providedBand.alert_run.trim()
                  : fallback.band.alert_run,
              comparator:
                typeof providedBand.comparator === "string" && providedBand.comparator.trim()
                  ? providedBand.comparator.trim()
                  : fallback.band.comparator,
            },
            heatmap: {
              rate_diverging: toArray(
                providedHeatmap.rate_diverging,
                fallback.heatmap.rate_diverging
              ),
              residual_diverging: toArray(
                providedHeatmap.residual_diverging,
                fallback.heatmap.residual_diverging
              ),
              volume_seq: toArray(providedHeatmap.volume_seq, fallback.heatmap.volume_seq),
            },
            categoricalPalette: toArray(
              provided.categorical_palette,
              fallback.categorical_palette
            ),
          };
        }

        function currentChartTheme() {
          const surfaceTheme = activeThemeId();
          if (semanticTokenCache.has(surfaceTheme)) {
            return semanticTokenCache.get(surfaceTheme);
          }
          const semanticTheme = resolveColorSemanticTheme(surfaceTheme);
          const tokens = {
            axisText: semanticTheme.axisText,
            axisLine: semanticTheme.axisLine,
            axisName: semanticTheme.axisName,
            markerLabel: semanticTheme.markerLabel,
            cursor: semanticTheme.cursor,
            gridLine:
              surfaceTheme === "dark"
                ? "rgba(148, 163, 184, 0.18)"
                : "rgba(71, 85, 105, 0.16)",
            splitAreaBands:
              surfaceTheme === "dark"
                ? ["rgba(148, 163, 184, 0.035)", "rgba(148, 163, 184, 0.01)"]
                : ["rgba(71, 85, 105, 0.035)", "rgba(71, 85, 105, 0.012)"],
            primaryLine: semanticTheme.series.primary,
            volumeBar: semanticTheme.series.volume,
            volumeBarOpacity: surfaceTheme === "dark" ? 0.42 : 0.4,
            contextLine: semanticTheme.series.context,
            intervalBand: semanticTheme.series.interval,
            referenceLine: semanticTheme.series.reference,
            alertLower: semanticTheme.alert.lower,
            alertUpper: semanticTheme.alert.upper,
            alert: semanticTheme.alert.lower,
            lowPower: semanticTheme.state.low_power,
            outlierPoint: semanticTheme.state.outlier,
            alertBandFill: semanticTheme.band.alert_run,
            comparatorBandFill: semanticTheme.band.comparator,
            heatmapRateDiverging: semanticTheme.heatmap.rate_diverging,
            heatmapDiverging: semanticTheme.heatmap.residual_diverging,
            heatmapVolume: semanticTheme.heatmap.volume_seq,
            heatmapNoData:
              surfaceTheme === "dark" ? "rgba(148, 163, 184, 0.24)" : "rgba(148, 163, 184, 0.18)",
            heatmapNoDataBorder:
              surfaceTheme === "dark" ? "rgba(148, 163, 184, 0.34)" : "rgba(148, 163, 184, 0.24)",
            heatmapRate: [
              semanticTheme.heatmap.volume_seq[0],
              semanticTheme.series.context,
              semanticTheme.series.primary,
            ],
            barAccent: semanticTheme.series.primary,
            scatterDefault: semanticTheme.series.primary,
            shadowColor: surfaceTheme === "dark" ? "rgba(12, 18, 30, 0.45)" : "rgba(15, 23, 42, 0.24)",
            seriesPalette: [
              semanticTheme.series.primary,
              semanticTheme.series.context,
              semanticTheme.series.interval,
              semanticTheme.alert.lower,
              semanticTheme.alert.upper,
              semanticTheme.state.low_power,
              semanticTheme.state.outlier,
              semanticTheme.series.reference,
            ],
            categoricalPalette: semanticTheme.categoricalPalette,
          };
          semanticTokenCache.set(surfaceTheme, tokens);
          return tokens;
        }

        function colorForExtraLine(metricName, index) {
          const theme = currentChartTheme();
          const key = String(metricName || "").toLowerCase();
          if (!key) {
            return theme.seriesPalette[index % theme.seriesPalette.length];
          }
          if (key.includes("expected")) {
            return theme.contextLine;
          }
          if (key.includes("control_low") || key.includes("control_high")) {
            return theme.intervalBand;
          }
          if (key.includes("stable") || key.includes("threshold")) {
            return theme.referenceLine;
          }
          if (key.includes("z_ref_zero")) {
            return theme.referenceLine;
          }
          if (key.includes("z_ref_pos")) {
            return theme.intervalBand;
          }
          if (key.includes("z_ref_neg")) {
            return theme.intervalBand;
          }
          if (key.includes("baseline")) {
            return theme.contextLine;
          }
          return theme.seriesPalette[index % theme.seriesPalette.length];
        }

        function styleForExtraLine(metricName, index, chartId) {
          const key = String(metricName || "").toLowerCase();
          const chart = String(chartId || "").toLowerCase();
          const offHoursDense =
            chart === "off_hours_control_timeline" || chart === "off_hours_primary_residual_timeline";
          const base = {
            width: offHoursDense ? 0.95 : 1.1,
            type: index === 0 ? "dashed" : "solid",
            opacity: offHoursDense ? 0.56 : 0.78,
          };
          if (!key) {
            return base;
          }
          if (key.includes("expected_pro_rate_primary")) {
            return {
              width: offHoursDense ? 1.15 : 1.25,
              type: "solid",
              opacity: offHoursDense ? 0.68 : 0.82,
            };
          }
          if (key.includes("expected_pro_rate_day")) {
            return {
              width: 1,
              type: "dashed",
              opacity: offHoursDense ? 0.42 : 0.56,
            };
          }
          if (key.includes("control_low") || key.includes("control_high")) {
            return {
              width: offHoursDense ? 0.9 : 1,
              type: "dashed",
              opacity: offHoursDense ? 0.4 : 0.58,
            };
          }
          if (key.includes("z_ref_zero")) {
            return {
              width: 1,
              type: "solid",
              opacity: offHoursDense ? 0.56 : 0.68,
            };
          }
          if (key.includes("z_ref_pos") || key.includes("z_ref_neg")) {
            return {
              width: 0.9,
              type: "dotted",
              opacity: offHoursDense ? 0.4 : 0.52,
            };
          }
          if (key.includes("baseline")) {
            return {
              width: 1,
              type: "dashed",
              opacity: offHoursDense ? 0.46 : 0.62,
            };
          }
          return base;
        }

        function toEpochMillis(value) {
          if (typeof value === "number" && Number.isFinite(value)) {
            return value;
          }
          if (!value) {
            return null;
          }
          const parsed = Date.parse(value);
          return Number.isFinite(parsed) ? parsed : null;
        }

        function applyReadableAxisStyle(axisConfig, axisKind) {
          if (!axisConfig || typeof axisConfig !== "object" || Array.isArray(axisConfig)) {
            return axisConfig;
          }
          const theme = currentChartTheme();
          const styled = Object.assign({}, axisConfig);

          styled.axisLabel = Object.assign(
            { color: theme.axisText, fontSize: 11 },
            styled.axisLabel || {}
          );
          if (toFiniteNumberOrNull(styled.axisLabel.margin) === null) {
            if (axisKind === "x") {
              const rotate = toFiniteNumberOrNull(styled.axisLabel.rotate);
              styled.axisLabel.margin = rotate !== null && Math.abs(rotate) >= 10 ? 16 : 12;
            } else {
              styled.axisLabel.margin = 8;
            }
          }

          const axisLine = Object.assign({}, styled.axisLine || {});
          axisLine.show = axisLine.show !== false;
          axisLine.lineStyle = Object.assign(
            { color: theme.axisLine, width: 1 },
            axisLine.lineStyle || {}
          );
          styled.axisLine = axisLine;

          const axisTick = Object.assign({}, styled.axisTick || {});
          axisTick.show = axisTick.show !== false;
          axisTick.lineStyle = Object.assign(
            { color: theme.axisLine },
            axisTick.lineStyle || {}
          );
          styled.axisTick = axisTick;

          const splitLine = Object.assign({}, styled.splitLine || {});
          splitLine.show = splitLine.show !== false;
          splitLine.lineStyle = Object.assign(
            { color: theme.gridLine, width: 1 },
            splitLine.lineStyle || {}
          );
          styled.splitLine = splitLine;

          const splitArea = Object.assign({}, styled.splitArea || {});
          if (splitArea.show) {
            const splitAreaStyle = Object.assign({}, splitArea.areaStyle || {});
            if (!Array.isArray(splitAreaStyle.color) || !splitAreaStyle.color.length) {
              splitAreaStyle.color = theme.splitAreaBands;
            }
            splitArea.areaStyle = splitAreaStyle;
          }
          styled.splitArea = splitArea;

          const hasName = typeof styled.name === "string" && styled.name.trim();
          if (hasName) {
            styled.nameTextStyle = Object.assign(
              { color: theme.axisName, fontSize: 12, fontWeight: 600 },
              styled.nameTextStyle || {}
            );
            if (!styled.nameLocation) {
              styled.nameLocation = "middle";
            }
            if (toFiniteNumberOrNull(styled.nameGap) === null) {
              styled.nameGap = axisKind === "x" ? 32 : 54;
            }
          }

          return styled;
        }

        function parsePixelLikeValue(value) {
          if (typeof value === "number" && Number.isFinite(value)) {
            return value;
          }
          if (typeof value !== "string") {
            return null;
          }
          const trimmed = value.trim();
          if (!trimmed || trimmed.endsWith("%")) {
            return null;
          }
          const parsed = Number(trimmed.replace(/px$/i, ""));
          return Number.isFinite(parsed) ? parsed : null;
        }

        function escapeHtml(value) {
          return String(value)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\"/g, "&quot;")
            .replace(/'/g, "&#39;");
        }

        function truncateLegendText(label, maxChars) {
          const source = String(label || "");
          if (!Number.isFinite(maxChars) || maxChars < 4 || source.length <= maxChars) {
            return source;
          }
          return source.slice(0, Math.max(1, maxChars - 1)).trimEnd() + "…";
        }

        function computeLegendDockMode(mount) {
          const viewportWidth =
            typeof window !== "undefined" && Number.isFinite(window.innerWidth)
              ? window.innerWidth
              : 0;
          const hostWidth =
            mount && mount.host && Number.isFinite(mount.host.clientWidth) ? mount.host.clientWidth : 0;
          let chartWidth = hostWidth;
          if (!(chartWidth > 0) && mount && mount.chart && typeof mount.chart.getWidth === "function") {
            const chartApiWidth = toFiniteNumberOrNull(mount.chart.getWidth());
            if (chartApiWidth !== null && chartApiWidth > 0) {
              chartWidth = chartApiWidth;
            }
          }

          const wideViewport = viewportWidth >= 1200;
          const wideChart = chartWidth >= 960;
          return wideViewport && wideChart ? "right" : "bottom";
        }

        function applyDockedLegendLayout(option, mount) {
          if (!option || typeof option !== "object" || !option.legend) {
            return option;
          }
          const theme = currentChartTheme();
          const dockRight = computeLegendDockMode(mount) === "right";
          if (mount && typeof mount === "object") {
            mount.legendDockMode = dockRight ? "right" : "bottom";
          }
          const maxLegendChars = dockRight ? 24 : 34;

          const styleLegend = (legendConfig) => {
            if (!legendConfig || typeof legendConfig !== "object" || Array.isArray(legendConfig)) {
              return legendConfig;
            }
            const styledLegend = Object.assign({}, legendConfig);
            const baseFormatter =
              typeof styledLegend.formatter === "function" ? styledLegend.formatter : null;

            if (dockRight) {
              styledLegend.type = "scroll";
              styledLegend.orient = "vertical";
              styledLegend.right = 8;
              styledLegend.top = 24;
              styledLegend.bottom = 24;
              delete styledLegend.left;
            } else {
              if (!styledLegend.orient) {
                styledLegend.orient = "horizontal";
              }
              if (toFiniteNumberOrNull(styledLegend.bottom) === null && typeof styledLegend.bottom !== "string") {
                styledLegend.bottom = 0;
              }
            }

            if (toFiniteNumberOrNull(styledLegend.itemWidth) === null) {
              styledLegend.itemWidth = 14;
            }
            if (toFiniteNumberOrNull(styledLegend.itemHeight) === null) {
              styledLegend.itemHeight = 10;
            }
            if (toFiniteNumberOrNull(styledLegend.itemGap) === null) {
              styledLegend.itemGap = dockRight ? 8 : 10;
            }

            styledLegend.formatter = (name) => {
              const baseLabel = baseFormatter ? baseFormatter(name) : name;
              return truncateLegendText(baseLabel, maxLegendChars);
            };

            const legendTooltip =
              styledLegend.tooltip && typeof styledLegend.tooltip === "object"
                ? Object.assign({}, styledLegend.tooltip)
                : {};
            styledLegend.tooltip = Object.assign({}, legendTooltip, {
              show: true,
              confine: true,
              formatter: (params) => {
                const fullLabel =
                  params && typeof params.name === "string"
                    ? params.name
                    : params && typeof params.value === "string"
                      ? params.value
                      : "";
                return escapeHtml(fullLabel);
              },
            });

            styledLegend.textStyle = Object.assign(
              {},
              styledLegend.textStyle || {},
              dockRight
                ? { width: 172, overflow: "truncate", ellipsis: "…", color: theme.axisText }
                : { color: theme.axisText }
            );

            return styledLegend;
          };

          const styled = Object.assign({}, option);
          styled.legend = Array.isArray(option.legend)
            ? option.legend.map((legendItem) => styleLegend(legendItem))
            : styleLegend(option.legend);

          if (dockRight && styled.grid && typeof styled.grid === "object") {
            if (Array.isArray(styled.grid)) {
              styled.grid = styled.grid.map((gridConfig) => {
                if (!gridConfig || typeof gridConfig !== "object") {
                  return gridConfig;
                }
                const gridRight = parsePixelLikeValue(gridConfig.right);
                return Object.assign({}, gridConfig, {
                  right: Math.max(gridRight === null ? 0 : gridRight, 228),
                });
              });
            } else {
              const gridRight = parsePixelLikeValue(styled.grid.right);
              styled.grid = Object.assign({}, styled.grid, {
                right: Math.max(gridRight === null ? 0 : gridRight, 228),
              });
            }
          }

          return styled;
        }

        function normalizeAxisArray(axisConfig) {
          if (!axisConfig) {
            return [];
          }
          return Array.isArray(axisConfig) ? axisConfig : [axisConfig];
        }

        function hasNamedXAxis(option) {
          return normalizeAxisArray(option && option.xAxis).some(
            (axis) => axis && typeof axis.name === "string" && axis.name.trim()
          );
        }

        function hasSliderDataZoom(option) {
          const zoomEntries = Array.isArray(option && option.dataZoom)
            ? option.dataZoom
            : option && option.dataZoom
              ? [option.dataZoom]
              : [];
          return zoomEntries.some((entry) => {
            if (!entry || typeof entry !== "object") {
              return false;
            }
            const zoomType = String(entry.type || "").toLowerCase();
            return zoomType === "slider";
          });
        }

        function hasVisualMap(option) {
          if (!option || typeof option !== "object") {
            return false;
          }
          if (Array.isArray(option.visualMap)) {
            return option.visualMap.length > 0;
          }
          return !!option.visualMap;
        }

        function hasRotatedXAxisLabels(option) {
          return normalizeAxisArray(option && option.xAxis).some((axis) => {
            if (!axis || typeof axis !== "object") {
              return false;
            }
            const axisLabel = axis.axisLabel;
            if (!axisLabel || typeof axisLabel !== "object") {
              return false;
            }
            const rotate = toFiniteNumberOrNull(axisLabel.rotate);
            return rotate !== null && Math.abs(rotate) >= 10;
          });
        }

        function legendDockIsBottom(option) {
          if (!option || !option.legend) {
            return false;
          }
          const legends = Array.isArray(option.legend) ? option.legend : [option.legend];
          return legends.some((legend) => {
            if (!legend || typeof legend !== "object") {
              return false;
            }
            const orient = String(legend.orient || "horizontal").toLowerCase();
            return orient !== "vertical";
          });
        }

        function reserveXAxisBottomSpace(option) {
          if (!option || typeof option !== "object" || !option.grid) {
            return option;
          }
          const hasName = hasNamedXAxis(option);
          const sliderZoom = hasSliderDataZoom(option);
          const visualMapEnabled = hasVisualMap(option);
          const rotatedXLabels = hasRotatedXAxisLabels(option);
          const legendAtBottom = legendDockIsBottom(option);

          let minBottom = 56;
          if (hasName) {
            minBottom += 16;
          }
          if (rotatedXLabels) {
            minBottom += 16;
          }
          if (sliderZoom) {
            minBottom += 42;
          }
          if (visualMapEnabled) {
            minBottom += 56;
          }
          if (legendAtBottom) {
            minBottom += 22;
          }

          const applyBottom = (gridConfig) => {
            if (!gridConfig || typeof gridConfig !== "object" || Array.isArray(gridConfig)) {
              return gridConfig;
            }
            const existingBottom = parsePixelLikeValue(gridConfig.bottom);
            if (existingBottom !== null || typeof gridConfig.bottom === "string") {
              return gridConfig;
            }
            return Object.assign({}, gridConfig, { bottom: minBottom });
          };

          const updated = Object.assign({}, option);
          updated.grid = Array.isArray(option.grid)
            ? option.grid.map((gridEntry) => applyBottom(gridEntry))
            : applyBottom(option.grid);
          return updated;
        }

        function ensureReadableAxes(option, mount) {
          if (!option || typeof option !== "object") {
            return option;
          }
          const styled = Object.assign({}, option);

          if (Array.isArray(styled.xAxis)) {
            styled.xAxis = styled.xAxis.map((axis) =>
              applyReadableAxisStyle(axis, "x")
            );
          } else if (styled.xAxis && typeof styled.xAxis === "object") {
            styled.xAxis = applyReadableAxisStyle(styled.xAxis, "x");
          }

          if (Array.isArray(styled.yAxis)) {
            styled.yAxis = styled.yAxis.map((axis) =>
              applyReadableAxisStyle(axis, "y")
            );
          } else if (styled.yAxis && typeof styled.yAxis === "object") {
            styled.yAxis = applyReadableAxisStyle(styled.yAxis, "y");
          }

          const withLegendLayout = applyDockedLegendLayout(styled, mount);
          return reserveXAxisBottomSpace(withLegendLayout);
        }

        function formatPercent(value, digits) {
          const parsed = toFiniteNumberOrNull(value);
          if (parsed === null) {
            return "-";
          }
          const precision = Number.isFinite(digits) ? digits : 1;
          return (parsed * 100).toFixed(precision) + "%";
        }

        function formatRatio(numerator, denominator, digits) {
          const num = toFiniteNumberOrNull(numerator);
          const den = toFiniteNumberOrNull(denominator);
          if (num === null || den === null || den <= 0) {
            return "-";
          }
          const precision = Number.isFinite(digits) ? digits : 1;
          return (num / den * 100).toFixed(precision) + "%";
        }

        function formatDateRange(startIso, endIso) {
          const start = toEpochMillis(startIso);
          const end = toEpochMillis(endIso);
          if (start === null || end === null) {
            return "-";
          }
          return formatEpochMillis(start) + " to " + formatEpochMillis(end);
        }

        function processMarkerDisplayLabel(marker) {
          const explicit = marker && typeof marker.label === "string" ? marker.label.trim() : "";
          if (explicit) {
            return explicit;
          }
          const key = marker && typeof marker.key === "string" ? marker.key : "";
          if (!key) {
            return "Process marker";
          }
          return key
            .replace(/_/g, " ")
            .replace(/\s+/g, " ")
            .trim();
        }

        function processMarkerColor(markerKey) {
          const theme = currentChartTheme();
          if (markerKey === "meeting_start") {
            return theme.contextLine;
          }
          if (markerKey === "sign_in_open") {
            return theme.primaryLine;
          }
          if (markerKey === "sign_in_cutoff") {
            return theme.lowPower;
          }
          if (markerKey === "written_testimony_deadline") {
            return theme.alertLower;
          }
          return theme.axisText;
        }

        function buildProcessMarkerLines() {
          return processMarkers
            .map((marker) => {
              const markerTime = toEpochMillis(
                marker && (marker.time_iso || marker.timestamp || marker.time)
              );
              if (markerTime === null) {
                return null;
              }
              const markerKey = marker && typeof marker.key === "string" ? marker.key : "";
              return {
                xAxis: markerTime,
                lineStyle: {
                  color: processMarkerColor(markerKey),
                  width: 1.2,
                  opacity: 0.88,
                  type: "dashed",
                },
                label: {
                  show: true,
                  formatter: processMarkerDisplayLabel(marker),
                  position: "insideEndTop",
                  color: currentChartTheme().markerLabel,
                  fontSize: 10,
                },
              };
            })
            .filter((entry) => !!entry);
        }

        function dedupModeLabel(mode) {
          if (mode === "raw") {
            return "Raw";
          }
          if (mode === "exact_row_dedup") {
            return "Exact row dedup";
          }
          if (mode === "side_by_side") {
            return "Side-by-side";
          }
          return mode;
        }

        function themeLabel(themeId) {
          if (themeId === "light") {
            return "Light";
          }
          if (themeId === "dark") {
            return "Dark";
          }
          return themeId;
        }

        function syncThemeButtons(activeTheme) {
          const buttons = Array.from(
            document.querySelectorAll('[data-theme-option]')
          );
          buttons.forEach((button) => {
            const option = String(button.getAttribute("data-theme-option") || "").trim();
            const isActive = option === activeTheme;
            button.classList.toggle("is-active", isActive);
            button.setAttribute("aria-pressed", isActive ? "true" : "false");
          });
        }

        function applyTheme(themeId, persist) {
          const canPersist = persist !== false;
          const availableThemes = Array.from(
            new Set(
              themeOptions
                .map((entry) => (entry && typeof entry.id === "string" ? entry.id.trim() : ""))
                .filter((entry) => !!entry)
            )
          );
          if (!availableThemes.length) {
            availableThemes.push("light", "dark");
          }
          const resolved = availableThemes.includes(themeId) ? themeId : availableThemes[0];
          document.documentElement.setAttribute("data-theme", resolved);
          syncThemeButtons(resolved);
          if (!canPersist) {
            return;
          }
          try {
            window.localStorage.setItem("testifier_audit_theme", resolved);
          } catch (_error) {}
        }

        function initThemeControl() {
          const controlsRoot = document.getElementById("theme-controls");

          const options = Array.from(
            new Set(
              themeOptions
                .map((entry) => (entry && typeof entry.id === "string" ? entry.id.trim() : ""))
                .filter((entry) => !!entry)
            )
          );
          if (!options.length) {
            options.push("light", "dark");
          }

          let savedTheme = "";
          try {
            savedTheme = String(window.localStorage.getItem("testifier_audit_theme") || "").trim();
          } catch (_error) {}

          const selectedTheme = options.includes(savedTheme)
            ? savedTheme
            : options.includes(defaultTheme)
              ? defaultTheme
              : options[0];
          applyTheme(selectedTheme, false);

          if (!controlsRoot) {
            return;
          }

          const buttons = Array.from(
            controlsRoot.querySelectorAll('[data-theme-option]')
          );
          buttons.forEach((button) => {
            const option = String(button.getAttribute("data-theme-option") || "").trim();
            const explicit = themeOptions.find(
              (entry) => entry && typeof entry.id === "string" && entry.id.trim() === option
            );
            button.setAttribute(
              "aria-label",
              explicit && typeof explicit.label === "string" && explicit.label.trim()
                ? explicit.label.trim()
                : themeLabel(option)
            );
            button.addEventListener("click", () => {
              if (!options.includes(option)) {
                return;
              }
              applyTheme(option, true);
              chartMounts.forEach((mount) => renderChartMount(mount));
              scheduleChartResizeSequence();
            });
          });
        }

        function createChartInstance(host) {
          if (!hasEcharts) {
            return null;
          }
          return window.echarts.init(host);
        }

        function initSidebarTooltips() {
          const tooltipTargets = Array.from(document.querySelectorAll("[data-tooltip]"));
          if (!tooltipTargets.length) {
            return;
          }

          if (typeof window.tippy === "function") {
            window.tippy(tooltipTargets, {
              content(reference) {
                return String(reference.getAttribute("data-tooltip") || "");
              },
              allowHTML: false,
              theme: "light-border",
              maxWidth: 320,
              delay: [120, 40],
              placement: "right",
            });
            return;
          }

          tooltipTargets.forEach((target) => {
            if (!target.getAttribute("title")) {
              target.setAttribute("title", String(target.getAttribute("data-tooltip") || ""));
            }
          });
        }

        function setListItems(host, items) {
          if (!host) {
            return;
          }
          host.innerHTML = "";
          const values = Array.isArray(items)
            ? items.map((item) => String(item || "").trim()).filter((item) => !!item)
            : [];
          if (!values.length) {
            const empty = document.createElement("li");
            empty.textContent = "No guidance available for this run.";
            host.appendChild(empty);
            return;
          }
          values.forEach((value) => {
            const item = document.createElement("li");
            item.textContent = value;
            host.appendChild(item);
          });
        }

        function renderMethodologyPanel() {
          const definitionsHost = document.getElementById("methodology-definitions-host");
          const testsHost = document.getElementById("methodology-tests-used-host");
          const guardrailsHost = document.getElementById("methodology-guardrails-host");
          const multipleTestingHost = document.getElementById("methodology-multiple-testing-list");
          const caveatsHost = document.getElementById("methodology-caveats-list");
          const guidanceHost = document.getElementById("methodology-guidance-list");

          const definitions = Array.isArray(methodology.definitions) ? methodology.definitions : [];
          const testsUsed = Array.isArray(methodology.tests_used) ? methodology.tests_used : [];
          const guardrails = Array.isArray(methodology.ethical_guardrails)
            ? methodology.ethical_guardrails
            : [];
          const multipleTesting = Array.isArray(methodology.multiple_testing_policy)
            ? methodology.multiple_testing_policy
            : [];
          const caveats = Array.isArray(methodology.caveats) ? methodology.caveats : [];
          const guidance = Array.isArray(methodology.interpretation_guidance)
            ? methodology.interpretation_guidance
            : [];

          mountTable(definitionsHost, definitions, {
            pagination: false,
            maxHeight: "280px",
          });
          mountTable(testsHost, testsUsed, {
            pagination: false,
            maxHeight: "320px",
          });
          mountTable(guardrailsHost, guardrails, {
            pagination: false,
            maxHeight: "260px",
          });
          setListItems(multipleTestingHost, multipleTesting);
          setListItems(caveatsHost, caveats);
          setListItems(guidanceHost, guidance);
        }

        function getCrossHearingComparator(metric) {
          const key = String(metric || "").trim();
          if (!key) {
            return null;
          }
          const row = crossHearingComparatorByMetric.get(key);
          if (!row || typeof row !== "object") {
            return null;
          }
          const bandP10 = toFiniteNumberOrNull(row.band_p10);
          const bandP50 = toFiniteNumberOrNull(row.band_p50);
          const bandP90 = toFiniteNumberOrNull(row.band_p90);
          if (bandP10 === null && bandP50 === null && bandP90 === null) {
            return null;
          }
          return {
            metric: key,
            label:
              typeof row.label === "string" && row.label.trim()
                ? row.label.trim()
                : key.replace(/_/g, " "),
            nReports: Number(toNumber(row.n_reports || crossHearingBaseline.report_count || 0)),
            percentile: toFiniteNumberOrNull(row.percentile),
            bandP10: bandP10,
            bandP50: bandP50,
            bandP90: bandP90,
          };
        }

        function getTriageView(mode) {
          const key = String(mode || "");
          const view = triageViews[key];
          if (view && typeof view === "object") {
            return view;
          }
          if (key === "raw" || !key) {
            return {
              triage_summary: triageSummary,
              window_evidence_queue: windowEvidenceQueue,
              record_evidence_queue: recordEvidenceQueue,
              cluster_evidence_queue: clusterEvidenceQueue,
            };
          }
          return {
            triage_summary: triageSummary,
            window_evidence_queue: windowEvidenceQueue,
            record_evidence_queue: recordEvidenceQueue,
            cluster_evidence_queue: clusterEvidenceQueue,
          };
        }

        function getActiveTriageView() {
          return getTriageView(state.activeDedupMode);
        }

        function rowsToCsv(rows) {
          const dataset = Array.isArray(rows) ? rows : [];
          if (!dataset.length) {
            return "";
          }
          const columns = Array.from(new Set(dataset.flatMap((row) => Object.keys(row || {}))));
          const encode = (value) => {
            if (value === null || value === undefined) {
              return "";
            }
            if (Array.isArray(value) || (value && typeof value === "object")) {
              return JSON.stringify(value);
            }
            return String(value);
          };
          const header = columns.join(",");
          const body = dataset
            .map((row) =>
              columns
                .map((column) => {
                  const raw = encode(row ? row[column] : "");
                  const escaped = raw.replace(/"/g, '""');
                  return '"' + escaped + '"';
                })
                .join(",")
            )
            .join("\n");
          return header + "\n" + body + "\n";
        }

        function downloadCsv(filename, rows) {
          const csv = rowsToCsv(rows);
          if (!csv) {
            return false;
          }
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          return true;
        }

        function buildDateTimeFormatter(timezoneName) {
          const options = {
            timeZone: timezoneName,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false,
          };
          try {
            return new Intl.DateTimeFormat(undefined, options);
          } catch (_error) {
            return new Intl.DateTimeFormat(
              undefined,
              Object.assign({}, options, { timeZone: "America/Los_Angeles" })
            );
          }
        }

        const reportDateTimeFormatter = buildDateTimeFormatter(reportTimezone);

        function formatEpochMillis(epochMillis) {
          if (!Number.isFinite(epochMillis)) {
            return "";
          }
          return reportDateTimeFormatter.format(new Date(epochMillis));
        }

        function formatDurationCompact(epochDelta) {
          const millis = toFiniteNumberOrNull(epochDelta);
          if (millis === null || millis <= 0) {
            return "-";
          }
          const totalMinutes = Math.floor(millis / 60000);
          if (totalMinutes < 1) {
            return "under 1m";
          }

          const days = Math.floor(totalMinutes / 1440);
          const hours = Math.floor((totalMinutes % 1440) / 60);
          const minutes = totalMinutes % 60;
          const parts = [];
          if (days > 0) {
            parts.push(String(days) + "d");
          }
          if (hours > 0) {
            parts.push(String(hours) + "h");
          }
          if (minutes > 0 && parts.length < 2) {
            parts.push(String(minutes) + "m");
          }
          if (!parts.length) {
            parts.push("0m");
          }
          return parts.join(" ");
        }

        function formatCoveragePercent(ratio) {
          const numeric = toFiniteNumberOrNull(ratio);
          if (numeric === null || numeric < 0) {
            return null;
          }
          const bounded = Math.max(0, Math.min(1, numeric));
          const percent = bounded * 100;
          if (percent < 0.1) {
            return "<0.1%";
          }
          if (percent > 99.95) {
            return "100%";
          }
          return percent.toFixed(1) + "%";
        }

        function formatTooltipValue(value) {
          const numeric = toFiniteNumberOrNull(value);
          if (numeric === null) {
            return "n/a";
          }
          const abs = Math.abs(numeric);
          if (abs >= 1000) {
            return numeric.toLocaleString(undefined, { maximumFractionDigits: 2 });
          }
          if (abs >= 1) {
            return numeric.toFixed(2);
          }
          if (abs === 0) {
            return "0";
          }
          return numeric.toFixed(4);
        }

        function bucketLabelFromValue(value) {
          const bucketMinutes = toFiniteNumberOrNull(value);
          return bucketMinutes !== null ? String(bucketMinutes) + "m" : null;
        }

        function normalizeHashId(rawValue) {
          const stripped = String(rawValue || "")
            .replace(/^#/, "")
            .trim();
          if (!stripped) {
            return "";
          }
          try {
            return decodeURIComponent(stripped);
          } catch (_error) {
            return stripped;
          }
        }

        function replaceUrlHashWithoutHistory(headingId) {
          const normalized = normalizeHashId(headingId);
          if (!normalized) {
            return;
          }
          const nextHash = "#" + normalized;
          if (window.location.hash === nextHash) {
            return;
          }
          if (window.history && typeof window.history.replaceState === "function") {
            try {
              const currentUrl = new window.URL(window.location.href);
              currentUrl.hash = nextHash;
              const nextUrl = currentUrl.pathname + currentUrl.search + currentUrl.hash;
              window.history.replaceState(window.history.state || null, "", nextUrl);
              return;
            } catch (_error) {}
          }
          window.location.hash = nextHash;
        }

        function updateUrlQueryParams(mutator) {
          if (
            !window.URL ||
            typeof window.URLSearchParams === "undefined" ||
            !window.history ||
            typeof window.history.replaceState !== "function"
          ) {
            return;
          }
          const currentUrl = new window.URL(window.location.href);
          const params = new window.URLSearchParams(currentUrl.search || "");
          mutator(params);
          const nextSearch = params.toString();
          const nextUrl =
            currentUrl.pathname +
            (nextSearch ? "?" + nextSearch : "") +
            (currentUrl.hash || "");
          const currentPath = window.location.pathname + window.location.search + window.location.hash;
          if (nextUrl !== currentPath) {
            window.history.replaceState(window.history.state || null, "", nextUrl);
          }
        }

        function syncControlOverridesToUrl() {
          updateUrlQueryParams((params) => {
            [
              "bucket",
              "bucket_minutes",
              "linked_bucket_minutes",
            ].forEach((key) => params.delete(key));
            if (
              Number.isFinite(state.activeBucket) &&
              Number.isFinite(state.defaultBucket) &&
              state.activeBucket !== state.defaultBucket
            ) {
              params.set("bucket", String(Math.round(state.activeBucket)));
            }

            [
              "zoom_start",
              "linked_zoom_start",
              "zoom_min",
              "zoom_min_time",
              "zoomStart",
            ].forEach((key) => params.delete(key));
            [
              "zoom_end",
              "linked_zoom_end",
              "zoom_max",
              "zoom_max_time",
              "zoomEnd",
            ].forEach((key) => params.delete(key));
            if (
              Number.isFinite(state.zoom.minTime) &&
              Number.isFinite(state.zoom.maxTime) &&
              state.zoom.maxTime > state.zoom.minTime
            ) {
              params.set("zoom_start", String(Math.round(state.zoom.minTime)));
              params.set("zoom_end", String(Math.round(state.zoom.maxTime)));
            }
          });
        }

        function copyTextToClipboard(text) {
          const value = String(text || "");
          if (!value) {
            return Promise.reject(new Error("Nothing to copy"));
          }
          if (
            window.navigator &&
            window.navigator.clipboard &&
            typeof window.navigator.clipboard.writeText === "function"
          ) {
            return window.navigator.clipboard.writeText(value);
          }
          return new Promise((resolve, reject) => {
            try {
              const input = document.createElement("textarea");
              input.value = value;
              input.setAttribute("readonly", "");
              input.style.position = "absolute";
              input.style.left = "-9999px";
              document.body.appendChild(input);
              input.select();
              const succeeded = document.execCommand("copy");
              document.body.removeChild(input);
              if (!succeeded) {
                reject(new Error("Copy command failed"));
                return;
              }
              resolve();
            } catch (error) {
              reject(error);
            }
          });
        }

        function setActiveTocHeading(headingId, syncUrl) {
          const normalized = normalizeHashId(headingId);
          if (!normalized || state.activeTocHeading === normalized) {
            return;
          }
          state.activeTocHeading = normalized;

          if (typeof state.renderToc === "function") {
            state.renderToc(normalized);
          } else {
            const links = Array.from(document.querySelectorAll('#report-toc a[href^="#"]'));
            links.forEach((link) => {
              const isActive = normalizeHashId(link.getAttribute("href")) === normalized;
              link.classList.toggle("is-active-link", isActive);
              if (isActive) {
                link.setAttribute("aria-current", "true");
              } else {
                link.removeAttribute("aria-current");
              }
            });
          }

          if (syncUrl) {
            replaceUrlHashWithoutHistory(normalized);
          }
        }

        function seriesData(rows, xField, yField) {
          return rows
            .map((row) => {
              const x = toEpochMillis(row[xField]);
              const y = toFiniteNumberOrNull(row[yField]);
              return x === null ? null : [x, y];
            })
            .filter((entry) => entry !== null)
            .sort((left, right) => left[0] - right[0]);
        }

        function inferTimeField(rows) {
          if (!rows.length) {
            return null;
          }
          const candidates = [
            "minute_bucket",
            "bucket_start",
            "start_minute",
            "first_seen",
            "change_minute",
            "date",
          ];
          const row = rows[0] || {};
          for (const field of candidates) {
            if (Object.prototype.hasOwnProperty.call(row, field)) {
              if (field === "date" && Object.prototype.hasOwnProperty.call(row, "slot_start_minute")) {
                continue;
              }
              return field;
            }
          }
          return null;
        }

        function numericFields(row) {
          return Object.keys(row || {}).filter((key) => typeof row[key] === "number" && Number.isFinite(row[key]));
        }

        function setEmptyForChart(chartId, isEmpty) {
          const element = document.querySelector('[data-chart-empty-for="' + chartId + '"]');
          if (!element) {
            return;
          }
          element.classList.toggle("hidden", !isEmpty);
        }

        function setChartNote(chartId, text) {
          const element = document.querySelector('[data-chart-note-for="' + chartId + '"]');
          if (!element) {
            return;
          }
          element.textContent = text || "";
        }

        function composeChartNote(mount, fallbackNote) {
          const parts = [];
          if (mount && Number.isFinite(mount.activeBucket)) {
            parts.push("Bucket: " + mount.activeBucket + "m.");
          }
          if (mount && mount.crossHearingComparatorNote) {
            parts.push(mount.crossHearingComparatorNote);
          }
          if (mount && mount.customChartNote) {
            parts.push(mount.customChartNote);
          }
          if (fallbackNote) {
            parts.push(fallbackNote);
          }
          return parts.join(" ");
        }

        function resizeCharts() {
          chartInstances.forEach((instance) => {
            if (instance && typeof instance.resize === "function") {
              instance.resize();
            }
          });
        }

        function scheduleChartResizeSequence() {
          window.requestAnimationFrame(() => resizeCharts());
          window.setTimeout(() => resizeCharts(), 120);
          window.setTimeout(() => resizeCharts(), 260);
          scheduleLegendLayoutRerender();
        }

        let legendLayoutRerenderTimer = null;

        function rerenderChartsForLegendLayoutIfNeeded() {
          if (!hasEcharts || !chartMounts.size) {
            return;
          }
          let rerendered = false;
          chartMounts.forEach((mount) => {
            if (!mount || !mount.host) {
              return;
            }
            const expectedMode = computeLegendDockMode(mount);
            const currentMode =
              typeof mount.legendDockMode === "string" && mount.legendDockMode
                ? mount.legendDockMode
                : "";
            if (currentMode && currentMode !== expectedMode) {
              renderChartMount(mount);
              rerendered = true;
            }
          });
          if (rerendered) {
            updateCursorAcrossTimeCharts();
            updateZoomRangeLabel();
          }
        }

        function scheduleLegendLayoutRerender() {
          if (legendLayoutRerenderTimer !== null) {
            window.clearTimeout(legendLayoutRerenderTimer);
          }
          legendLayoutRerenderTimer = window.setTimeout(() => {
            legendLayoutRerenderTimer = null;
            rerenderChartsForLegendLayoutIfNeeded();
          }, 180);
        }

        let busyToken = 0;

        function setBusyIndicator(isVisible, text) {
          const root = document.getElementById("report-busy-indicator");
          if (!root) {
            return;
          }
          const label = document.getElementById("report-busy-text");
          if (label && text) {
            label.textContent = text;
          }
          root.classList.toggle("hidden", !isVisible);
        }

        function showDataLoadError(message, error) {
          if (error) {
            console.error(message, error);
          } else {
            console.error(message);
          }
          const busyIndicator = document.getElementById("report-busy-indicator");
          const busyText = document.getElementById("report-busy-text");
          if (busyText) {
            busyText.textContent = message;
          }
          if (busyIndicator) {
            busyIndicator.classList.remove("hidden");
          }
        }

        async function runWithBusyIndicator(text, action) {
          busyToken += 1;
          const token = busyToken;
          setBusyIndicator(true, text);
          clearAllChartInteractionState();
          await new Promise((resolve) => {
            window.requestAnimationFrame(() => {
              window.requestAnimationFrame(resolve);
            });
          });
          try {
            return await action();
          } catch (error) {
            showDataLoadError(
              "Unable to load report data files. Serve this report directory over HTTP and refresh.",
              error
            );
            return null;
          } finally {
            window.setTimeout(() => {
              if (token === busyToken) {
                setBusyIndicator(false);
              }
            }, 140);
          }
        }

        function normalizeBucketKey(value) {
          const parsed = toFiniteNumberOrNull(value);
          if (parsed === null || parsed <= 0) {
            return null;
          }
          return String(Math.round(parsed));
        }

        function chartRowsFromMap(payload) {
          return payload && typeof payload === "object" && !Array.isArray(payload)
            ? payload
            : {};
        }

        function setChartLoading(chartId, isLoading, noteText) {
          const host = document.querySelector('[data-chart-id="' + chartId + '"]');
          if (host) {
            host.classList.toggle("is-loading", !!isLoading);
            host.setAttribute("aria-busy", isLoading ? "true" : "false");
          }
          if (isLoading) {
            setEmptyForChart(chartId, false);
            setChartNote(chartId, noteText || "Loading chart data...");
          }
        }

        function setSectionLoading(section, isLoading, noteText) {
          if (!section) {
            return;
          }
          const hosts = Array.from(section.querySelectorAll("[data-chart-id]"));
          hosts.forEach((host) => {
            const chartId = String(host.getAttribute("data-chart-id") || "").trim();
            if (!chartId) {
              return;
            }
            setChartLoading(chartId, isLoading, noteText);
          });
        }

        async function fetchJsonPayload(url, contextLabel) {
          const target = String(url || "").trim();
          if (!target) {
            return {};
          }
          const response = await fetch(target);
          if (!response.ok) {
            throw new Error(
              "HTTP " + String(response.status || "") + " while loading " + contextLabel
            );
          }
          const payload = await response.json();
          return payload && typeof payload === "object" ? payload : {};
        }

        function mergeChartShardPayload(payload, bucketKey) {
          const charts = chartRowsFromMap(payload ? payload.charts : null);
          Object.keys(charts).forEach((chartIdRaw) => {
            const chartId = String(chartIdRaw || "").trim();
            if (!chartId) {
              return;
            }
            const rows = Array.isArray(charts[chartIdRaw]) ? charts[chartIdRaw] : [];
            if (bucketKey === null) {
              chartBaseRowsMap[chartId] = rows;
              return;
            }
            let bucketMap = chartBucketRowsMap.get(chartId);
            if (!bucketMap) {
              bucketMap = new Map();
              chartBucketRowsMap.set(chartId, bucketMap);
            }
            bucketMap.set(bucketKey, rows);
          });
        }

        function getChartBucketOptions(chartId, rows) {
          const manifestOptions = chartBucketOptionsByChart.get(chartId);
          if (Array.isArray(manifestOptions) && manifestOptions.length) {
            return manifestOptions.slice();
          }
          return uniqueBucketOptions(rows);
        }

        function resolveBucketTarget(options) {
          if (!options.length) {
            return { bucket: null, note: "" };
          }
          let target = state.activeBucket;
          if (!Number.isFinite(target)) {
            if (Number.isFinite(state.defaultBucket) && options.includes(state.defaultBucket)) {
              target = state.defaultBucket;
            } else {
              target = options.includes(30) ? 30 : options[0];
            }
          }
          if (!options.includes(target)) {
            const nearest = options
              .slice()
              .sort((left, right) => Math.abs(left - target) - Math.abs(right - target))[0];
            return {
              bucket: nearest,
              note:
                "Requested " +
                target +
                "m is unavailable for this chart; showing " +
                nearest +
                "m instead.",
            };
          }
          return { bucket: target, note: "" };
        }

        function chartShardEntryForAnalysis(analysisId) {
          const key = String(analysisId || "").trim();
          if (!key) {
            return null;
          }
          const direct = chartShardManifestByAnalysis[key];
          if (direct && typeof direct === "object") {
            return direct;
          }
          return null;
        }

        async function ensureAnalysisBaseLoaded(analysisId) {
          const key = String(analysisId || "").trim();
          if (!key) {
            return;
          }
          const manifest = chartShardEntryForAnalysis(key);
          if (!manifest || typeof manifest.base_url !== "string" || !manifest.base_url.trim()) {
            loadedAnalysisBase.add(key);
            return;
          }
          if (loadedAnalysisBase.has(key)) {
            return;
          }
          const inFlight = loadingAnalysisBase.get(key);
          if (inFlight) {
            await inFlight;
            return;
          }
          const promise = (async () => {
            const payload = await fetchJsonPayload(
              manifest.base_url,
              "base analysis shard for " + key
            );
            mergeChartShardPayload(payload, null);
            loadedAnalysisBase.add(key);
          })();
          loadingAnalysisBase.set(key, promise);
          try {
            await promise;
          } finally {
            loadingAnalysisBase.delete(key);
          }
        }

        function analysisBucketSet(analysisId) {
          const key = String(analysisId || "").trim();
          let bucketSet = loadedAnalysisBuckets.get(key);
          if (!bucketSet) {
            bucketSet = new Set();
            loadedAnalysisBuckets.set(key, bucketSet);
          }
          return bucketSet;
        }

        function analysisBucketPendingMap(analysisId) {
          const key = String(analysisId || "").trim();
          let pendingMap = loadingAnalysisBuckets.get(key);
          if (!pendingMap) {
            pendingMap = new Map();
            loadingAnalysisBuckets.set(key, pendingMap);
          }
          return pendingMap;
        }

        async function ensureAnalysisBucketLoaded(analysisId, bucketMinutes) {
          const key = String(analysisId || "").trim();
          const bucketKey = normalizeBucketKey(bucketMinutes);
          if (!key || !bucketKey) {
            return;
          }
          const manifest = chartShardEntryForAnalysis(key);
          if (!manifest || typeof manifest !== "object") {
            return;
          }
          const bucketUrls =
            manifest.bucket_urls && typeof manifest.bucket_urls === "object"
              ? manifest.bucket_urls
              : {};
          const targetUrl =
            typeof bucketUrls[bucketKey] === "string" ? bucketUrls[bucketKey].trim() : "";
          if (!targetUrl) {
            return;
          }
          const loadedBuckets = analysisBucketSet(key);
          if (loadedBuckets.has(bucketKey)) {
            return;
          }
          const pendingMap = analysisBucketPendingMap(key);
          const inFlight = pendingMap.get(bucketKey);
          if (inFlight) {
            await inFlight;
            return;
          }
          const promise = (async () => {
            const payload = await fetchJsonPayload(
              targetUrl,
              "bucket " + bucketKey + "m shard for " + key
            );
            mergeChartShardPayload(payload, bucketKey);
            loadedBuckets.add(bucketKey);
          })();
          pendingMap.set(bucketKey, promise);
          try {
            await promise;
          } finally {
            pendingMap.delete(bucketKey);
          }
        }

        function resolvedBucketsForAnalysis(analysisId) {
          const manifest = chartShardEntryForAnalysis(analysisId);
          if (!manifest || typeof manifest !== "object") {
            return [];
          }
          const chartOptions =
            manifest.chart_bucket_options && typeof manifest.chart_bucket_options === "object"
              ? manifest.chart_bucket_options
              : {};
          const resolved = new Set();
          Object.keys(chartOptions).forEach((chartIdRaw) => {
            const chartId = String(chartIdRaw || "").trim();
            if (!chartId) {
              return;
            }
            const rows = Array.isArray(chartBaseRowsMap[chartId]) ? chartBaseRowsMap[chartId] : [];
            const options = getChartBucketOptions(chartId, rows);
            const selection = resolveBucketTarget(options);
            if (Number.isFinite(selection.bucket)) {
              resolved.add(Math.round(selection.bucket));
            }
          });
          return Array.from(resolved).sort((left, right) => left - right);
        }

        function analysisNeedsShardLoad(analysisId) {
          const key = String(analysisId || "").trim();
          if (!key) {
            return false;
          }
          const manifest = chartShardEntryForAnalysis(key);
          if (!manifest || typeof manifest !== "object") {
            return false;
          }
          if (!loadedAnalysisBase.has(key)) {
            return true;
          }
          const buckets = resolvedBucketsForAnalysis(key);
          if (!buckets.length) {
            return false;
          }
          const loadedBuckets = analysisBucketSet(key);
          return buckets.some((bucket) => !loadedBuckets.has(String(Math.round(bucket))));
        }

        async function ensureAnalysisDataLoaded(analysisId) {
          const key = String(analysisId || "").trim();
          if (!key) {
            return;
          }
          const manifest = chartShardEntryForAnalysis(key);
          if (!manifest || typeof manifest !== "object") {
            return;
          }
          await ensureAnalysisBaseLoaded(key);
          const buckets = resolvedBucketsForAnalysis(key);
          if (!buckets.length) {
            return;
          }
          await Promise.all(buckets.map((bucket) => ensureAnalysisBucketLoaded(key, bucket)));
        }

        function getChartRows(chartId) {
          const baseRows = Array.isArray(chartBaseRowsMap[chartId]) ? chartBaseRowsMap[chartId] : [];
          const bucketMap = chartBucketRowsMap.get(chartId);
          if (!bucketMap || !bucketMap.size) {
            return baseRows;
          }
          const options = getChartBucketOptions(chartId, baseRows);
          if (!options.length) {
            const mergedRows = [];
            bucketMap.forEach((rows) => {
              if (Array.isArray(rows) && rows.length) {
                mergedRows.push(...rows);
              }
            });
            return baseRows.concat(mergedRows);
          }
          const selection = resolveBucketTarget(options);
          if (!Number.isFinite(selection.bucket)) {
            return baseRows;
          }
          const key = String(Math.round(selection.bucket));
          const bucketRows = bucketMap.get(key);
          return baseRows.concat(Array.isArray(bucketRows) ? bucketRows : []);
        }

        function uniqueBucketOptions(rows) {
          const values = new Set();
          rows.forEach((row) => {
            const value = toFiniteNumberOrNull(row.bucket_minutes);
            if (value !== null) {
              values.add(value);
            }
          });
          return Array.from(values).sort((left, right) => left - right);
        }

        function filterRowsByBucket(rows, chartId) {
          const options = getChartBucketOptions(chartId, rows);
          if (!options.length) {
            return { rows: rows, bucket: null, options: options, note: "" };
          }

          const selection = resolveBucketTarget(options);
          const target = selection.bucket;
          return {
            rows: rows.filter((row) => toFiniteNumberOrNull(row.bucket_minutes) === target),
            bucket: target,
            options: options,
            note: selection.note,
          };
        }

        function hasActiveZoomRange() {
          return (
            Number.isFinite(state.zoom.minTime) &&
            Number.isFinite(state.zoom.maxTime) &&
            state.zoom.maxTime > state.zoom.minTime
          );
        }

        function parseShortOffsetMinutes(rawValue) {
          const value = String(rawValue || "")
            .replace(/\u2212/g, "-")
            .trim()
            .toUpperCase();
          if (!value || value === "GMT" || value === "UTC") {
            return 0;
          }
          const match = value.match(/^(?:GMT|UTC)\s*([+-])(\d{1,2})(?::?(\d{2}))?$/);
          if (!match) {
            return null;
          }
          const sign = match[1] === "-" ? -1 : 1;
          const hours = Number(match[2]);
          const minutes = Number(match[3] || "0");
          if (!Number.isFinite(hours) || !Number.isFinite(minutes)) {
            return null;
          }
          return sign * (hours * 60 + minutes);
        }

        function timezoneOffsetMinutesAt(epochMillis, timezoneName) {
          if (!Number.isFinite(epochMillis) || !timezoneName) {
            return null;
          }
          try {
            const parts = new Intl.DateTimeFormat("en-US", {
              timeZone: timezoneName,
              timeZoneName: "shortOffset",
              hour: "2-digit",
              minute: "2-digit",
              hour12: false,
            }).formatToParts(new Date(epochMillis));
            const zonePart = parts.find((part) => part.type === "timeZoneName");
            if (!zonePart || typeof zonePart.value !== "string") {
              return null;
            }
            return parseShortOffsetMinutes(zonePart.value);
          } catch (_error) {
            return null;
          }
        }

        function epochFromDateTimeInReportTimezone(dateValue, hourValue, minuteValue) {
          const dateText = String(dateValue || "").trim();
          const dateMatch = dateText.match(/^(\d{4})-(\d{2})-(\d{2})$/);
          const hour = Math.max(0, Math.min(23, Math.round(toNumber(hourValue))));
          const minute = Math.max(0, Math.min(59, Math.round(toNumber(minuteValue))));
          if (!dateMatch) {
            return toEpochMillis(dateText);
          }
          const cacheKey =
            dateMatch[1] +
            "-" +
            dateMatch[2] +
            "-" +
            dateMatch[3] +
            "|" +
            String(hour) +
            "|" +
            String(minute) +
            "|" +
            reportTimezone;
          if (zonedDateTimeEpochCache.has(cacheKey)) {
            return zonedDateTimeEpochCache.get(cacheKey);
          }

          const year = Number(dateMatch[1]);
          const month = Number(dateMatch[2]);
          const day = Number(dateMatch[3]);
          if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
            return null;
          }

          const utcGuess = Date.UTC(year, month - 1, day, hour, minute, 0, 0);
          const firstOffset = timezoneOffsetMinutesAt(utcGuess, reportTimezone);
          let resolved =
            firstOffset === null ? null : utcGuess - firstOffset * 60 * 1000;
          if (resolved !== null) {
            const refinedOffset = timezoneOffsetMinutesAt(resolved, reportTimezone);
            if (refinedOffset !== null && refinedOffset !== firstOffset) {
              resolved = utcGuess - refinedOffset * 60 * 1000;
            }
          }

          zonedDateTimeEpochCache.set(cacheKey, resolved);
          return resolved;
        }

        function inferRowAbsoluteTimeRange(mount, row) {
          if (!row || typeof row !== "object") {
            return null;
          }

          const pointFields = [
            "bucket_start",
            "minute_bucket",
            "start_minute",
            "change_minute",
            "peak_bucket_start",
          ];
          for (const field of pointFields) {
            if (!Object.prototype.hasOwnProperty.call(row, field)) {
              continue;
            }
            const timestamp = toEpochMillis(row[field]);
            if (timestamp !== null) {
              return { start: timestamp, end: timestamp };
            }
          }

          const firstSeen = toEpochMillis(row.first_seen);
          const lastSeen = toEpochMillis(row.last_seen);
          if (firstSeen !== null || lastSeen !== null) {
            const start = firstSeen !== null ? firstSeen : lastSeen;
            const end = lastSeen !== null ? lastSeen : firstSeen;
            return {
              start: Math.min(start, end),
              end: Math.max(start, end),
            };
          }

          const dateText = String(row.date || "").trim();
          if (dateText) {
            const hour = toFiniteNumberOrNull(row.hour);
            if (hour !== null) {
              const start = epochFromDateTimeInReportTimezone(dateText, hour, 0);
              if (start !== null) {
                return { start: start, end: start + 60 * 60 * 1000 - 1 };
              }
            }

            const slotStartMinute = toFiniteNumberOrNull(row.slot_start_minute);
            if (slotStartMinute !== null) {
              const roundedMinute = Math.max(
                0,
                Math.min(24 * 60 - 1, Math.round(slotStartMinute))
              );
              const slotHour = Math.floor(roundedMinute / 60);
              const minuteOfHour = roundedMinute % 60;
              const start = epochFromDateTimeInReportTimezone(
                dateText,
                slotHour,
                minuteOfHour
              );
              if (start !== null) {
                const bucketMinutes = toFiniteNumberOrNull(row.bucket_minutes);
                const fallbackMinutes = Number.isFinite(mount && mount.activeBucket)
                  ? mount.activeBucket
                  : 60;
                const spanMinutes = Math.max(
                  1,
                  Math.round(bucketMinutes !== null ? bucketMinutes : fallbackMinutes)
                );
                return {
                  start: start,
                  end: start + spanMinutes * 60 * 1000 - 1,
                };
              }
            }

            const dayStart = epochFromDateTimeInReportTimezone(dateText, 0, 0);
            if (dayStart !== null) {
              return {
                start: dayStart,
                end: dayStart + 24 * 60 * 60 * 1000 - 1,
              };
            }
          }

          return null;
        }

        function chartUsesLinkedZoomRowFilter(mount, rows) {
          if (!mount || state.absoluteTimeSet.has(mount.chartId)) {
            return false;
          }
          if (linkedZoomFilterChartIds.has(mount.chartId)) {
            return true;
          }
          return Array.isArray(rows)
            ? rows.some((row) => inferRowAbsoluteTimeRange(mount, row) !== null)
            : false;
        }

        function filterRowsByLinkedZoom(mount, rows) {
          if (!Array.isArray(rows) || !rows.length || !hasActiveZoomRange()) {
            return { rows: rows, note: "" };
          }
          if (!chartUsesLinkedZoomRowFilter(mount, rows)) {
            return { rows: rows, note: "" };
          }

          const start = state.zoom.minTime;
          const end = state.zoom.maxTime;
          const filtered = [];
          let scopedRows = 0;

          rows.forEach((row) => {
            const rowRange = inferRowAbsoluteTimeRange(mount, row);
            if (!rowRange) {
              return;
            }
            scopedRows += 1;
            if (overlapsWindow(rowRange.start, rowRange.end, start, end)) {
              filtered.push(row);
            }
          });

          if (!scopedRows) {
            return { rows: rows, note: "" };
          }

          const zoomPrefix =
            "Linked zoom filter: " +
            formatEpochMillis(start) +
            " to " +
            formatEpochMillis(end) +
            ".";
          if (!filtered.length) {
            return { rows: [], note: zoomPrefix + " No rows remain in this range." };
          }

          return {
            rows: filtered,
            note:
              zoomPrefix +
              " Showing " +
              filtered.length.toLocaleString() +
              "/" +
              scopedRows.toLocaleString() +
              " rows.",
          };
        }

        function appendCursorMarkLine(baseLines) {
          const theme = currentChartTheme();
          const lines = Array.isArray(baseLines) ? baseLines.slice() : [];
          if (Number.isFinite(state.cursorX)) {
            lines.push({
              xAxis: state.cursorX,
              lineStyle: { color: theme.cursor, width: 1.2, opacity: 0.95, type: "solid" },
              label: { show: false },
            });
          }
          if (!lines.length) {
            return { data: [] };
          }
          return {
            silent: true,
            symbol: ["none", "none"],
            data: lines,
          };
        }

        function updateCursorAcrossTimeCharts() {
          chartMounts.forEach((mount) => {
            if (!mount.isTimeSeries || !mount.chart || !mount.seriesId) {
              return;
            }
            const markLine = appendCursorMarkLine(mount.baseMarkLines || []);
            try {
              mount.chart.setOption({
                series: [{ id: mount.seriesId, markLine: markLine }],
              });
            } catch (_error) {}
          });

          const cursorNote = document.getElementById("cursor-sync-note");
          if (cursorNote) {
            cursorNote.textContent = "";
          }
        }

        function clearChartInteractionState(mount) {
          if (!mount || !mount.chart) {
            return;
          }
          try {
            mount.chart.dispatchAction({ type: "hideTip" });
          } catch (_error) {}
          try {
            mount.chart.dispatchAction({ type: "updateAxisPointer", currTrigger: "leave" });
          } catch (_error) {}
        }

        function clearAllChartInteractionState() {
          chartMounts.forEach((mount) => clearChartInteractionState(mount));
        }

        function extractCursorFromEvent(chart, params) {
          if (!params || !chart) {
            return null;
          }
          if (Object.prototype.hasOwnProperty.call(params, "value")) {
            const value = params.value;
            if (Array.isArray(value) && value.length) {
              const parsed = toEpochMillis(value[0]);
              if (parsed !== null) {
                return parsed;
              }
            }
            const parsedDirect = toEpochMillis(value);
            if (parsedDirect !== null) {
              return parsedDirect;
            }
          }

          if (!params.event) {
            return null;
          }
          const evt = params.event.event || params.event;
          if (!evt || !Number.isFinite(evt.offsetX) || !Number.isFinite(evt.offsetY)) {
            return null;
          }
          try {
            if (!chart.containPixel({ gridIndex: 0 }, [evt.offsetX, evt.offsetY])) {
              return null;
            }
            const converted = chart.convertFromPixel({ gridIndex: 0 }, [evt.offsetX, evt.offsetY]);
            const raw = Array.isArray(converted) ? converted[0] : converted;
            return toEpochMillis(raw);
          } catch (_error) {
            return null;
          }
        }

        function attachCursorHandlers(mount) {
          if (!mount.chart || !mount.isTimeSeries) {
            return;
          }
          mount.chart.on("click", (params) => {
            const xValue = extractCursorFromEvent(mount.chart, params);
            if (xValue !== null) {
              state.cursorX = xValue;
              updateCursorAcrossTimeCharts();
            }
          });
        }

        function extractFunnelCursorFromEvent(params) {
          if (!params) {
            return null;
          }
          const pointData = params && params.data && typeof params.data === "object" ? params.data : null;
          if (pointData && pointData.meta && typeof pointData.meta === "object") {
            const fromMeta = toEpochMillis(pointData.meta.bucketStart);
            if (fromMeta !== null) {
              return fromMeta;
            }
          }
          const valueCandidate = pointData && Object.prototype.hasOwnProperty.call(pointData, "value")
            ? pointData.value
            : params.value;
          if (Array.isArray(valueCandidate) && valueCandidate.length > 2) {
            const fromValue = toEpochMillis(valueCandidate[2]);
            if (fromValue !== null) {
              return fromValue;
            }
          }
          return null;
        }

        function attachFunnelCursorHandler(mount) {
          if (
            !mount ||
            !mount.chart ||
            mount.chartId !== "off_hours_funnel_plot" ||
            toBool(mount.hasFunnelClickHandler)
          ) {
            return;
          }
          mount.chart.on("click", (params) => {
            const timestamp = extractFunnelCursorFromEvent(params);
            if (timestamp === null) {
              return;
            }
            state.cursorX = timestamp;
            updateCursorAcrossTimeCharts();
          });
          mount.hasFunnelClickHandler = true;
        }

        function extentFromRows(rows, timeField) {
          const values = rows
            .map((row) => toEpochMillis(row[timeField]))
            .filter((value) => Number.isFinite(value));
          if (!values.length) {
            return null;
          }
          return {
            min: Math.min.apply(null, values),
            max: Math.max.apply(null, values),
          };
        }

        function firstQueryParam(searchParams, names) {
          for (const name of names) {
            const value = searchParams.get(name);
            if (typeof value === "string" && value.trim()) {
              return value.trim();
            }
          }
          return null;
        }

        function parseZoomEpoch(value) {
          if (value === null || value === undefined) {
            return null;
          }
          const text = String(value).trim();
          if (!text) {
            return null;
          }

          const numeric = Number(text);
          if (Number.isFinite(numeric)) {
            const absolute = Math.abs(numeric);
            if (absolute >= 1e12) {
              return numeric;
            }
            if (absolute >= 1e9) {
              return numeric * 1000;
            }
            return null;
          }

          const parsed = Date.parse(text);
          return Number.isFinite(parsed) ? parsed : null;
        }

        function parseBucketFromQueryParams(availableOptions) {
          if (typeof window.URLSearchParams === "undefined") {
            return null;
          }
          const params = new window.URLSearchParams(window.location.search || "");
          const raw = firstQueryParam(params, [
            "bucket",
            "bucket_minutes",
            "linked_bucket_minutes",
          ]);
          const parsed = toFiniteNumberOrNull(raw);
          if (parsed === null) {
            return null;
          }
          const rounded = Math.max(1, Math.round(parsed));
          if (!Array.isArray(availableOptions) || !availableOptions.length) {
            return rounded;
          }
          if (availableOptions.includes(rounded)) {
            return rounded;
          }
          return null;
        }

        function parseLinkedZoomFromQueryParams() {
          if (typeof window.URLSearchParams === "undefined") {
            return null;
          }
          const params = new window.URLSearchParams(window.location.search || "");
          const startRaw = firstQueryParam(params, [
            "zoom_start",
            "linked_zoom_start",
            "zoom_min",
            "zoom_min_time",
            "zoomStart",
          ]);
          const endRaw = firstQueryParam(params, [
            "zoom_end",
            "linked_zoom_end",
            "zoom_max",
            "zoom_max_time",
            "zoomEnd",
          ]);
          if (!startRaw || !endRaw) {
            return null;
          }

          const min = parseZoomEpoch(startRaw);
          const max = parseZoomEpoch(endRaw);
          if (!Number.isFinite(min) || !Number.isFinite(max) || max <= min) {
            return null;
          }
          return { min: min, max: max };
        }

        function collectAbsoluteTimeExtent() {
          let min = null;
          let max = null;
          chartMounts.forEach((mount) => {
            if (!mount || !mount.isAbsoluteTime || !mount.timeExtent) {
              return;
            }
            const extent = mount.timeExtent;
            if (!Number.isFinite(extent.min) || !Number.isFinite(extent.max)) {
              return;
            }
            min = min === null ? extent.min : Math.min(min, extent.min);
            max = max === null ? extent.max : Math.max(max, extent.max);
          });
          if (!Number.isFinite(min) || !Number.isFinite(max) || max <= min) {
            return null;
          }
          return { min: min, max: max };
        }

        function initializeLinkedZoomOnLoad() {
          if (!state.absoluteTimeSet.size) {
            return;
          }

          const fullExtent = collectAbsoluteTimeExtent();
          const queryRange = parseLinkedZoomFromQueryParams();
          if (!queryRange) {
            propagateZoom(null, null, null, true);
            return;
          }

          let min = queryRange.min;
          let max = queryRange.max;
          if (fullExtent) {
            min = Math.max(min, fullExtent.min);
            max = Math.min(max, fullExtent.max);
          }
          if (!Number.isFinite(min) || !Number.isFinite(max) || max <= min) {
            propagateZoom(null, null, null, true);
            return;
          }
          propagateZoom(min, max, null, false);
        }

        function extractZoomRange(chart, extent) {
          const option = chart.getOption ? chart.getOption() : {};
          const dataZoom = Array.isArray(option.dataZoom) ? option.dataZoom : [];

          for (const item of dataZoom) {
            const startValue = toFiniteNumberOrNull(item.startValue);
            const endValue = toFiniteNumberOrNull(item.endValue);
            if (startValue !== null && endValue !== null && endValue > startValue) {
              if (
                extent &&
                Number.isFinite(extent.min) &&
                Number.isFinite(extent.max) &&
                Math.abs(startValue - extent.min) < 1 &&
                Math.abs(endValue - extent.max) < 1
              ) {
                return { min: extent.min, max: extent.max, reset: true };
              }
              return { min: startValue, max: endValue, reset: false };
            }
          }

          if (!extent) {
            return null;
          }
          for (const item of dataZoom) {
            const start = toFiniteNumberOrNull(item.start);
            const end = toFiniteNumberOrNull(item.end);
            if (start === null || end === null) {
              continue;
            }
            if (start <= 0 && end >= 100) {
              return { min: extent.min, max: extent.max, reset: true };
            }
            const span = extent.max - extent.min;
            if (!(span > 0)) {
              continue;
            }
            const min = extent.min + (Math.max(0, Math.min(100, start)) / 100) * span;
            const max = extent.min + (Math.max(0, Math.min(100, end)) / 100) * span;
            if (max > min) {
              return { min: min, max: max, reset: false };
            }
          }
          return null;
        }

        function applyZoomToChart(mount) {
          if (!mount || !mount.chart || !mount.isAbsoluteTime) {
            return;
          }
          if (
            !Number.isFinite(state.zoom.minTime) ||
            !Number.isFinite(state.zoom.maxTime) ||
            state.zoom.maxTime <= state.zoom.minTime
          ) {
            mount.chart.dispatchAction({ type: "dataZoom", xAxisIndex: 0, start: 0, end: 100 });
            return;
          }
          mount.chart.dispatchAction({
            type: "dataZoom",
            xAxisIndex: 0,
            startValue: state.zoom.minTime,
            endValue: state.zoom.maxTime,
          });
        }

        function updateZoomRangeLabel() {
          const panel = document.getElementById("zoom-sync-panel");
          const label = document.getElementById("zoom-range-label");
          const statusChip = document.getElementById("zoom-status-chip");
          const resetButton = document.getElementById("zoom-reset-button");
          const banner = document.getElementById("zoom-active-banner");
          const bannerText = document.getElementById("zoom-active-banner-text");
          const bannerMeta = document.getElementById("zoom-active-banner-meta");
          const bannerChip = document.getElementById("zoom-active-banner-chip");
          const bannerResetButton = document.getElementById("zoom-banner-reset-button");
          const bannerCopyButton = document.getElementById("zoom-banner-copy-button");
          if (!panel || !label || !resetButton) {
            return;
          }
          if (!state.absoluteTimeSet.size) {
            panel.classList.add("hidden");
            panel.classList.remove("zoom-state-active");
            if (statusChip) {
              statusChip.classList.remove("is-active");
              statusChip.textContent = "Full timeline";
            }
            if (banner) {
              banner.classList.add("hidden");
            }
            return;
          }
          panel.classList.remove("hidden");

          const hasZoom = hasActiveZoomRange();
          document.body.classList.toggle("zoom-range-active", hasZoom);
          panel.classList.toggle("zoom-state-active", hasZoom);
          resetButton.disabled = !hasZoom;
          if (statusChip) {
            statusChip.classList.toggle("is-active", hasZoom);
            if (!hasZoom) {
              statusChip.textContent = "Full timeline";
            }
          }
          if (bannerResetButton) {
            bannerResetButton.disabled = !hasZoom;
          }
          if (bannerCopyButton) {
            bannerCopyButton.disabled = !hasZoom;
            if (!hasZoom) {
              bannerCopyButton.textContent = "Copy link";
            }
          }
          if (!hasZoom) {
            label.textContent = "Range: full timeline.";
            if (banner) {
              banner.classList.add("hidden");
            }
            if (bannerMeta) {
              bannerMeta.textContent = "";
            }
            if (bannerChip) {
              bannerChip.textContent = "";
            }
            return;
          }

          const rangeText =
            formatEpochMillis(state.zoom.minTime) +
            " to " +
            formatEpochMillis(state.zoom.maxTime);
          label.textContent =
            "Range: " +
            rangeText +
            ".";
          const selectedDuration = Math.max(0, state.zoom.maxTime - state.zoom.minTime);
          const selectedDurationText = formatDurationCompact(selectedDuration);
          const fullExtent = collectAbsoluteTimeExtent();
          const fullDuration =
            fullExtent && Number.isFinite(fullExtent.min) && Number.isFinite(fullExtent.max)
              ? Math.max(0, fullExtent.max - fullExtent.min)
              : null;
          const coverageRatio =
            fullDuration && fullDuration > 0 ? selectedDuration / fullDuration : null;
          const coverageText = formatCoveragePercent(coverageRatio);
          if (statusChip) {
            statusChip.textContent = coverageText
              ? "Filtered: " + coverageText
              : "Filtered";
          }
          if (banner && bannerText) {
            banner.classList.remove("hidden");
            bannerText.textContent = rangeText;
            if (bannerMeta) {
              let metaText =
                "All time-based charts, heatmaps, funnel points, and bucket tables are filtered to this range.";
              if (selectedDurationText !== "-") {
                metaText += " Window span: " + selectedDurationText + ".";
              }
              if (coverageText) {
                metaText += " Coverage: " + coverageText + " of full timeline.";
              }
              bannerMeta.textContent = metaText;
            }
            if (bannerChip) {
              bannerChip.textContent = coverageText
                ? coverageText + " of timeline"
                : selectedDurationText;
            }
          }
        }

        function propagateZoom(minTime, maxTime, sourceChartId, isReset) {
          if (state.zoom.syncing) {
            return;
          }
          const hasRange =
            Number.isFinite(minTime) && Number.isFinite(maxTime) && maxTime > minTime;
          if (!isReset && !hasRange) {
            return;
          }
          state.zoom.syncing = true;
          try {
            if (isReset) {
              state.zoom.minTime = null;
              state.zoom.maxTime = null;
            } else {
              state.zoom.minTime = minTime;
              state.zoom.maxTime = maxTime;
            }
            chartMounts.forEach((mount, chartId) => {
              if (!mount.isAbsoluteTime || chartId === sourceChartId) {
                return;
              }
              applyZoomToChart(mount);
            });
            rerenderLinkedZoomAwareCharts(sourceChartId);
          } finally {
            state.zoom.syncing = false;
            updateZoomRangeLabel();
            syncControlOverridesToUrl();
          }
        }

        function scheduleZoomSync(minTime, maxTime, sourceChartId, isReset) {
          state.zoom.pending = {
            minTime: minTime,
            maxTime: maxTime,
            sourceChartId: sourceChartId,
            isReset: isReset,
          };
          if (state.zoom.raf !== null) {
            return;
          }
          state.zoom.raf = window.requestAnimationFrame(() => {
            state.zoom.raf = null;
            const pending = state.zoom.pending;
            state.zoom.pending = null;
            if (!pending) {
              return;
            }
            propagateZoom(pending.minTime, pending.maxTime, pending.sourceChartId, pending.isReset);
          });
        }

        function attachZoomHandlers(mount) {
          if (!mount.chart || !mount.isAbsoluteTime) {
            return;
          }
          mount.chart.on("dataZoom", () => {
            if (state.zoom.syncing) {
              return;
            }
            const range = extractZoomRange(mount.chart, mount.timeExtent);
            if (!range) {
              return;
            }
            scheduleZoomSync(range.min, range.max, mount.chartId, range.reset);
          });
        }

        function chartTitleFor(chartId) {
          return String(chartId || "").replace(/_/g, " ");
        }

        function renderTimeBarLine(mount, rows, config) {
          const theme = currentChartTheme();
          const timeField = config.timeField;
          const barField = config.barField;
          const lineField = config.lineField;
          const lineLow = config.lineLow;
          const lineHigh = config.lineHigh;
          const extraLines = Array.isArray(config.extraLines) ? config.extraLines : [];
          const lowPowerField = config.lowPowerField;
          const flaggedField = config.flaggedField;
          const comparatorMetric =
            typeof config.comparatorMetric === "string" ? config.comparatorMetric.trim() : "";
          const inferentialWindowField =
            typeof config.inferentialWindowField === "string"
              ? config.inferentialWindowField.trim()
              : "";
          const sparseWhenLowSupport = toBool(config.sparseWhenLowSupport);
          const sparseMinTestedPoints = Math.max(
            3,
            Math.round(toNumber(config.sparseMinTestedPoints || 8))
          );
          const sparseMinTestedShare = Math.max(
            0,
            Math.min(1, toNumber(config.sparseMinTestedShare || 0.35))
          );
          const runOverlayField =
            typeof config.runOverlayField === "string" ? config.runOverlayField.trim() : "";
          const denseOffHoursMarkers =
            mount.chartId === "off_hours_control_timeline" ||
            mount.chartId === "off_hours_primary_residual_timeline";

          const sorted = rows
            .map((row) => Object.assign({}, row, { __time: toEpochMillis(row[timeField]) }))
            .filter((row) => row.__time !== null)
            .sort((left, right) => left.__time - right.__time);

          if (!sorted.length) {
            return false;
          }

          mount.timeExtent = extentFromRows(sorted, "__time");
          mount.crossHearingComparatorNote = null;
          mount.customChartNote = null;
          const mainSeriesId = "main-" + mount.chartId;

          const inferentialRows =
            lineField && inferentialWindowField
              ? sorted.filter(
                  (row) =>
                    toBool(row[inferentialWindowField]) &&
                    toFiniteNumberOrNull(row[lineField]) !== null
                )
              : [];
          const testedInferentialRows =
            lineField && inferentialWindowField && lowPowerField
              ? inferentialRows.filter((row) => !toBool(row[lowPowerField]))
              : inferentialRows.slice();
          const inferentialCount = inferentialRows.length;
          const testedInferentialCount = testedInferentialRows.length;
          const testedInferentialShare =
            inferentialCount > 0 ? testedInferentialCount / inferentialCount : null;
          const sparseMode =
            sparseWhenLowSupport &&
            inferentialCount > 0 &&
            (testedInferentialCount < sparseMinTestedPoints ||
              (testedInferentialShare !== null && testedInferentialShare < sparseMinTestedShare));
          const noInferentialSupport =
            sparseWhenLowSupport && inferentialCount > 0 && testedInferentialCount === 0;

          const includeInPrimarySeries = (row) => {
            if (!lineField || !sparseMode) {
              return true;
            }
            if (inferentialWindowField && !toBool(row[inferentialWindowField])) {
              return false;
            }
            if (lowPowerField && toBool(row[lowPowerField])) {
              return false;
            }
            return true;
          };

          if (lineField && sparseWhenLowSupport) {
            if (inferentialCount === 0) {
              mount.customChartNote =
                "No alert-eligible windows were available for inferential off-hours testing in this bucket.";
            } else if (noInferentialSupport) {
              mount.customChartNote =
                "Descriptive-only: 0/" +
                inferentialCount.toLocaleString() +
                " alert-eligible windows were inferentially tested after low-power filtering.";
            } else if (sparseMode) {
              mount.customChartNote =
                "Sparse inferential support: showing tested windows as points with Wilson bounds (" +
                testedInferentialCount.toLocaleString() +
                "/" +
                inferentialCount.toLocaleString() +
                " tested).";
            }
          }

          const barData = barField
            ? sorted.map((row) => [row.__time, toFiniteNumberOrNull(row[barField])])
            : [];
          const lineData = lineField
            ? sorted.map((row) => [
                row.__time,
                includeInPrimarySeries(row) ? toFiniteNumberOrNull(row[lineField]) : null,
              ])
            : [];
          const lowData = lineLow
            ? sorted.map((row) => [
                row.__time,
                includeInPrimarySeries(row) ? toFiniteNumberOrNull(row[lineLow]) : null,
              ])
            : [];
          const highData = lineHigh
            ? sorted.map((row) => [
                row.__time,
                includeInPrimarySeries(row) ? toFiniteNumberOrNull(row[lineHigh]) : null,
              ])
            : [];
          const sparsePointData =
            sparseMode && lineField
              ? sorted
                  .filter(
                    (row) =>
                      includeInPrimarySeries(row) &&
                      toFiniteNumberOrNull(row[lineField]) !== null
                  )
                  .map((row) => [row.__time, toFiniteNumberOrNull(row[lineField])])
              : [];
          const sparseErrorbarData =
            sparseMode && lineLow && lineHigh
              ? sorted
                  .filter(
                    (row) =>
                      includeInPrimarySeries(row) &&
                      toFiniteNumberOrNull(row[lineLow]) !== null &&
                      toFiniteNumberOrNull(row[lineHigh]) !== null
                  )
                  .map((row) => [
                    row.__time,
                    toFiniteNumberOrNull(row[lineLow]),
                    toFiniteNumberOrNull(row[lineHigh]),
                  ])
              : [];

          const lowPowerData = lowPowerField
            ? sorted
                .filter((row) => toBool(row[lowPowerField]) && toFiniteNumberOrNull(row[lineField]) !== null)
                .map((row) => [row.__time, toFiniteNumberOrNull(row[lineField])])
            : [];
          const robustLowerData = [];
          const robustUpperData = [];
          const genericFlagData = [];
          const spcOnlyData = [];
          const fdrOnlyData = [];
          const classifyDirection = (row, value) => {
            if (toBool(row.is_material_primary_lower_shift) || toBool(row.is_significant_primary_lower)) {
              return "lower";
            }
            if (toBool(row.is_material_primary_upper_shift) || toBool(row.is_significant_primary_upper)) {
              return "upper";
            }
            if (value !== null && value < 0) {
              return "lower";
            }
            return "upper";
          };
          if (lineField) {
            sorted.forEach((row) => {
              const value = toFiniteNumberOrNull(row[lineField]);
              if (value === null) {
                return;
              }
              const point = [row.__time, value];
              const isLowPowerRow = lowPowerField ? toBool(row[lowPowerField]) : false;
              const isSpcOnly =
                !isLowPowerRow &&
                toBool(row.is_primary_spc_998_two_sided) &&
                !toBool(row.is_primary_fdr_two_sided);
              const isFdrOnly =
                !isLowPowerRow &&
                toBool(row.is_primary_fdr_two_sided) &&
                !toBool(row.is_primary_spc_998_two_sided);
              if (isSpcOnly) {
                spcOnlyData.push(point);
              }
              if (isFdrOnly) {
                fdrOnlyData.push(point);
              }
              if (!flaggedField || !toBool(row[flaggedField])) {
                return;
              }
              if (isLowPowerRow) {
                genericFlagData.push(point);
                return;
              }
              const direction = classifyDirection(row, value);
              if (direction === "lower") {
                robustLowerData.push(point);
              } else if (direction === "upper") {
                robustUpperData.push(point);
              } else {
                genericFlagData.push(point);
              }
            });
          }
          const bucketByTime = new Map();
          sorted.forEach((row) => {
            if (bucketByTime.has(row.__time)) {
              return;
            }
            const bucketMinutes = toFiniteNumberOrNull(row.bucket_minutes);
            if (bucketMinutes !== null) {
              bucketByTime.set(row.__time, bucketMinutes);
            }
          });

          const option = {
            animation: false,
            color: theme.seriesPalette,
            tooltip: {
              trigger: "axis",
              axisPointer: { type: "cross" },
              formatter: (params) => {
                const entries = Array.isArray(params) ? params : [params];
                if (!entries.length) {
                  return "";
                }
                const first = entries[0] || {};
                const rawValue = first.value;
                const axisRaw = Array.isArray(rawValue) ? rawValue[0] : first.axisValue;
                const timestamp = toEpochMillis(axisRaw);
                const lines = [];
                if (timestamp !== null) {
                  lines.push(
                    "<strong>Time (" +
                      reportTimezoneLabel +
                      "):</strong> " +
                      formatEpochMillis(timestamp)
                  );
                  const bucketFromTime = bucketByTime.has(timestamp)
                    ? bucketByTime.get(timestamp)
                    : Number.isFinite(mount.activeBucket)
                      ? mount.activeBucket
                      : null;
                  const bucketLabel = bucketLabelFromValue(bucketFromTime);
                  if (bucketLabel) {
                    lines.push("<strong>Bucket:</strong> " + bucketLabel);
                  }
                }
                entries.forEach((entry) => {
                  const entryValue = Array.isArray(entry.value) ? entry.value[1] : entry.value;
                  lines.push(
                    (entry.marker || "") +
                      "<strong>" +
                      String(entry.seriesName || "value") +
                      ":</strong> " +
                      formatTooltipValue(entryValue)
                  );
                });
                return lines.join("<br/>");
              },
            },
            legend: { bottom: 0 },
            grid: { left: 56, right: 56, top: 18, bottom: 88 },
            xAxis: { type: "time", name: "Time (" + reportTimezoneLabel + ")" },
            yAxis: [
              barField ? { type: "value", name: config.barAxisName || "Volume" } : { type: "value", name: config.lineAxisName || "Value" },
              {
                type: "value",
                name: config.lineAxisName || "Value",
                min: config.lineMin,
                max: config.lineMax,
              },
            ],
            dataZoom: [
              {
                type: "inside",
                xAxisIndex: [0],
                startValue: Number.isFinite(state.zoom.minTime) ? state.zoom.minTime : undefined,
                endValue: Number.isFinite(state.zoom.maxTime) ? state.zoom.maxTime : undefined,
              },
              {
                type: "slider",
                xAxisIndex: [0],
                bottom: 30,
                startValue: Number.isFinite(state.zoom.minTime) ? state.zoom.minTime : undefined,
                endValue: Number.isFinite(state.zoom.maxTime) ? state.zoom.maxTime : undefined,
              },
            ],
            series: [],
          };

            if (barField) {
            option.series.push({
              id: mainSeriesId,
              name: config.barSeriesName || "Volume",
              type: "bar",
              yAxisIndex: 0,
              data: barData,
              barMaxWidth: 11,
              itemStyle: { color: config.barColor || theme.volumeBar, opacity: theme.volumeBarOpacity },
              markLine: appendCursorMarkLine(mount.baseMarkLines || []),
            });
          } else {
            option.series.push({
              id: mainSeriesId,
              name: config.lineSeriesName || "Value",
              type: "line",
              yAxisIndex: 0,
              data: lineData,
              showSymbol: false,
              lineStyle: { color: config.lineColor || theme.primaryLine, width: 1.6 },
              markLine: appendCursorMarkLine(mount.baseMarkLines || []),
            });
          }

          if (lineField) {
            if (sparseMode) {
              option.series.push({
                name: (config.lineSeriesName || "Value") + " (tested windows)",
                  type: "scatter",
                  yAxisIndex: barField ? 1 : 0,
                  data: sparsePointData,
                  symbolSize: 7,
                  itemStyle: { color: config.lineColor || theme.primaryLine, opacity: 0.9 },
                });
              if (sparseErrorbarData.length) {
                option.series.push({
                  name: "Wilson low (tested)",
                  type: "line",
                  yAxisIndex: barField ? 1 : 0,
                  data: sparseErrorbarData.map((row) => [row[0], row[1]]),
                  showSymbol: false,
                  lineStyle: {
                    color: theme.intervalBand,
                    width: denseOffHoursMarkers ? 0.9 : 1,
                    opacity: denseOffHoursMarkers ? 0.52 : 0.7,
                  },
                });
                option.series.push({
                  name: "Wilson high (tested)",
                  type: "line",
                  yAxisIndex: barField ? 1 : 0,
                  data: sparseErrorbarData.map((row) => [row[0], row[2]]),
                  showSymbol: false,
                  lineStyle: {
                    color: theme.intervalBand,
                    width: denseOffHoursMarkers ? 0.9 : 1,
                    opacity: denseOffHoursMarkers ? 0.52 : 0.7,
                  },
                });
              }
            } else {
              option.series.push({
                name: config.lineSeriesName || "Value",
                type: "line",
                yAxisIndex: barField ? 1 : 0,
                data: lineData,
                showSymbol: false,
                lineStyle: { color: config.lineColor || theme.primaryLine, width: 1.6 },
              });
            }
          }
          if (lineLow && !sparseMode) {
            option.series.push({
              name: "Wilson low",
              type: "line",
              yAxisIndex: barField ? 1 : 0,
              data: lowData,
              showSymbol: false,
              lineStyle: {
                color: theme.intervalBand,
                width: denseOffHoursMarkers ? 0.9 : 1,
                opacity: denseOffHoursMarkers ? 0.52 : 0.7,
              },
            });
          }
          if (lineHigh && !sparseMode) {
            option.series.push({
              name: "Wilson high",
              type: "line",
              yAxisIndex: barField ? 1 : 0,
              data: highData,
              showSymbol: false,
              lineStyle: {
                color: theme.intervalBand,
                width: denseOffHoursMarkers ? 0.9 : 1,
                opacity: denseOffHoursMarkers ? 0.52 : 0.7,
              },
            });
          }

          extraLines.forEach((field, index) => {
            const extraLineStyle = styleForExtraLine(field, index, mount.chartId);
            option.series.push({
              name: field.replace(/_/g, " "),
              type: "line",
              yAxisIndex: barField ? 1 : 0,
              data: sorted.map((row) => [row.__time, toFiniteNumberOrNull(row[field])]),
              showSymbol: false,
              lineStyle: {
                color: colorForExtraLine(field, index),
                width: extraLineStyle.width,
                type: extraLineStyle.type,
                opacity: extraLineStyle.opacity,
              },
            });
          });

          if (runOverlayField && lineField) {
            const runIntervals = [];
            let runStart = null;
            let prevTime = null;
            let prevBucketMinutes = null;

            const closeRun = () => {
              if (runStart === null || prevTime === null) {
                return;
              }
              const endPaddingMs =
                Math.max(1, toNumber(prevBucketMinutes || mount.activeBucket || 1)) * 60 * 1000;
              runIntervals.push({
                start: runStart,
                end: prevTime + endPaddingMs,
              });
              runStart = null;
              prevTime = null;
              prevBucketMinutes = null;
            };

            sorted.forEach((row) => {
              const flagged = toBool(row[runOverlayField]);
              const currentTime = row.__time;
              const currentBucketMinutes = toFiniteNumberOrNull(row.bucket_minutes);
              const expectedGapMs =
                Math.max(1, toNumber(currentBucketMinutes || mount.activeBucket || 1)) * 60 * 1000 * 1.5;

              if (!flagged) {
                closeRun();
                return;
              }

              const isContiguous =
                prevTime !== null && Number.isFinite(currentTime - prevTime)
                  ? currentTime - prevTime <= expectedGapMs
                  : false;

              if (runStart === null || !isContiguous) {
                closeRun();
                runStart = currentTime;
              }
              prevTime = currentTime;
              prevBucketMinutes = currentBucketMinutes;
            });
            closeRun();

            if (runIntervals.length) {
              option.series.push({
                name: "Robust alert run span",
                type: "line",
                yAxisIndex: barField ? 1 : 0,
                data: sorted.map((row) => [row.__time, null]),
                showSymbol: false,
                tooltip: { show: false },
                lineStyle: { opacity: 0 },
                markArea: {
                  silent: true,
                  itemStyle: { color: theme.alertBandFill },
                  data: runIntervals.map((interval) => [
                    { xAxis: interval.start },
                    { xAxis: interval.end },
                  ]),
                },
              });
            }
          }

          const comparator = comparatorMetric ? getCrossHearingComparator(comparatorMetric) : null;
          if (comparator && lineField) {
            const comparatorYAxisIndex = barField ? 1 : 0;
            const startTime = sorted[0].__time;
            const endTime = sorted[sorted.length - 1].__time;

            if (
              comparator.bandP10 !== null &&
              comparator.bandP90 !== null &&
              comparator.bandP90 >= comparator.bandP10
            ) {
              const bandAnchor =
                comparator.bandP50 !== null ? comparator.bandP50 : comparator.bandP10;
              option.series.push({
                name: "Cross-hearing p10-p90 band",
                type: "line",
                yAxisIndex: comparatorYAxisIndex,
                data: sorted.map((row) => [row.__time, bandAnchor]),
                showSymbol: false,
                tooltip: { show: false },
                lineStyle: { opacity: 0 },
                markArea: {
                  silent: true,
                  itemStyle: { color: theme.comparatorBandFill },
                  data: [
                    [
                      { xAxis: startTime, yAxis: comparator.bandP10 },
                      { xAxis: endTime, yAxis: comparator.bandP90 },
                    ],
                  ],
                },
              });
            }

            if (comparator.bandP50 !== null) {
              option.series.push({
                name: "Cross-hearing p50",
                type: "line",
                yAxisIndex: comparatorYAxisIndex,
                data: sorted.map((row) => [row.__time, comparator.bandP50]),
                showSymbol: false,
                lineStyle: {
                  color: theme.contextLine,
                  width: 1.5,
                  type: "dashed",
                  opacity: 0.95,
                },
              });
            }

            const percentileLabel =
              comparator.percentile !== null
                ? formatPercent(comparator.percentile, 0)
                : "n/a";
            mount.crossHearingComparatorNote =
              "Cross-hearing baseline (" +
              comparator.label +
              ", n=" +
              comparator.nReports.toLocaleString() +
              "): percentile " +
              percentileLabel +
              ".";
          }

          if (robustLowerData.length) {
            option.series.push({
              name: "Robust lower-tail alert",
              type: "scatter",
              yAxisIndex: barField ? 1 : 0,
              data: robustLowerData,
              symbol: "diamond",
              symbolSize: denseOffHoursMarkers ? 9 : 10,
              itemStyle: {
                color: theme.alertLower,
                borderColor: theme.axisLine,
                borderWidth: denseOffHoursMarkers ? 1.25 : 1.5,
                opacity: denseOffHoursMarkers ? 0.94 : 0.98,
              },
            });
          }
          if (robustUpperData.length) {
            option.series.push({
              name: "Robust upper-tail alert",
              type: "scatter",
              yAxisIndex: barField ? 1 : 0,
              data: robustUpperData,
              symbol: "triangle",
              symbolSize: denseOffHoursMarkers ? 9 : 10,
              itemStyle: {
                color: theme.alertUpper,
                borderColor: theme.axisLine,
                borderWidth: denseOffHoursMarkers ? 1.25 : 1.5,
                opacity: denseOffHoursMarkers ? 0.94 : 0.98,
              },
            });
          }
          if (spcOnlyData.length) {
            option.series.push({
              name: "SPC-only flag",
              type: "scatter",
              yAxisIndex: barField ? 1 : 0,
              data: spcOnlyData,
              symbol: "rect",
              symbolSize: denseOffHoursMarkers ? 7 : 8,
              itemStyle: {
                color: "rgba(0,0,0,0)",
                borderColor: theme.referenceLine,
                borderWidth: denseOffHoursMarkers ? 1.2 : 1.5,
                opacity: denseOffHoursMarkers ? 0.9 : 1,
              },
            });
          }
          if (fdrOnlyData.length) {
            option.series.push({
              name: "FDR-only flag",
              type: "scatter",
              yAxisIndex: barField ? 1 : 0,
              data: fdrOnlyData,
              symbol: "circle",
              symbolSize: denseOffHoursMarkers ? 7 : 8,
              itemStyle: {
                color: "rgba(0,0,0,0)",
                borderColor: theme.contextLine,
                borderWidth: denseOffHoursMarkers ? 1.2 : 1.5,
                opacity: denseOffHoursMarkers ? 0.9 : 1,
              },
            });
          }
          if (genericFlagData.length) {
            option.series.push({
              name: "Flagged",
              type: "scatter",
              yAxisIndex: barField ? 1 : 0,
              data: genericFlagData,
              symbol: "diamond",
              symbolSize: denseOffHoursMarkers ? 8 : 9,
              itemStyle: {
                color: theme.alertLower,
                borderColor: theme.axisLine,
                borderWidth: denseOffHoursMarkers ? 1 : 1.2,
                opacity: denseOffHoursMarkers ? 0.86 : 0.92,
              },
            });
          }
          if (lowPowerData.length) {
            option.series.push({
              name: "Low-power",
              type: "scatter",
              yAxisIndex: barField ? 1 : 0,
              data: lowPowerData,
              symbol: "triangle",
              symbolRotate: 180,
              symbolSize: denseOffHoursMarkers ? 7 : 8,
              itemStyle: {
                color: theme.lowPower,
                borderColor: theme.axisLine,
                borderWidth: denseOffHoursMarkers ? 0.9 : 1,
                opacity: denseOffHoursMarkers ? 0.9 : 0.96,
              },
            });
          }

          mount.chart.setOption(ensureReadableAxes(option, mount), true);
          mount.seriesId = mainSeriesId;
          mount.isTimeSeries = true;
          mount.isAbsoluteTime = state.absoluteTimeSet.has(mount.chartId);
          return true;
        }

        function renderShiftHeatmap(mount, rows) {
          const theme = currentChartTheme();
          const subset = rows
            .map((row) => ({
              date: String(row.date || ""),
              slot: toNumber(row.slot_start_minute),
              value: toFiniteNumberOrNull(row.delta_from_slot_pro_rate),
              outlier: toBool(row.is_slot_outlier),
            }))
            .filter((row) => row.date && row.value !== null);

          if (!subset.length) {
            return false;
          }

          const dates = Array.from(new Set(subset.map((row) => row.date))).sort();
          const slots = Array.from(new Set(subset.map((row) => row.slot))).sort((a, b) => a - b);
          const dateMap = new Map(dates.map((value, index) => [value, index]));
          const slotMap = new Map(slots.map((value, index) => [value, index]));

          const values = [];
          const outliers = [];
          subset.forEach((row) => {
            const x = slotMap.get(row.slot);
            const y = dateMap.get(row.date);
            if (typeof x !== "number" || typeof y !== "number") {
              return;
            }
            values.push([x, y, row.value]);
            if (row.outlier) {
              outliers.push([x, y, row.value]);
            }
          });

          const maxAbs = Math.max(
            0.05,
            ...values.map((entry) => Math.abs(toNumber(entry[2]))).filter((value) => Number.isFinite(value))
          );

          const option = {
            animation: false,
            tooltip: {
                position: "top",
                formatter: (params) => {
                  if (!Array.isArray(params.value)) {
                    return "";
                  }
                  const xIndex = params.value[0];
                  const yIndex = params.value[1];
                  const slotMinutes = slots[xIndex];
                  const hour = Math.floor(slotMinutes / 60);
                  const minute = slotMinutes % 60;
                  const bucketLabel = bucketLabelFromValue(mount.activeBucket);
                  return (
                    "<strong>Time (" +
                    reportTimezoneLabel +
                    "):</strong> " +
                    dates[yIndex] +
                    " " +
                    String(hour).padStart(2, "0") +
                    ":" +
                    String(minute).padStart(2, "0") +
                    (bucketLabel ? "<br/><strong>Bucket:</strong> " + bucketLabel : "") +
                    "<br/><strong>Delta:</strong> " +
                    toNumber(params.value[2]).toFixed(4)
                  );
                },
              },
            grid: { left: 72, right: 34, top: 20, bottom: 62 },
            xAxis: {
                type: "category",
                name: "Time of day (" + reportTimezoneLabel + ")",
                data: slots.map((slotMinutes) => {
                  const hour = Math.floor(slotMinutes / 60);
                  const minute = slotMinutes % 60;
                  return String(hour).padStart(2, "0") + ":" + String(minute).padStart(2, "0");
                }),
                axisLabel: { interval: Math.ceil(slots.length / 18) },
                splitArea: { show: true },
              },
            yAxis: {
                type: "category",
                name: "Date",
                data: dates,
                inverse: true,
                splitArea: { show: true },
              },
            visualMap: {
                min: -maxAbs,
                max: maxAbs,
                calculable: true,
                orient: "horizontal",
                left: "center",
                bottom: 6,
                inRange: { color: theme.heatmapDiverging },
              },
            series: [
                {
                  name: "shift",
                  type: "heatmap",
                  data: values,
                  emphasis: { itemStyle: { shadowBlur: 10, shadowColor: theme.shadowColor } },
                },
                {
                  name: "slot outlier",
                  type: "scatter",
                  data: outliers,
                  symbolSize: 10,
                  itemStyle: {
                    color: theme.outlierPoint,
                    borderColor: theme.axisLine,
                    borderWidth: 1,
                  },
                },
              ],
          };

          mount.chart.setOption(ensureReadableAxes(option, mount), true);

          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        function renderDayHourHeatmap(mount, rows, valueField) {
          const theme = currentChartTheme();
          const isProportion = String(valueField || "").toLowerCase() === "pro_rate";
          const subset = rows
            .map((row) => ({
              day: String(row.day_of_week || ""),
              hour: toNumber(row.hour),
              value: toFiniteNumberOrNull(row[valueField]),
            }))
            .filter((row) => row.day && row.value !== null);
          if (!subset.length) {
            return false;
          }

          const dayOrder = [
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
            "Sunday",
          ];
          const days = Array.from(new Set(subset.map((row) => row.day))).sort(
            (left, right) => dayOrder.indexOf(left) - dayOrder.indexOf(right)
          );
          const hours = Array.from(new Set(subset.map((row) => row.hour))).sort((a, b) => a - b);
          const dayMap = new Map(days.map((value, index) => [value, index]));
          const hourMap = new Map(hours.map((value, index) => [value, index]));

          const values = subset
            .map((row) => {
              const x = hourMap.get(row.hour);
              const y = dayMap.get(row.day);
              if (typeof x !== "number" || typeof y !== "number") {
                return null;
              }
              return [x, y, row.value];
            })
            .filter((entry) => entry !== null);

          const numericValues = values
            .map((entry) => toFiniteNumberOrNull(entry[2]))
            .filter((value) => value !== null);
          if (!numericValues.length) {
            return false;
          }
          let minValue = isProportion ? 0 : Math.min.apply(null, numericValues);
          let maxValue = isProportion ? 1 : Math.max.apply(null, numericValues);
          if (!isProportion && minValue === maxValue) {
            maxValue = minValue + 1;
          }

          const option = {
            animation: false,
            tooltip: {
                position: "top",
                formatter: (params) => {
                  if (!Array.isArray(params.value)) {
                    return "";
                  }
                  const bucketLabel = bucketLabelFromValue(mount.activeBucket);
                  return (
                    "<strong>Time (" +
                    reportTimezoneLabel +
                    "):</strong> " +
                    days[params.value[1]] +
                    " " +
                    String(hours[params.value[0]]).padStart(2, "0") +
                    ":00" +
                    (bucketLabel ? "<br/><strong>Bucket:</strong> " + bucketLabel : "") +
                    "<br/><strong>Value:</strong> " +
                    toNumber(params.value[2]).toFixed(4)
                  );
                },
              },
            grid: { left: 76, right: 30, top: 18, bottom: 56 },
            xAxis: {
                type: "category",
                name: "Hour (" + reportTimezoneLabel + ")",
                data: hours.map((hour) => String(hour).padStart(2, "0")),
                splitArea: { show: true },
              },
            yAxis: {
                type: "category",
                name: "Day of week",
                data: days,
                inverse: true,
                splitArea: { show: true },
              },
            visualMap: {
                min: minValue,
                max: maxValue,
                orient: "horizontal",
                left: "center",
                bottom: 6,
                calculable: true,
                text: isProportion ? ["Pro-leaning", "Con-leaning"] : undefined,
                inRange: isProportion
                  ? { color: theme.heatmapRateDiverging || theme.heatmapDiverging }
                  : { color: theme.heatmapRate },
              },
            series: [
                {
                  type: "heatmap",
                  data: values,
                  emphasis: { itemStyle: { shadowBlur: 8, shadowColor: theme.shadowColor } },
                },
              ],
          };
          mount.chart.setOption(ensureReadableAxes(option, mount), true);
          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        function renderDateHourHeatmap(mount, rows, valueField, valueLabel, options) {
          const theme = currentChartTheme();
          const heatmapOptions =
            options && typeof options === "object" ? options : {};
          const scaleMode = String(heatmapOptions.scaleMode || "").toLowerCase();
          const isProportionField = String(valueField || "").toLowerCase() === "pro_rate";
          const highlightOffHoursAxis = toBool(heatmapOptions.highlightOffHoursAxis);
          const offHoursAxisThreshold = Math.min(
            1,
            Math.max(
              0,
              toFiniteNumberOrNull(heatmapOptions.offHoursAxisThreshold) === null
                ? 0.5
                : toNumber(heatmapOptions.offHoursAxisThreshold)
            )
          );
          const force24HourSlots = toBool(heatmapOptions.force24HourSlots);
          const showMissingOverlay =
            toBool(heatmapOptions.showMissingOverlay) ||
            String(valueField || "").toLowerCase() === "n_total";
          const divergingPositiveWarm = toBool(heatmapOptions.divergingPositiveWarm);
          const subset = rows
            .map((row) => ({
              date: String(row.date || ""),
              hour: toNumber(row.hour),
              value: toFiniteNumberOrNull(row[valueField]),
              nTotal: toFiniteNumberOrNull(row.n_total),
              nKnown: toFiniteNumberOrNull(row.n_known),
              nWindows: toFiniteNumberOrNull(row.n_windows),
              nWindowsTested: toFiniteNumberOrNull(row.n_windows_tested),
              nWindowsPrimaryAlert: toFiniteNumberOrNull(row.n_windows_primary_alert),
              expectedPrimary: toFiniteNumberOrNull(row.expected_pro_rate_primary),
              deltaPrimary: toFiniteNumberOrNull(row.delta_pro_rate_primary),
              zPrimaryMedian: toFiniteNumberOrNull(row.z_score_primary_median),
              zPrimaryAbsMax: toFiniteNumberOrNull(row.z_score_primary_abs_max),
              offHoursFraction: toFiniteNumberOrNull(row.off_hours_fraction),
              proRate: toFiniteNumberOrNull(row.pro_rate),
              lowPower: toBool(row.is_low_power),
            }))
            .filter((row) => row.date && Number.isFinite(row.hour));
          if (!subset.length) {
            return false;
          }

          const dates = Array.from(new Set(subset.map((row) => row.date))).sort();
          const hours = force24HourSlots
            ? Array.from({ length: 24 }, (_unused, index) => index)
            : Array.from(new Set(subset.map((row) => row.hour))).sort((a, b) => a - b);
          const dateMap = new Map(dates.map((value, index) => [value, index]));
          const hourMap = new Map(hours.map((value, index) => [value, index]));
          const cellLookup = new Map();

          const values = [];
          const lowPowerPoints = [];
          const highlightedHours = new Set();
          subset.forEach((row) => {
            const x = hourMap.get(row.hour);
            const y = dateMap.get(row.date);
            if (typeof x !== "number" || typeof y !== "number") {
              return;
            }
            const key = String(row.date) + "|" + String(row.hour);
            cellLookup.set(key, row);
            if (row.value === null) {
              return;
            }
            values.push([x, y, row.value]);
            if (row.lowPower) {
              lowPowerPoints.push([x, y, row.value]);
            }
            if (
              highlightOffHoursAxis &&
              row.offHoursFraction !== null &&
              row.offHoursFraction >= offHoursAxisThreshold
            ) {
              highlightedHours.add(row.hour);
            }
          });

          const isDiverging = scaleMode === "diverging";
          const isRateDiverging = scaleMode === "rate_diverging";
          const isVolume =
            scaleMode === "volume" ||
            String(valueField || "").toLowerCase() === "n_total" ||
            String(valueField || "").toLowerCase() === "n_known";
          const isRate =
            scaleMode === "rate" ||
            isRateDiverging ||
            (!isDiverging && isProportionField);
          const numericValues = values
            .map((entry) => toFiniteNumberOrNull(entry[2]))
            .filter((value) => value !== null);
          if (!numericValues.length) {
            return false;
          }
          let minValue = isRate || isVolume ? 0 : Math.min.apply(null, numericValues);
          let maxValue = isRate ? 1 : Math.max.apply(null, numericValues);
          if (isDiverging) {
            const maxAbs = Math.max.apply(
              null,
              numericValues.map((value) => Math.abs(toNumber(value)))
            );
            const boundedMaxAbs = Number.isFinite(maxAbs) && maxAbs > 0 ? maxAbs : 1;
            minValue = -boundedMaxAbs;
            maxValue = boundedMaxAbs;
          } else if (isVolume && maxValue <= 0) {
            maxValue = 1;
          } else if (!isRate && minValue === maxValue) {
            maxValue = minValue + 1;
          }
          const divergingColors = divergingPositiveWarm
            ? (theme.heatmapDiverging || []).slice().reverse()
            : theme.heatmapDiverging;
          const missingCells = [];
          if (showMissingOverlay && dates.length && hours.length) {
            dates.forEach((dateValue) => {
              hours.forEach((hourValue) => {
                const key = String(dateValue) + "|" + String(hourValue);
                const details = cellLookup.get(key);
                const hasValue = details && details.value !== null;
                if (hasValue) {
                  return;
                }
                const x = hourMap.get(hourValue);
                const y = dateMap.get(dateValue);
                if (typeof x === "number" && typeof y === "number") {
                  missingCells.push([x, y, 0]);
                }
              });
            });
          }
          const bucketLabel = bucketLabelFromValue(mount.activeBucket);

          const option = {
            animation: false,
            tooltip: {
                position: "top",
                formatter: (params) => {
                  if (!Array.isArray(params.value)) {
                    return "";
                  }
                  const xIndex = params.value[0];
                  const yIndex = params.value[1];
                  const hour = hours[xIndex];
                  const date = dates[yIndex];
                  const key = String(date) + "|" + String(hour);
                  const details = cellLookup.get(key);
                  const lines = [
                    "<strong>Time (" +
                      reportTimezoneLabel +
                      "):</strong> " +
                      String(date) +
                      " " +
                      String(hour).padStart(2, "0") +
                      ":00",
                  ];
                  if (bucketLabel) {
                    lines.push("<strong>Bucket:</strong> " + bucketLabel);
                  }
                  const hasCellValue = details && details.value !== null;
                  lines.push(
                    "<strong>" +
                      String(valueLabel || valueField) +
                      ":</strong> " +
                      (hasCellValue ? formatTooltipValue(params.value[2]) : "No data")
                  );
                  if (details && details.nTotal !== null) {
                    lines.push("<strong>Total:</strong> " + Math.round(details.nTotal).toLocaleString());
                  }
                  if (details && details.nKnown !== null) {
                    lines.push("<strong>Known Pro+Con:</strong> " + Math.round(details.nKnown));
                  }
                  if (details && details.nWindows !== null) {
                    lines.push("<strong>Windows:</strong> " + Math.round(details.nWindows));
                  }
                  if (details && details.nWindowsTested !== null) {
                    lines.push(
                      "<strong>Tested windows:</strong> " +
                        Math.round(details.nWindowsTested)
                    );
                  }
                  if (details && details.nWindowsPrimaryAlert !== null) {
                    lines.push(
                      "<strong>Robust alerts:</strong> " +
                        Math.round(details.nWindowsPrimaryAlert)
                    );
                  }
                  if (details && details.proRate !== null && valueField !== "pro_rate") {
                    lines.push("<strong>Pro rate:</strong> " + formatPercent(details.proRate));
                  }
                  if (details && details.offHoursFraction !== null) {
                    lines.push(
                      "<strong>Off-hours fraction:</strong> " + formatPercent(details.offHoursFraction)
                    );
                  }
                  if (
                    details &&
                    details.expectedPrimary !== null &&
                    valueField !== "expected_pro_rate_primary"
                  ) {
                    lines.push(
                      "<strong>Expected pro rate:</strong> " +
                        formatPercent(details.expectedPrimary)
                    );
                  }
                  if (
                    details &&
                    details.deltaPrimary !== null &&
                    valueField !== "delta_pro_rate_primary"
                  ) {
                    lines.push(
                      "<strong>Delta vs primary:</strong> " +
                        formatTooltipValue(details.deltaPrimary)
                    );
                  }
                  if (details && details.zPrimaryMedian !== null && valueField !== "z_score_primary") {
                    lines.push(
                      "<strong>Median primary z:</strong> " +
                        formatTooltipValue(details.zPrimaryMedian)
                    );
                  }
                  if (details && details.zPrimaryAbsMax !== null) {
                    lines.push(
                      "<strong>Max |primary z|:</strong> " +
                        formatTooltipValue(details.zPrimaryAbsMax)
                    );
                  }
                  if (details && details.lowPower) {
                    lines.push("<strong>Low-power:</strong> yes");
                  }
                  return lines.join("<br/>");
                },
              },
            grid: { left: 86, right: 54, top: 18, bottom: 86 },
            xAxis: {
                type: "category",
                name: "Hour (" + reportTimezoneLabel + ")",
                data: hours.map((hour) => String(hour).padStart(2, "0")),
                axisLabel: {
                  formatter: (value) => {
                    const parsedHour = Number(value);
                    const label = String(value || "").padStart(2, "0");
                    if (highlightOffHoursAxis && highlightedHours.has(parsedHour)) {
                      return "{offHours|" + label + "}";
                    }
                    return label;
                  },
                  rich: highlightOffHoursAxis
                    ? {
                        offHours: {
                          color: theme.alertLower,
                          fontWeight: 700,
                        },
                      }
                    : undefined,
                },
                splitArea: { show: true },
              },
            yAxis: {
                type: "category",
                name: "Date",
                data: dates,
                inverse: true,
                splitArea: { show: true },
              },
            visualMap: {
                min: minValue,
                max: maxValue,
                orient: "horizontal",
                left: "center",
                bottom: 8,
                calculable: true,
                text:
                  isRate && (isRateDiverging || isProportionField)
                    ? ["Pro-leaning", "Con-leaning"]
                    : isDiverging
                      ? divergingPositiveWarm
                        ? ["Positive residual", "Negative residual"]
                        : ["Negative residual", "Positive residual"]
                    : undefined,
                inRange: isRate
                  ? isRateDiverging || isProportionField
                    ? { color: theme.heatmapRateDiverging || theme.heatmapDiverging }
                    : { color: theme.heatmapRate }
                  : isDiverging
                    ? { color: divergingColors }
                    : { color: theme.heatmapVolume },
              },
            series: [
                {
                  name: "no-data",
                  type: "heatmap",
                  data: missingCells,
                  silent: true,
                  itemStyle: {
                    color: theme.heatmapNoData,
                    borderColor: theme.heatmapNoDataBorder,
                    borderWidth: 0.6,
                  },
                  emphasis: { disabled: true },
                  z: 0,
                },
                {
                  name: valueLabel || valueField,
                  type: "heatmap",
                  data: values,
                  emphasis: { itemStyle: { shadowBlur: 8, shadowColor: theme.shadowColor } },
                  z: 1,
                },
                {
                  name: "low-power",
                  type: "scatter",
                  data: lowPowerPoints,
                  symbol: "triangle",
                  symbolRotate: 180,
                  symbolSize: 9,
                  itemStyle: {
                    color: theme.lowPower,
                    borderColor: theme.axisLine,
                    borderWidth: 1,
                  },
                },
              ],
          };

          mount.chart.setOption(ensureReadableAxes(option, mount), true);

          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        function renderOffHoursFunnel(mount, rows) {
          const theme = currentChartTheme();
          const subset = rows
            .map((row) => ({
              bucketStart: toEpochMillis(row.bucket_start),
              bucketMinutes: toFiniteNumberOrNull(row.bucket_minutes),
              nTotal: toFiniteNumberOrNull(row.n_total),
              nKnown: toFiniteNumberOrNull(row.n_known),
              proRate: toFiniteNumberOrNull(row.pro_rate),
              expectedGlobal: toFiniteNumberOrNull(row.expected_pro_rate_global),
              expectedPrimary: toFiniteNumberOrNull(row.expected_pro_rate_primary),
              low95Primary: toFiniteNumberOrNull(row.control_low_95_primary),
              high95Primary: toFiniteNumberOrNull(row.control_high_95_primary),
              low998Primary: toFiniteNumberOrNull(row.control_low_998_primary),
              high998Primary: toFiniteNumberOrNull(row.control_high_998_primary),
              low95Global: toFiniteNumberOrNull(row.control_low_95_global),
              high95Global: toFiniteNumberOrNull(row.control_high_95_global),
              low998Global: toFiniteNumberOrNull(row.control_low_998_global),
              high998Global: toFiniteNumberOrNull(row.control_high_998_global),
              zDay: toFiniteNumberOrNull(row.z_score_day),
              zPrimary: toFiniteNumberOrNull(row.z_score_primary),
              deltaPrimary: toFiniteNumberOrNull(row.delta_pro_rate_primary),
              qPrimary: toFiniteNumberOrNull(
                Object.prototype.hasOwnProperty.call(row, "q_value_primary_lower")
                  ? row.q_value_primary_lower
                  : row.q_value_primary
              ),
              qPrimaryTwoSided: toFiniteNumberOrNull(row.q_value_primary_two_sided),
              significantPrimaryLower: toBool(
                Object.prototype.hasOwnProperty.call(row, "is_significant_primary_lower")
                  ? row.is_significant_primary_lower
                  : row.is_significant_primary
              ),
              significantPrimaryUpper: toBool(row.is_significant_primary_upper),
              significantPrimaryTwoSided: toBool(row.is_significant_primary_two_sided),
              materialPrimaryLowerShift: toBool(row.is_material_primary_lower_shift),
              materialPrimaryUpperShift: toBool(row.is_material_primary_upper_shift),
              belowPrimary998: toBool(row.is_below_primary_control_998),
              abovePrimary998: toBool(row.is_above_primary_control_998),
              alertOffHoursWindow: toBool(row.is_alert_off_hours_window),
              primaryAlertWindow: toBool(row.is_primary_alert_window),
              primarySpcTwoSided: toBool(row.is_primary_spc_998_two_sided),
              primaryFdrTwoSided: toBool(row.is_primary_fdr_two_sided),
              modelAvailable: toBool(row.is_model_baseline_available),
              primaryBaselineSource:
                typeof row.primary_baseline_source === "string" ? row.primary_baseline_source : "",
              lowPower: toBool(row.is_low_power),
              offHoursWindow: toBool(row.is_off_hours_window),
              pureOffHoursWindow: toBool(row.is_pure_off_hours_window),
              inferentialEligible:
                toBool(row.is_alert_off_hours_window) && !toBool(row.is_low_power),
            }))
            .filter((row) => row.nKnown !== null && row.nKnown > 0 && row.proRate !== null)
            .slice(0, 60000);
          if (!subset.length) {
            return false;
          }

          const sorted = subset.slice().sort((left, right) => left.nKnown - right.nKnown);
          const curveByN = new Map();
          sorted.forEach((row) => {
            const nKey = Math.round(row.nKnown);
            if (curveByN.has(nKey)) {
              return;
            }
            curveByN.set(nKey, row);
          });
          const curveRows = Array.from(curveByN.entries())
            .map((entry) => ({ n: entry[0], row: entry[1] }))
            .sort((left, right) => left.n - right.n);

          const expectedSeries = curveRows
            .filter((entry) => entry.row.expectedGlobal !== null)
            .map((entry) => [entry.n, entry.row.expectedGlobal]);
          const low95Series = curveRows
            .filter((entry) => entry.row.low95Global !== null)
            .map((entry) => [entry.n, entry.row.low95Global]);
          const high95Series = curveRows
            .filter((entry) => entry.row.high95Global !== null)
            .map((entry) => [entry.n, entry.row.high95Global]);
          const low998Series = curveRows
            .filter((entry) => entry.row.low998Global !== null)
            .map((entry) => [entry.n, entry.row.low998Global]);
          const high998Series = curveRows
            .filter((entry) => entry.row.high998Global !== null)
            .map((entry) => [entry.n, entry.row.high998Global]);

          const toPoint = (row) => ({
            value: [row.nKnown, row.proRate, row.bucketStart],
            meta: row,
          });
          const classifyDirection = (row) => {
            if (row.materialPrimaryLowerShift || row.significantPrimaryLower || row.belowPrimary998) {
              return "lower";
            }
            if (row.materialPrimaryUpperShift || row.significantPrimaryUpper || row.abovePrimary998) {
              return "upper";
            }
            if (row.deltaPrimary !== null) {
              return row.deltaPrimary < 0 ? "lower" : "upper";
            }
            return "upper";
          };
          const offHoursPoints = sorted.filter((row) => row.offHoursWindow).map(toPoint);
          const inferentialOffHoursPoints = sorted
            .filter((row) => row.inferentialEligible)
            .map(toPoint);
          const onHoursPoints = sorted.filter((row) => !row.offHoursWindow).map(toPoint);
          const lowPowerPoints = sorted.filter((row) => row.lowPower).map(toPoint);
          const robustLowerPoints = [];
          const robustUpperPoints = [];
          const spcOnlyPoints = [];
          const fdrOnlyPoints = [];
          sorted.forEach((row) => {
            if (row.inferentialEligible && row.primarySpcTwoSided && !row.primaryFdrTwoSided) {
              spcOnlyPoints.push(toPoint(row));
            }
            if (row.inferentialEligible && row.primaryFdrTwoSided && !row.primarySpcTwoSided) {
              fdrOnlyPoints.push(toPoint(row));
            }
            if (!row.inferentialEligible) {
              return;
            }
            const direction = classifyDirection(row);
            const robustLower =
              row.primaryAlertWindow ||
              (row.significantPrimaryTwoSided &&
                row.belowPrimary998 &&
                row.materialPrimaryLowerShift);
            const robustUpper =
              (row.significantPrimaryTwoSided &&
                row.abovePrimary998 &&
                row.materialPrimaryUpperShift) ||
              (row.primaryAlertWindow && direction === "upper");
            if (robustLower && direction === "lower") {
              robustLowerPoints.push(toPoint(row));
            } else if (robustUpper && direction === "upper") {
              robustUpperPoints.push(toPoint(row));
            }
          });
          const bucketLabel = bucketLabelFromValue(mount.activeBucket);

          const option = {
            animation: false,
            color: theme.seriesPalette,
            tooltip: {
                formatter: (params) => {
                  const payload = params && params.data && params.data.meta ? params.data.meta : null;
                  const dataValue = Array.isArray(params.value) ? params.value : [];
                  const nKnown = payload ? payload.nKnown : toFiniteNumberOrNull(dataValue[0]);
                  const proRate = payload ? payload.proRate : toFiniteNumberOrNull(dataValue[1]);
                  const lines = [];
                  if (nKnown !== null) {
                    lines.push(
                      "<strong>Known Pro+Con (n):</strong> " + Math.round(nKnown).toLocaleString()
                    );
                  }
                  if (payload && payload.nTotal !== null) {
                    lines.push("<strong>Total rows:</strong> " + Math.round(payload.nTotal).toLocaleString());
                  }
                  if (proRate !== null) {
                    lines.push("<strong>Pro rate:</strong> " + formatPercent(proRate));
                  }
                  if (payload && payload.bucketStart !== null) {
                    lines.push(
                      "<strong>Time (" +
                        reportTimezoneLabel +
                        "):</strong> " +
                        formatEpochMillis(payload.bucketStart)
                    );
                  }
                  if (payload && payload.bucketMinutes !== null) {
                    lines.push(
                      "<strong>Bucket:</strong> " + String(Math.round(payload.bucketMinutes)) + "m"
                    );
                  } else if (bucketLabel) {
                    lines.push("<strong>Bucket:</strong> " + bucketLabel);
                  }
                  if (payload && payload.expectedGlobal !== null) {
                    lines.push("<strong>Global baseline:</strong> " + formatPercent(payload.expectedGlobal));
                  }
                  if (payload && payload.expectedPrimary !== null) {
                    lines.push(
                      "<strong>Primary baseline:</strong> " + formatPercent(payload.expectedPrimary)
                    );
                  }
                  if (payload && payload.zDay !== null) {
                    lines.push("<strong>Day-adjusted z:</strong> " + toNumber(payload.zDay).toFixed(2));
                  }
                  if (payload && payload.zPrimary !== null) {
                    lines.push(
                      "<strong>Primary-baseline z:</strong> " +
                        toNumber(payload.zPrimary).toFixed(2)
                    );
                  }
                  if (payload && payload.deltaPrimary !== null) {
                    lines.push(
                      "<strong>Primary delta (obs-exp):</strong> " +
                        formatPercent(payload.deltaPrimary)
                    );
                  }
                  if (payload && payload.qPrimary !== null) {
                    lines.push(
                      "<strong>Primary lower-tail q:</strong> " +
                        toNumber(payload.qPrimary).toExponential(2)
                    );
                  }
                  if (payload && payload.qPrimaryTwoSided !== null) {
                    lines.push(
                      "<strong>Primary two-sided q:</strong> " +
                        toNumber(payload.qPrimaryTwoSided).toExponential(2)
                    );
                  }
                  if (payload && payload.offHoursWindow) {
                    lines.push("<strong>Window class:</strong> off-hours");
                  }
                  if (payload && payload.alertOffHoursWindow) {
                    lines.push("<strong>Alert-eligible window:</strong> yes");
                  }
                  if (payload && payload.inferentialEligible) {
                    lines.push("<strong>Inferentially eligible:</strong> yes");
                  } else if (payload && payload.alertOffHoursWindow) {
                    lines.push("<strong>Inferentially eligible:</strong> no (low-power)");
                  }
                  if (payload && payload.primaryBaselineSource) {
                    lines.push(
                      "<strong>Primary source:</strong> " +
                        String(payload.primaryBaselineSource).replace(/_/g, " ")
                    );
                  }
                  if (payload && payload.modelAvailable) {
                    lines.push("<strong>Model baseline:</strong> available");
                  }
                  if (payload && payload.significantPrimaryLower) {
                    lines.push("<strong>Primary lower-tail FDR:</strong> yes");
                  }
                  if (payload && payload.significantPrimaryUpper) {
                    lines.push("<strong>Primary upper-tail FDR:</strong> yes");
                  }
                  if (payload && payload.significantPrimaryTwoSided) {
                    lines.push("<strong>Primary two-sided FDR:</strong> yes");
                  }
                  if (payload && payload.materialPrimaryLowerShift) {
                    lines.push("<strong>Material lower shift:</strong> yes");
                  }
                  if (payload && payload.materialPrimaryUpperShift) {
                    lines.push("<strong>Material upper shift:</strong> yes");
                  }
                  if (payload && payload.primaryAlertWindow) {
                    lines.push("<strong>Robust primary alert:</strong> yes");
                  }
                  if (payload && payload.abovePrimary998) {
                    lines.push("<strong>Above primary 99.8% upper band:</strong> yes");
                  }
                  if (payload && payload.lowPower) {
                    lines.push("<strong>Low-power:</strong> yes");
                  }
                  return lines.join("<br/>");
                },
              },
            grid: { left: 66, right: 36, top: 18, bottom: 60 },
            legend: {
                bottom: 0,
                selected: {
                  "Global 99.8% lower": false,
                  "Global 99.8% upper": false,
                },
              },
            xAxis: {
                type: "log",
                name: "Known Pro+Con Count (n)",
                min: "dataMin",
              },
            yAxis: {
                type: "value",
                name: "Pro rate",
                min: 0,
                max: 1,
              },
            series: [
                {
                  name: "On-hours/mixed windows",
                  type: "scatter",
                  data: onHoursPoints,
                  symbolSize: 6.5,
                  itemStyle: { color: theme.referenceLine, opacity: 0.34 },
                },
                {
                  name: "Off-hours windows",
                  type: "scatter",
                  data: offHoursPoints,
                  symbolSize: 7,
                  itemStyle: { color: theme.primaryLine, opacity: 0.52 },
                },
                {
                  name: "Inferentially tested off-hours",
                  type: "scatter",
                  data: inferentialOffHoursPoints,
                  symbolSize: 7.5,
                  itemStyle: { color: theme.contextLine, opacity: 0.82 },
                },
                {
                  name: "SPC-only flag",
                  type: "scatter",
                  data: spcOnlyPoints,
                  symbol: "rect",
                  symbolSize: 7,
                  itemStyle: {
                    color: "rgba(0,0,0,0)",
                    borderColor: theme.referenceLine,
                    borderWidth: 1.2,
                    opacity: 0.9,
                  },
                },
                {
                  name: "FDR-only flag",
                  type: "scatter",
                  data: fdrOnlyPoints,
                  symbol: "circle",
                  symbolSize: 7,
                  itemStyle: {
                    color: "rgba(0,0,0,0)",
                    borderColor: theme.contextLine,
                    borderWidth: 1.2,
                    opacity: 0.9,
                  },
                },
                {
                  name: "Robust lower-tail alert",
                  type: "scatter",
                  data: robustLowerPoints,
                  symbol: "diamond",
                  symbolSize: 9,
                  itemStyle: {
                    color: theme.alertLower,
                    borderColor: theme.axisLine,
                    borderWidth: 1.35,
                    opacity: 0.94,
                  },
                },
                {
                  name: "Robust upper-tail alert",
                  type: "scatter",
                  data: robustUpperPoints,
                  symbol: "triangle",
                  symbolSize: 9,
                  itemStyle: {
                    color: theme.alertUpper,
                    borderColor: theme.axisLine,
                    borderWidth: 1.35,
                    opacity: 0.94,
                  },
                },
                {
                  name: "Low-power windows",
                  type: "scatter",
                  data: lowPowerPoints,
                  symbol: "triangle",
                  symbolRotate: 180,
                  symbolSize: 7,
                  itemStyle: {
                    color: theme.lowPower,
                    borderColor: theme.axisLine,
                    borderWidth: 0.9,
                    opacity: 0.88,
                  },
                },
                {
                  name: "Global expected rate",
                  type: "line",
                  data: expectedSeries,
                  showSymbol: false,
                  lineStyle: { color: theme.referenceLine, width: 1.1, type: "solid", opacity: 0.62 },
                },
                {
                  name: "Global 95% lower",
                  type: "line",
                  data: low95Series,
                  showSymbol: false,
                  lineStyle: { color: theme.intervalBand, width: 0.95, type: "dashed", opacity: 0.43 },
                },
                {
                  name: "Global 95% upper",
                  type: "line",
                  data: high95Series,
                  showSymbol: false,
                  lineStyle: { color: theme.intervalBand, width: 0.95, type: "dashed", opacity: 0.43 },
                },
                {
                  name: "Global 99.8% lower",
                  type: "line",
                  data: low998Series,
                  showSymbol: false,
                  lineStyle: { color: theme.intervalBand, width: 0.85, type: "dotted", opacity: 0.28 },
                },
                {
                  name: "Global 99.8% upper",
                  type: "line",
                  data: high998Series,
                  showSymbol: false,
                  lineStyle: { color: theme.intervalBand, width: 0.85, type: "dotted", opacity: 0.28 },
                },
              ],
          };

          mount.chart.setOption(ensureReadableAxes(option, mount), true);

          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        const simpleBarCategoricalChartIds = new Set([
          "composite_evidence_flags",
          "off_hours_primary_flag_channels",
          "voter_registry_match_tiers",
          "voter_registry_match_by_position",
        ]);
        const simpleBarRankedChartIds = new Set([
          "baseline_top_names",
          "baseline_name_length_distribution",
          "changepoints_hour_hist",
          "changepoints_magnitude",
          "duplicates_exact_top_names",
          "duplicates_exact_position_switch",
          "duplicates_near_cluster_size",
          "duplicates_near_similarity",
          "duplicates_near_time_concentration",
          "off_hours_hourly_profile",
          "off_hours_model_fit_diagnostics",
          "off_hours_summary_compare",
          "org_anomalies_bursts",
          "org_anomalies_top_orgs",
          "periodicity_clockface",
          "periodicity_spectrum",
          "rare_names_weird_scores",
          "sortedness_minute_spikes",
          "voter_registry_unmatched_names",
        ]);
        const simpleBarNullDiagnosticChartIds = new Set([
          "bursts_null_distribution",
          "bursts_significance_by_window",
          "procon_swings_null_distribution",
          "periodicity_rolling_fano",
        ]);
        const simpleBarRatioReferenceChartIds = new Set([
          "composite_high_priority",
          "periodicity_autocorr",
          "procon_swings_time_of_day_profile",
          "sortedness_bucket_summary",
          "sortedness_kendall_tau_summary",
        ]);
        const simpleBarDirectionalReferenceChartIds = new Set([
          "periodicity_autocorr",
          "procon_swings_time_of_day_profile",
          "sortedness_bucket_summary",
          "sortedness_kendall_tau_summary",
        ]);

        function renderSimpleBar(mount, rows, xField, yField, title) {
          const theme = currentChartTheme();
          const subset = rows
            .map((row) => ({
              raw: row,
              x: row[xField],
              y: toFiniteNumberOrNull(row[yField]),
            }))
            .filter((row) => row.x !== undefined && row.x !== null && row.y !== null)
            .slice(0, 200);
          if (!subset.length) {
            return false;
          }
          const bucketLabel = bucketLabelFromValue(mount.activeBucket);
          const isTimeField = [
            "minute_bucket",
            "bucket_start",
            "first_seen",
            "start_minute",
            "change_minute",
            "date",
          ].includes(xField);
          const xAxisLabel = isTimeField
            ? "Time (" + reportTimezoneLabel + ")"
            : humanizeFieldName(xField);
          const yAxisLabel = title ? String(title) : humanizeFieldName(yField);

          let barSeriesData = subset.map((row) => row.y);
          const markLineData = [];

          if (simpleBarCategoricalChartIds.has(mount.chartId)) {
            const palette = Array.isArray(theme.categoricalPalette) && theme.categoricalPalette.length
              ? theme.categoricalPalette
              : theme.seriesPalette;
            const colorByLabel = new Map();
            subset.forEach((row) => {
              const label = String(row.x);
              if (colorByLabel.has(label)) {
                return;
              }
              const nextColor = palette[colorByLabel.size % palette.length] || theme.barAccent;
              colorByLabel.set(label, nextColor);
            });
            barSeriesData = subset.map((row) => ({
              value: row.y,
              itemStyle: {
                color: colorByLabel.get(String(row.x)) || theme.barAccent,
                opacity: 0.9,
              },
            }));
          } else if (simpleBarRankedChartIds.has(mount.chartId)) {
            const ranked = subset
              .map((row, index) => ({ index: index, value: row.y }))
              .sort((left, right) => right.value - left.value);
            const topCount = Math.max(1, Math.min(6, Math.ceil(subset.length * 0.15)));
            const topIndexSet = new Set(ranked.slice(0, topCount).map((entry) => entry.index));
            barSeriesData = subset.map((row, index) => ({
              value: row.y,
              itemStyle: {
                color: topIndexSet.has(index) ? theme.alertLower : theme.barAccent,
                opacity: topIndexSet.has(index) ? 0.94 : 0.56,
              },
            }));
          } else if (simpleBarNullDiagnosticChartIds.has(mount.chartId)) {
            barSeriesData = subset.map((row) => ({
              value: row.y,
              itemStyle: {
                color: theme.referenceLine,
                opacity: 0.58,
              },
            }));
            const first = subset[0].raw || {};
            const observedField = [
              "observed_value",
              "observed_max",
              "observed_count",
              "observed",
              "actual",
            ].find((field) => toFiniteNumberOrNull(first[field]) !== null);
            const thresholdField = [
              "critical_value",
              "significance_threshold",
              "threshold",
              "alpha_threshold",
            ].find((field) => toFiniteNumberOrNull(first[field]) !== null);
            const observedValue = observedField ? toFiniteNumberOrNull(first[observedField]) : null;
            const thresholdValue = thresholdField
              ? toFiniteNumberOrNull(first[thresholdField])
              : null;
            if (thresholdValue !== null) {
              markLineData.push({
                name: "Threshold",
                yAxis: thresholdValue,
                lineStyle: { color: theme.referenceLine, type: "dashed", width: 1.2, opacity: 0.8 },
                label: { formatter: "threshold", color: theme.axisText, fontSize: 10 },
              });
            }
            if (observedValue !== null) {
              markLineData.push({
                name: "Observed",
                yAxis: observedValue,
                lineStyle: { color: theme.alertLower, type: "solid", width: 1.2, opacity: 0.9 },
                label: { formatter: "observed", color: theme.axisText, fontSize: 10 },
              });
            }
          } else if (simpleBarRatioReferenceChartIds.has(mount.chartId)) {
            const referenceByChartId = {
              composite_high_priority: 0.8,
              periodicity_autocorr: 0.0,
              procon_swings_time_of_day_profile: 0.5,
              sortedness_bucket_summary: 0.5,
              sortedness_kendall_tau_summary: 0.0,
            };
            const referenceValue = Object.prototype.hasOwnProperty.call(referenceByChartId, mount.chartId)
              ? referenceByChartId[mount.chartId]
              : null;
            const useDirectionalSplit =
              simpleBarDirectionalReferenceChartIds.has(mount.chartId) &&
              Number.isFinite(referenceValue);
            barSeriesData = subset.map((row) => {
              if (!useDirectionalSplit) {
                return {
                  value: row.y,
                  itemStyle: { color: theme.barAccent, opacity: 0.8 },
                };
              }
              return {
                value: row.y,
                itemStyle: {
                  color: row.y >= referenceValue ? theme.alertUpper : theme.alertLower,
                  opacity: 0.86,
                },
              };
            });
            if (Number.isFinite(referenceValue)) {
              markLineData.push({
                name: "Reference",
                yAxis: referenceValue,
                lineStyle: { color: theme.referenceLine, type: "dashed", width: 1.2, opacity: 0.85 },
                label: { formatter: "reference", color: theme.axisText, fontSize: 10 },
              });
            }
          }

          const seriesEntry = {
            type: "bar",
            data: barSeriesData,
          };
          if (markLineData.length) {
            seriesEntry.markLine = {
              symbol: ["none", "none"],
              data: markLineData,
            };
          }

          const option = {
            animation: false,
            tooltip: {
                trigger: "axis",
                axisPointer: { type: "shadow" },
                formatter: (params) => {
                  const entries = Array.isArray(params) ? params : [params];
                  if (!entries.length) {
                    return "";
                  }
                  const first = entries[0];
                  const categoryRaw = first.axisValueLabel || first.axisValue || "";
                  const timestamp = toEpochMillis(categoryRaw);
                  const lines = [];
                  if (timestamp !== null) {
                    lines.push(
                      "<strong>Time (" +
                        reportTimezoneLabel +
                        "):</strong> " +
                        formatEpochMillis(timestamp)
                    );
                  } else {
                    lines.push("<strong>" + xAxisLabel + ":</strong> " + String(categoryRaw));
                  }
                  if (bucketLabel) {
                    lines.push("<strong>Bucket:</strong> " + bucketLabel);
                  }
                  entries.forEach((entry) => {
                    lines.push(
                      (entry.marker || "") +
                        "<strong>" +
                        String(entry.seriesName || title || "value") +
                        ":</strong> " +
                        formatTooltipValue(entry.value)
                    );
                  });
                  return lines.join("<br/>");
                },
              },
            grid: { left: 64, right: 20, top: 26, bottom: 86 },
            xAxis: {
                type: "category",
                name: xAxisLabel,
                data: subset.map((row) => String(row.x)),
                axisLabel: { interval: 0, rotate: 34, color: theme.axisText },
              },
            yAxis: { type: "value", name: yAxisLabel, axisLabel: { color: theme.axisText } },
            series: [seriesEntry],
          };
          mount.chart.setOption(ensureReadableAxes(option, mount), true);
          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        function renderScatter(mount, rows, xField, yField, colorField, sizeField) {
          const theme = currentChartTheme();
          const subset = rows
            .map((row) => {
              const x = toFiniteNumberOrNull(row[xField]);
              const y = toFiniteNumberOrNull(row[yField]);
              const c = colorField ? toFiniteNumberOrNull(row[colorField]) : null;
              const s = sizeField ? toFiniteNumberOrNull(row[sizeField]) : null;
              if (x === null || y === null) {
                return null;
              }
              return { x: x, y: y, c: c, s: s };
            })
            .filter((row) => row !== null)
            .slice(0, 15000);

          if (!subset.length) {
            return false;
          }

          const dataPoints = subset.map((row) => [row.x, row.y, row.c, row.s]);
          const colorValues = subset
            .map((row) => row.c)
            .filter((value) => value !== null)
            .sort((left, right) => left - right);
          const colorMin = colorValues.length ? colorValues[0] : 0;
          const colorMaxRaw = colorValues.length ? colorValues[colorValues.length - 1] : 1;
          const colorMax = colorMaxRaw > colorMin ? colorMaxRaw : colorMin + 1;
          const topPercentileThreshold = colorValues.length
            ? colorValues[Math.max(0, Math.floor(colorValues.length * 0.95) - 1)]
            : null;
          const topPercentilePoints =
            topPercentileThreshold === null
              ? []
              : subset
                  .filter((row) => row.c !== null && row.c >= topPercentileThreshold)
                  .map((row) => [row.x, row.y, row.c, row.s]);

          const visualMap = colorField
            ? {
                min: colorMin,
                max: colorMax,
                dimension: 2,
                orient: "horizontal",
                left: "center",
                bottom: 6,
                calculable: true,
                inRange: {
                  color: [theme.volumeBar, theme.primaryLine, theme.alertLower],
                },
              }
            : null;

          const option = {
            animation: false,
            tooltip: {
                formatter: (params) => {
                  if (!Array.isArray(params.value)) {
                    return "";
                  }
                  return (
                    "<strong>x:</strong> " +
                    toNumber(params.value[0]).toFixed(4) +
                    "<br/><strong>y:</strong> " +
                    toNumber(params.value[1]).toFixed(4)
                  );
                },
              },
            grid: { left: 62, right: 24, top: 24, bottom: colorField ? 80 : 44 },
            xAxis: { type: "value", name: humanizeFieldName(xField) },
            yAxis: { type: "value", name: humanizeFieldName(yField) },
            visualMap: visualMap,
            series: [
                {
                  type: "scatter",
                  data: dataPoints,
                  symbolSize: (value) => {
                    if (!sizeField || value[3] === null) {
                      return 7;
                    }
                    return Math.max(5, Math.min(18, Math.sqrt(Math.max(1, toNumber(value[3])))));
                  },
                  itemStyle: { color: colorField ? undefined : theme.scatterDefault, opacity: 0.74 },
                },
              ],
          };
          if (topPercentilePoints.length) {
            option.series.push({
              name: "Top-percentile anomalies",
              type: "scatter",
              data: topPercentilePoints,
              symbolSize: (value) => {
                if (!sizeField || value[3] === null) {
                  return 9;
                }
                return Math.max(7, Math.min(20, Math.sqrt(Math.max(1, toNumber(value[3]))) + 2));
              },
              tooltip: { show: false },
              itemStyle: {
                color: "rgba(0,0,0,0)",
                borderColor: theme.alertLower,
                borderWidth: 1.8,
                opacity: 1,
              },
              z: 4,
            });
          }

          mount.chart.setOption(ensureReadableAxes(option, mount), true);

          mount.isTimeSeries = false;
          mount.isAbsoluteTime = false;
          return true;
        }

        function renderAutoChart(mount, rows) {
          if (!rows.length) {
            return false;
          }

          if (mount.chartId === "procon_swings_shift_heatmap") {
            return renderShiftHeatmap(mount, rows);
          }
          if (mount.chartId === "procon_swings_day_hour_heatmap") {
            return renderDayHourHeatmap(mount, rows, "pro_rate");
          }
          if (mount.chartId === "baseline_day_hour_volume") {
            return renderDayHourHeatmap(mount, rows, "n_total");
          }
          if (mount.chartId === "off_hours_day_hour_heatmap") {
            return renderDayHourHeatmap(mount, rows, "pro_rate");
          }
          if (mount.chartId === "off_hours_date_hour_pro_heatmap") {
            return renderDateHourHeatmap(mount, rows, "pro_rate", "Pro rate", {
              scaleMode: "rate_diverging",
              force24HourSlots: true,
            });
          }
          if (mount.chartId === "off_hours_date_hour_primary_residual_heatmap") {
            return renderDateHourHeatmap(
              mount,
              rows,
              "z_score_primary",
              "Primary z-score",
              {
                scaleMode: "diverging",
                divergingPositiveWarm: true,
                force24HourSlots: true,
                highlightOffHoursAxis: true,
                offHoursAxisThreshold: 0.5,
              }
            );
          }
          if (mount.chartId === "off_hours_date_hour_volume_heatmap") {
            return renderDateHourHeatmap(mount, rows, "n_total", "Submission count", {
              scaleMode: "volume",
              force24HourSlots: true,
              showMissingOverlay: true,
            });
          }
          if (mount.chartId === "off_hours_funnel_plot") {
            return renderOffHoursFunnel(mount, rows);
          }
          if (mount.chartId === "off_hours_primary_flag_channels") {
            return renderSimpleBar(
              mount,
              rows,
              "channel_label",
              "count",
              "Window count"
            );
          }
          if (mount.chartId === "off_hours_model_fit_diagnostics") {
            return renderSimpleBar(
              mount,
              rows,
              "bucket_minutes",
              "model_fit_available_fraction",
              "Model-available fraction"
            );
          }

          const timeOverrides = {
            baseline_volume_pro_rate: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "pro_rate",
              lineLow: "pro_rate_wilson_low",
              lineHigh: "pro_rate_wilson_high",
              comparatorMetric: "overall_pro_rate",
              lowPowerField: "is_low_power",
              lineAxisName: "Pro rate",
              lineMin: 0,
              lineMax: 1,
            },
            procon_swings_hero_bucket_trend: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "pro_rate",
              lineLow: "pro_rate_wilson_low",
              lineHigh: "pro_rate_wilson_high",
              lowPowerField: "is_low_power",
              flaggedField: "is_flagged",
              extraLines: ["baseline_pro_rate", "stable_lower", "stable_upper"],
              comparatorMetric: "overall_pro_rate",
              lineAxisName: "Pro rate",
              lineMin: 0,
              lineMax: 1,
            },
            changepoints_hero_timeline: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "pro_rate",
              lineLow: "pro_rate_wilson_low",
              lineHigh: "pro_rate_wilson_high",
              lowPowerField: "is_low_power",
              flaggedField: "is_changepoint",
              lineAxisName: "Pro rate",
              lineMin: 0,
              lineMax: 1,
            },
            off_hours_control_timeline: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "pro_rate",
              lineLow: "pro_rate_wilson_low",
              lineHigh: "pro_rate_wilson_high",
              lowPowerField: "is_low_power",
              flaggedField: "is_primary_alert_window",
              inferentialWindowField: "is_alert_off_hours_window",
              sparseWhenLowSupport: true,
              sparseMinTestedPoints: 8,
              sparseMinTestedShare: 0.35,
              runOverlayField: "is_primary_alert_window",
              extraLines: [
                "expected_pro_rate_primary",
                "control_low_95_primary",
                "control_high_95_primary",
                "expected_pro_rate_day",
              ],
              lineAxisName: "Pro rate",
              lineMin: 0,
              lineMax: 1,
            },
            off_hours_primary_residual_timeline: {
              timeField: "bucket_start",
              barField: "n_known",
              lineField: "z_score_primary",
              lowPowerField: "is_low_power",
              flaggedField: "is_primary_alert_window",
              inferentialWindowField: "is_alert_off_hours_window",
              sparseWhenLowSupport: true,
              sparseMinTestedPoints: 8,
              sparseMinTestedShare: 0.35,
              runOverlayField: "is_primary_alert_window",
              extraLines: ["z_score_day", "z_ref_zero", "z_ref_pos3", "z_ref_neg3"],
              barAxisName: "Known pro+con",
              lineAxisName: "Primary z-score",
            },
            rare_names_unique_ratio: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "unique_ratio",
              extraLines: ["threshold_unique_ratio"],
              lowPowerField: "is_low_power",
              lineAxisName: "Unique ratio",
              lineMin: 0,
              lineMax: 1,
            },
            org_anomalies_blank_rate: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "blank_org_rate",
              lineLow: "blank_org_rate_wilson_low",
              lineHigh: "blank_org_rate_wilson_high",
              extraLines: ["pro_blank_org_rate", "con_blank_org_rate"],
              lowPowerField: "is_low_power",
              lineAxisName: "Blank org rate",
              lineMin: 0,
              lineMax: 1,
            },
            voter_registry_match_rates: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "match_rate",
              lineLow: "match_rate_wilson_low",
              lineHigh: "match_rate_wilson_high",
              extraLines: [
                "exact_match_rate",
                "strong_fuzzy_match_rate",
                "weak_fuzzy_match_rate",
                "mean_match_confidence",
              ],
              lowPowerField: "is_low_power",
              lineAxisName: "Match rate",
              lineMin: 0,
              lineMax: 1,
            },
            multivariate_score_timeline: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "anomaly_score",
              extraLines: ["anomaly_score_percentile"],
              lowPowerField: "is_low_power",
              lineAxisName: "Anomaly score",
            },
            procon_swings_direction_runs: {
              timeField: "start_bucket",
              barField: "run_length_buckets",
              lineField: "mean_abs_delta_pro_rate",
              lineAxisName: "Mean abs delta",
              barAxisName: "Run length",
            },
            composite_score_timeline: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "composite_score",
              lowPowerField: "is_low_power",
              lineAxisName: "Composite score",
            },
            duplicates_exact_bucket_concentration: {
              timeField: "bucket_start",
              barField: "n",
              lineField: null,
              barAxisName: "Duplicate count",
            },
            duplicates_near_cluster_timeline: {
              timeField: "first_seen",
              barField: "cluster_size",
              lineField: "n_records",
              lineAxisName: "Records",
              barAxisName: "Cluster size",
            },
            sortedness_bucket_ratio: {
              timeField: "bucket_start",
              barField: "n_records",
              lineField: "is_alphabetical",
              lineAxisName: "Alphabetical (0/1)",
              lineMin: 0,
              lineMax: 1,
            },
            org_anomalies_position_rates: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "blank_org_rate",
              lineLow: "blank_org_rate_wilson_low",
              lineHigh: "blank_org_rate_wilson_high",
              lowPowerField: "is_low_power",
              lineAxisName: "Blank org rate",
              lineMin: 0,
              lineMax: 1,
            },
            voter_registry_position_buckets: {
              timeField: "bucket_start",
              barField: "n_total",
              lineField: "match_rate",
              lineLow: "match_rate_wilson_low",
              lineHigh: "match_rate_wilson_high",
              lowPowerField: "is_low_power",
              lineAxisName: "Match rate",
              lineMin: 0,
              lineMax: 1,
            },
            rare_names_singletons: {
              timeField: "first_seen",
              barField: "n_pro",
              lineField: "n_con",
              lineAxisName: "Counts",
              barAxisName: "Pro count",
            },
            rare_names_rarity_timeline: {
              timeField: "minute_bucket",
              barField: "n_total",
              lineField: "rarity_median",
              extraLines: ["rarity_p95"],
              lowPowerField: "is_low_power",
              lineAxisName: "Rarity",
            },
            bursts_hero_timeline: {
              timeField: "start_minute",
              barField: "observed_count",
              lineField: "rate_ratio",
              lineAxisName: "Rate ratio",
              barAxisName: "Observed count",
            },
            bursts_composition_shift: {
              timeField: "start_minute",
              barField: "observed_count",
              lineField: "abs_delta_pro_rate",
              lowPowerField: "is_low_power",
              lineAxisName: "Abs pro-rate delta",
              barAxisName: "Observed count",
              lineMin: 0,
            },
          };

          if (Object.prototype.hasOwnProperty.call(timeOverrides, mount.chartId)) {
            return renderTimeBarLine(mount, rows, timeOverrides[mount.chartId]);
          }

          if (mount.chartId === "multivariate_feature_projection") {
            return renderScatter(mount, rows, "log_n_total", "pro_rate", "anomaly_score", "n_total");
          }
          if (mount.chartId === "multivariate_top_buckets") {
            return renderScatter(mount, rows, "n_total", "anomaly_score", "anomaly_score_percentile", "n_total");
          }
          if (mount.chartId === "duplicates_near_similarity") {
            return renderSimpleBar(mount, rows, "left_display_name", "similarity", "similarity");
          }
          if (mount.chartId === "composite_evidence_flags") {
            return renderSimpleBar(mount, rows, "flag", "count", "count");
          }
          if (mount.chartId === "off_hours_hourly_profile") {
            return renderSimpleBar(mount, rows, "hour", "n_total", "submissions");
          }
          if (mount.chartId === "off_hours_summary_compare") {
            return renderSimpleBar(mount, rows, "off_hours", "off_hours_pro_rate", "pro rate");
          }
          if (mount.chartId === "periodicity_clockface") {
            return renderSimpleBar(mount, rows, "minute_of_hour", "n_events", "events");
          }
          if (mount.chartId === "periodicity_autocorr") {
            return renderSimpleBar(mount, rows, "lag_minutes", "autocorr", "autocorr");
          }
          if (mount.chartId === "periodicity_spectrum") {
            return renderSimpleBar(mount, rows, "period_minutes", "power", "power");
          }
          if (mount.chartId === "periodicity_rolling_fano") {
            return renderSimpleBar(
              mount,
              rows,
              "window_minutes",
              "median_fano_factor",
              "median fano factor"
            );
          }
          if (mount.chartId === "baseline_top_names") {
            return renderSimpleBar(mount, rows, "display_name", "n", "count");
          }
          if (mount.chartId === "baseline_name_length_distribution") {
            return renderSimpleBar(mount, rows, "name_length", "n_names", "names");
          }
          if (mount.chartId === "bursts_significance_by_window") {
            return renderSimpleBar(mount, rows, "window_minutes", "n_significant", "significant windows");
          }
          if (mount.chartId === "bursts_null_distribution") {
            return renderSimpleBar(mount, rows, "iteration", "max_window_count", "max count");
          }
          if (mount.chartId === "procon_swings_null_distribution") {
            return renderSimpleBar(mount, rows, "iteration", "max_abs_delta_pro_rate", "max abs delta");
          }
          if (mount.chartId === "changepoints_magnitude") {
            return renderSimpleBar(mount, rows, "change_index", "abs_delta", "abs delta");
          }
          if (mount.chartId === "changepoints_hour_hist") {
            return renderSimpleBar(mount, rows, "change_hour", "n_changes", "changes");
          }
          if (mount.chartId === "duplicates_exact_top_names") {
            return renderSimpleBar(mount, rows, "display_name", "n", "count");
          }
          if (mount.chartId === "duplicates_exact_position_switch") {
            return renderSimpleBar(mount, rows, "display_name", "n", "count");
          }
          if (mount.chartId === "duplicates_near_cluster_size") {
            return renderSimpleBar(mount, rows, "cluster_size", "n_clusters", "clusters");
          }
          if (mount.chartId === "duplicates_near_time_concentration") {
            return renderSimpleBar(
              mount,
              rows,
              "cluster_id",
              "peak_bucket_fraction",
              "peak bucket fraction"
            );
          }
          if (mount.chartId === "sortedness_bucket_summary") {
            return renderSimpleBar(mount, rows, "bucket_minutes", "alphabetical_ratio", "alphabetical ratio");
          }
          if (mount.chartId === "sortedness_kendall_tau_summary") {
            return renderSimpleBar(
              mount,
              rows,
              "bucket_minutes",
              "mean_abs_kendall_tau",
              "mean abs kendall tau"
            );
          }
          if (mount.chartId === "sortedness_minute_spikes") {
            return renderSimpleBar(mount, rows, "minute_bucket", "n_records", "records");
          }
          if (mount.chartId === "rare_names_weird_scores") {
            return renderSimpleBar(mount, rows, "sample_name", "weirdness_score", "weirdness");
          }
          if (mount.chartId === "org_anomalies_bursts") {
            return renderSimpleBar(mount, rows, "minute_bucket", "n", "count");
          }
          if (mount.chartId === "org_anomalies_top_orgs") {
            return renderSimpleBar(mount, rows, "organization_clean", "n", "count");
          }
          if (mount.chartId === "voter_registry_match_by_position") {
            return renderSimpleBar(mount, rows, "position_normalized", "match_rate", "match rate");
          }
          if (mount.chartId === "voter_registry_unmatched_names") {
            return renderSimpleBar(mount, rows, "canonical_name", "n_records", "count");
          }
          if (mount.chartId === "voter_registry_match_tiers") {
            return renderSimpleBar(mount, rows, "match_tier", "record_rate", "record rate");
          }
          if (mount.chartId === "procon_swings_time_of_day_profile") {
            return renderSimpleBar(mount, rows, "slot_start_minute", "pro_rate", "pro rate");
          }
          if (mount.chartId === "composite_high_priority") {
            return renderSimpleBar(mount, rows, "minute_bucket", "composite_score", "score");
          }

          const timeField = inferTimeField(rows);
          if (timeField) {
            const fields = numericFields(rows[0]);
            const lineField = fields.find((field) => field !== "bucket_minutes") || null;
            if (lineField) {
              return renderTimeBarLine(mount, rows, {
                timeField: timeField,
                barField: null,
                lineField: lineField,
                lineAxisName: lineField,
              });
            }
          }

          const row = rows[0] || {};
          const numeric = numericFields(row);
          const stringField = Object.keys(row).find(
            (key) => typeof row[key] === "string" || typeof row[key] === "boolean"
          );

          if (stringField && numeric.length) {
            return renderSimpleBar(mount, rows, stringField, numeric[0], numeric[0]);
          }

          if (numeric.length >= 2) {
            return renderScatter(mount, rows, numeric[0], numeric[1], null, null);
          }

          return false;
        }

        function humanizeFieldName(field) {
          return String(field || "")
            .replace(/_/g, " ")
            .replace(/\s+/g, " ")
            .trim();
        }

        function fallbackColumnDescription(field) {
          const normalized = String(field || "").trim();
          const label = humanizeFieldName(normalized);
          if (!normalized) {
            return "Column value from detector output.";
          }
          if (normalized.startsWith("n_")) {
            return "Count of " + humanizeFieldName(normalized.slice(2)) + " in this row grouping.";
          }
          if (normalized.endsWith("_rate")) {
            return "Proportion metric for " + label + " on a 0 to 1 scale.";
          }
          if (normalized.endsWith("_ratio")) {
            return "Ratio metric for " + label + ".";
          }
          if (normalized.endsWith("_wilson_low")) {
            return "Lower Wilson confidence bound for " + humanizeFieldName(normalized.replace(/_wilson_low$/, "")) + ".";
          }
          if (normalized.endsWith("_wilson_high")) {
            return "Upper Wilson confidence bound for " + humanizeFieldName(normalized.replace(/_wilson_high$/, "")) + ".";
          }
          if (normalized.startsWith("is_")) {
            return "Boolean indicator for " + label + ".";
          }
          if (
            normalized.includes("minute") ||
            normalized.includes("hour") ||
            normalized.endsWith("_time") ||
            normalized.endsWith("_date")
          ) {
            return "Time coordinate for " + label + ".";
          }
          return "Detector output field for " + label + ".";
        }

        function tableColumnsFromRows(rows) {
          const columns = [];
          const seen = new Set();
          (Array.isArray(rows) ? rows : []).forEach((row) => {
            Object.keys(row || {}).forEach((field) => {
              if (seen.has(field)) {
                return;
              }
              seen.add(field);
              columns.push(field);
            });
          });
          return columns;
        }

        function renderColumnGlossary(parent, tableKey, rows) {
          if (!parent) {
            return;
          }
          const fields = tableColumnsFromRows(rows);
          if (!fields.length) {
            return;
          }
          const docsByTable = tableKey && tableColumnDocs[tableKey] ? tableColumnDocs[tableKey] : {};

          const glossary = document.createElement("section");
          glossary.className = "column-glossary";

          const title = document.createElement("p");
          title.className = "column-glossary-title";
          title.innerHTML = "<strong>Column glossary:</strong> what each field means in this table.";
          glossary.appendChild(title);

          const list = document.createElement("dl");
          list.className = "column-glossary-grid";
          fields.forEach((field) => {
            const wrapper = document.createElement("div");
            wrapper.className = "column-glossary-item";

            const key = document.createElement("dt");
            const code = document.createElement("code");
            code.textContent = field;
            key.appendChild(code);

            const value = document.createElement("dd");
            value.textContent = docsByTable[field] || fallbackColumnDescription(field);

            wrapper.appendChild(key);
            wrapper.appendChild(value);
            list.appendChild(wrapper);
          });
          glossary.appendChild(list);
          parent.appendChild(glossary);
        }

        function fallbackTableHelp(tableKey, rows) {
          const columns = tableColumnsFromRows(rows);
          const hasRates = columns.some((name) => name.endsWith("_rate") || name.includes("ratio"));
          const hasCounts = columns.some((name) => name.startsWith("n_") || name === "count" || name === "n");
          const hasTime = columns.some(
            (name) =>
              name.includes("minute") ||
              name.includes("hour") ||
              name.includes("bucket") ||
              name.includes("date")
          );
          const context = [];
          if (hasRates) {
            context.push("rate/proportion fields");
          }
          if (hasCounts) {
            context.push("count/volume fields");
          }
          if (hasTime) {
            context.push("time keys");
          }
          const contextText = context.length ? context.join(", ") : "detector-specific fields";
          const tableLabel = humanizeFieldName((tableKey || "table").replace(/\./g, " "));

          return {
            what_is_this:
              "This table preview shows row-level values for " +
              tableLabel +
              ", including " +
              contextText +
              ". It is the direct evidence layer behind chart summaries and is the best place to verify exact records.",
            why_it_matters:
              "The table is the audit source of truth behind chart aggregates. It confirms whether chart patterns are backed by real support and helps catch low-power or contradictory rows that can mislead visual interpretation.",
            how_to_interpret:
              "Sort and filter around flagged windows or categories, then compare neighboring rows to distinguish random outliers from consistent structure. Read identifier/time keys first, then volume and rate fields, then flags and derived scores.",
            what_to_look_for:
              "Look for multiple indicators moving together, especially when elevated values persist across adjacent rows with adequate support. Repeated combinations are stronger evidence than one extreme field in one row.",
            momentary_high_low:
              "A single high/low row can be event noise or low-support variance; verify in nearby rows and linked charts. Momentary highs often map to reminders or queue releases, while momentary lows often map to normal lulls or ingest timing.",
            extended_high_low:
              "Sustained high/low runs across many rows suggest process-level behavior and deserve higher confidence. Extended highs can indicate durable mobilization or process skew; extended lows can indicate reduced activity or missing data segments.",
            column_highlight:
              "Primary columns in preview: " +
              (columns.slice(0, 6).join(", ") || "none") +
              ". Use the glossary below for per-column definitions before drawing conclusions.",
          };
        }

        function renderTableHelpCard(parent, tableKey, rows) {
          if (!parent) {
            return;
          }
          const explicit = tableKey && tableHelpDocs[tableKey] ? tableHelpDocs[tableKey] : null;
          const help = explicit || fallbackTableHelp(tableKey, rows);

          const details = document.createElement("details");
          details.className = "table-help-card";

          const summary = document.createElement("summary");
          summary.textContent = "Table Help";
          details.appendChild(summary);

          const body = document.createElement("div");
          body.className = "table-help-body";

          const fields = [
            ["What is this?", help.what_is_this],
            ["Why this data matters", help.why_it_matters],
            ["How do I interpret this data?", help.how_to_interpret],
            ["What do I look for?", help.what_to_look_for],
            ["What could a momentary high/low mean?", help.momentary_high_low],
            ["What could an extended high/low mean?", help.extended_high_low],
            ["Column focus", help.column_highlight],
          ];
          fields.forEach((entry) => {
            if (!entry[1]) {
              return;
            }
            const p = document.createElement("p");
            p.innerHTML = "<strong>" + entry[0] + ":</strong> " + entry[1];
            body.appendChild(p);
          });

          renderColumnGlossary(body, tableKey, rows);
          details.appendChild(body);
          parent.appendChild(details);
        }

        const tableSemanticClassNames = [
          "table-cell-semantic-alert",
          "table-cell-semantic-warn",
          "table-cell-semantic-context",
        ];
        const offHoursSummaryAlertColumns = new Set([
          "off_hours_windows_primary_alert",
          "off_hours_windows_primary_alert_fraction",
          "off_hours_primary_alert_run_count",
          "off_hours_primary_alert_max_run_minutes",
          "off_hours_windows_significant_primary",
          "off_hours_windows_significant_primary_upper",
          "off_hours_windows_significant_primary_two_sided",
          "off_hours_windows_below_primary_control_998",
          "off_hours_windows_above_primary_control_998",
          "off_hours_windows_primary_flag_any",
          "off_hours_windows_primary_flag_any_fraction",
          "off_hours_windows_primary_flag_both",
          "off_hours_windows_primary_flag_both_fraction",
        ]);
        const offHoursSummaryLowPowerColumns = new Set([
          "off_hours_windows_alert_eligible_low_power",
          "off_hours_windows_alert_eligible_low_power_fraction",
          "off_hours_is_low_power",
          "on_hours_is_low_power",
        ]);
        const offHoursSummaryContextColumns = new Set([
          "off_hours_windows_model_available",
          "off_hours_windows_alert_eligible_tested_fraction",
        ]);

        function clearSemanticCellClasses(element) {
          if (!element) {
            return;
          }
          tableSemanticClassNames.forEach((name) => element.classList.remove(name));
        }

        function semanticClassForTableCell(tableKey, field, value) {
          const key = String(tableKey || "").trim();
          const column = String(field || "").trim();
          if (!key || !column) {
            return "";
          }

          const numeric = toFiniteNumberOrNull(value);
          const truthy = toBool(value);
          const valueText = String(value === null || value === undefined ? "" : value)
            .trim()
            .toLowerCase();

          if (key === "off_hours.off_hours_summary") {
            if (offHoursSummaryAlertColumns.has(column)) {
              if (numeric !== null) {
                return numeric > 0 ? "table-cell-semantic-alert" : "";
              }
              return truthy ? "table-cell-semantic-alert" : "";
            }
            if (offHoursSummaryLowPowerColumns.has(column)) {
              if (numeric !== null) {
                return numeric > 0 ? "table-cell-semantic-warn" : "";
              }
              return truthy ? "table-cell-semantic-warn" : "";
            }
            if (offHoursSummaryContextColumns.has(column)) {
              if (numeric !== null) {
                return numeric > 0 ? "table-cell-semantic-context" : "";
              }
              if (!valueText) {
                return "";
              }
              if (valueText.includes("unavailable")) {
                return "table-cell-semantic-alert";
              }
              return valueText === "available" || valueText === "true"
                ? "table-cell-semantic-context"
                : "";
            }
            if (column === "primary_baseline_method" || column === "primary_model_fit_method") {
              if (!valueText) {
                return "";
              }
              if (
                valueText.includes("unavailable") ||
                valueText.includes("failure") ||
                valueText.includes("none")
              ) {
                return "table-cell-semantic-alert";
              }
              return "";
            }
            if (column === "primary_model_fit_converged") {
              if (numeric === null) {
                return "table-cell-semantic-warn";
              }
              return numeric >= 1 ? "table-cell-semantic-context" : "table-cell-semantic-alert";
            }
          }

          if (key === "off_hours.model_fit_diagnostics") {
            if (column === "model_fit_available_fraction") {
              if (numeric === null) {
                return "table-cell-semantic-warn";
              }
              if (numeric >= 0.8) {
                return "table-cell-semantic-context";
              }
              if (numeric >= 0.4) {
                return "table-cell-semantic-warn";
              }
              return "table-cell-semantic-alert";
            }
            if (column === "model_fit_converged") {
              if (numeric === null) {
                return "table-cell-semantic-warn";
              }
              return numeric >= 1 ? "table-cell-semantic-context" : "table-cell-semantic-alert";
            }
            if (column === "model_fit_method") {
              if (!valueText) {
                return "";
              }
              if (valueText.includes("unavailable") || valueText.includes("failure")) {
                return "table-cell-semantic-alert";
              }
              return "";
            }
          }

          return "";
        }

        function mountTable(container, rows, options) {
          const dataset = Array.isArray(rows) ? rows : [];
          if (!container || !dataset.length) {
            if (container) {
              container.innerHTML = "";
            }
            return null;
          }
          const tableKey =
            options && typeof options.tableKey === "string" ? options.tableKey.trim() : "";
          const tableOptions = Object.assign({}, options || {});
          if (Object.prototype.hasOwnProperty.call(tableOptions, "tableKey")) {
            delete tableOptions.tableKey;
          }

          const columns = Array.from(
            new Set(dataset.flatMap((row) => Object.keys(row || {})))
          ).map((field) => ({
            title: field,
            field: field,
            headerFilter: "input",
            formatter: (cell) => {
              const value = cell && typeof cell.getValue === "function" ? cell.getValue() : null;
              const element = cell && typeof cell.getElement === "function" ? cell.getElement() : null;
              clearSemanticCellClasses(element);
              const semanticClass = semanticClassForTableCell(tableKey, field, value);
              if (semanticClass && element) {
                element.classList.add(semanticClass);
              }
              if (value === null || value === undefined) {
                return "";
              }
              return String(value);
            },
          }));

          if (hasTabulator) {
            container.innerHTML = "";
            const table = new window.Tabulator(
              container,
              Object.assign(
                {
                  data: dataset,
                  columns: columns,
                  layout: "fitDataStretch",
                  reactiveData: false,
                  pagination: true,
                  paginationSize: 8,
                  paginationCounter: "rows",
                  maxHeight: "340px",
                  placeholder: "No rows",
                  movableColumns: true,
                },
                tableOptions
              )
            );
            return {
              kind: "tabulator",
              table: table,
              data: dataset,
            };
          }

          const table = document.createElement("table");
          table.style.borderCollapse = "collapse";
          table.style.width = "100%";

          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");
          columns.forEach((column) => {
            const th = document.createElement("th");
            th.textContent = column.title;
            th.style.border = "1px solid #cbd5e1";
            th.style.padding = "0.35rem 0.45rem";
            th.style.background = "#f8fafc";
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          const rowClickHandler =
            options && typeof options.rowClick === "function" ? options.rowClick : null;
          dataset.forEach((row) => {
            const tr = document.createElement("tr");
            columns.forEach((column) => {
              const td = document.createElement("td");
              const value = row[column.field];
              td.textContent = value === null || value === undefined ? "" : String(value);
              const semanticClass = semanticClassForTableCell(tableKey, column.field, value);
              if (semanticClass) {
                td.classList.add(semanticClass);
              }
              td.style.border = "1px solid #e2e8f0";
              td.style.padding = "0.3rem 0.45rem";
              tr.appendChild(td);
            });
            if (rowClickHandler) {
              tr.style.cursor = "pointer";
              tr.tabIndex = 0;
              tr.addEventListener("click", (event) => {
                rowClickHandler(event, {
                  getData: () => row,
                  getElement: () => tr,
                });
              });
              tr.addEventListener("keydown", (event) => {
                if (event.key === "Enter" || event.key === " ") {
                  event.preventDefault();
                  rowClickHandler(event, {
                    getData: () => row,
                    getElement: () => tr,
                  });
                }
              });
            }
            tbody.appendChild(tr);
          });
          table.appendChild(tbody);

          container.innerHTML = "";
          container.appendChild(table);
          return {
            kind: "html",
            table: null,
            data: dataset,
          };
        }

        function withinWindow(timestamp, start, end) {
          return timestamp !== null && start !== null && end !== null && timestamp >= start && timestamp <= end;
        }

        function overlapsWindow(startA, endA, startB, endB) {
          return startA !== null && endA !== null && startB !== null && endB !== null && startA <= endB && endA >= startB;
        }

        function getWindowSpanRows(windowRow) {
          const start = toEpochMillis(windowRow ? windowRow.start_time : null);
          const end = toEpochMillis(windowRow ? windowRow.end_time : null);
          if (start === null || end === null) {
            return [];
          }

          const baselineRows = getChartRows("baseline_volume_pro_rate")
            .filter((row) => withinWindow(toEpochMillis(row.minute_bucket), start, end))
            .map((row) =>
              Object.assign({ source: "baseline_volume_pro_rate", source_time: row.minute_bucket }, row)
            );
          const burstRows = getChartRows("bursts_hero_timeline")
            .filter((row) =>
              overlapsWindow(
                toEpochMillis(row.start_minute),
                toEpochMillis(row.end_minute),
                start,
                end
              )
            )
            .map((row) =>
              Object.assign({ source: "bursts_hero_timeline", source_time: row.start_minute }, row)
            );
          const swingRows = getChartRows("procon_swings_hero_bucket_trend")
            .filter((row) => withinWindow(toEpochMillis(row.bucket_start), start, end))
            .map((row) =>
              Object.assign(
                { source: "procon_swings_hero_bucket_trend", source_time: row.bucket_start },
                row
              )
            );
          const duplicateRows = getChartRows("duplicates_exact_bucket_concentration")
            .filter((row) => withinWindow(toEpochMillis(row.bucket_start), start, end))
            .map((row) =>
              Object.assign(
                { source: "duplicates_exact_bucket_concentration", source_time: row.bucket_start },
                row
              )
            );
          const rarityRows = getChartRows("rare_names_rarity_timeline")
            .filter((row) => withinWindow(toEpochMillis(row.minute_bucket), start, end))
            .map((row) =>
              Object.assign({ source: "rare_names_rarity_timeline", source_time: row.minute_bucket }, row)
            );

          return baselineRows
            .concat(burstRows, swingRows, duplicateRows, rarityRows)
            .sort((left, right) => {
              const leftTime = toEpochMillis(left.source_time);
              const rightTime = toEpochMillis(right.source_time);
              if (leftTime === null && rightTime === null) {
                return 0;
              }
              if (leftTime === null) {
                return 1;
              }
              if (rightTime === null) {
                return -1;
              }
              return leftTime - rightTime;
            });
        }

        function getWindowDupRows(windowRow) {
          const start = toEpochMillis(windowRow ? windowRow.start_time : null);
          const end = toEpochMillis(windowRow ? windowRow.end_time : null);
          if (start === null || end === null) {
            return [];
          }
          const rows = getChartRows("duplicates_exact_bucket_concentration");
          return rows.filter((row) => {
            const timestamp = toEpochMillis(row.bucket_start);
            return withinWindow(timestamp, start, end);
          });
        }

        function getWindowClusterRows(windowRow) {
          const start = toEpochMillis(windowRow ? windowRow.start_time : null);
          const end = toEpochMillis(windowRow ? windowRow.end_time : null);
          if (start === null || end === null) {
            return [];
          }
          const rows = getChartRows("duplicates_near_cluster_timeline");
          return rows.filter((row) => {
            const firstSeen = toEpochMillis(row.first_seen);
            const lastSeen = toEpochMillis(row.last_seen);
            if (firstSeen === null || lastSeen === null) {
              return false;
            }
            return overlapsWindow(firstSeen, lastSeen, start, end);
          });
        }

        function getRunsAndWeirdnessRows(windowRow, causativeRows) {
          const series = Array.isArray(causativeRows) ? causativeRows : [];
          let longestProHeavy = 0;
          let longestConHeavy = 0;
          let currentPro = 0;
          let currentCon = 0;
          series.forEach((row) => {
            const proRate = toFiniteNumberOrNull(row.pro_rate);
            if (proRate === null) {
              currentPro = 0;
              currentCon = 0;
              return;
            }
            if (proRate >= 0.5) {
              currentPro += 1;
              currentCon = 0;
            } else {
              currentCon += 1;
              currentPro = 0;
            }
            longestProHeavy = Math.max(longestProHeavy, currentPro);
            longestConHeavy = Math.max(longestConHeavy, currentCon);
          });

          const start = toEpochMillis(windowRow ? windowRow.start_time : null);
          const end = toEpochMillis(windowRow ? windowRow.end_time : null);
          const rarityRows = getChartRows("rare_names_rarity_timeline");
          const inWindow = rarityRows.filter((row) => {
            const timestamp = toEpochMillis(row.minute_bucket);
            return withinWindow(timestamp, start, end);
          });
          const outWindow = rarityRows.filter((row) => {
            const timestamp = toEpochMillis(row.minute_bucket);
            return (
              timestamp !== null &&
              start !== null &&
              end !== null &&
              !withinWindow(timestamp, start, end)
            );
          });
          const mean = (rows) => {
            const values = rows
              .map((row) => toFiniteNumberOrNull(row.rarity_mean))
              .filter((value) => value !== null);
            if (!values.length) {
              return null;
            }
            return values.reduce((acc, value) => acc + value, 0) / values.length;
          };
          const weirdnessIn = mean(inWindow);
          const weirdnessOut = mean(outWindow);
          const weirdnessDelta =
            weirdnessIn !== null && weirdnessOut !== null ? weirdnessIn - weirdnessOut : null;

          return [
            {
              metric: "longest_pro_heavy_run_buckets",
              value: longestProHeavy,
            },
            {
              metric: "longest_con_heavy_run_buckets",
              value: longestConHeavy,
            },
            {
              metric: "rarity_mean_in_window",
              value: weirdnessIn,
            },
            {
              metric: "rarity_mean_outside_window",
              value: weirdnessOut,
            },
            {
              metric: "rarity_mean_delta_window_minus_outside",
              value: weirdnessDelta,
            },
          ];
        }

        function focusWindowSpan(windowRow) {
          const start = toEpochMillis(windowRow ? windowRow.start_time : null);
          const endRaw = toEpochMillis(windowRow ? windowRow.end_time : null);
          if (start === null || endRaw === null) {
            state.selectedWindowRange = null;
            return;
          }
          const bucketMinutes = toFiniteNumberOrNull(windowRow ? windowRow.bucket_minutes : null);
          const fallbackSpanMs = Math.max(
            60_000,
            Math.round((bucketMinutes !== null ? bucketMinutes : 30) * 60_000)
          );
          const end = endRaw > start ? endRaw : start + fallbackSpanMs;
          state.selectedWindowRange = { start: start, end: end };
          state.cursorX = start;
          updateCursorAcrossTimeCharts();
          scheduleZoomSync(start, end, null, false);
        }

        function renderWindowDrilldown(windowRow) {
          drilldownState.activeWindow = windowRow || null;
          const selectionLabel = document.getElementById("window-drilldown-selection");
          if (selectionLabel) {
            selectionLabel.textContent = windowRow
              ? "Selected window: " + String(windowRow.window_id || "") + " (" + formatDateRange(windowRow.start_time, windowRow.end_time) + ")"
              : "No window selected.";
          }

          const causativeRows = windowRow ? getWindowSpanRows(windowRow) : [];
          const dupRows = windowRow ? getWindowDupRows(windowRow) : [];
          const clusterRows = windowRow ? getWindowClusterRows(windowRow) : [];
          const runsWeirdnessRows = windowRow ? getRunsAndWeirdnessRows(windowRow, causativeRows) : [];

          const causativeHost = document.getElementById("drilldown-causative-rows-host");
          const dupHost = document.getElementById("drilldown-dup-names-host");
          const clusterHost = document.getElementById("drilldown-clusters-host");
          const runsHost = document.getElementById("drilldown-runs-weirdness-host");
          mountTable(causativeHost, causativeRows, { paginationSize: 12, maxHeight: "330px" });
          mountTable(dupHost, dupRows, { paginationSize: 12, maxHeight: "330px" });
          mountTable(clusterHost, clusterRows, { paginationSize: 12, maxHeight: "330px" });
          mountTable(runsHost, runsWeirdnessRows, { pagination: false, maxHeight: "330px" });
          if (windowRow) {
            focusWindowSpan(windowRow);
          }
        }

        function renderTriageSummary() {
          const view = getActiveTriageView();
          const summary = view.triage_summary || {};
          const setText = (id, value) => {
            const element = document.getElementById(id);
            if (element) {
              element.textContent = String(value);
            }
          };

          if (
            state.activeDedupMode === "side_by_side" &&
            summary.total_submissions_raw !== undefined &&
            summary.total_submissions_exact_row_dedup !== undefined
          ) {
            setText(
              "triage-total-submissions",
              Number(toNumber(summary.total_submissions_raw || 0)).toLocaleString() +
                " -> " +
                Number(toNumber(summary.total_submissions_exact_row_dedup || 0)).toLocaleString()
            );
          } else {
            setText(
              "triage-total-submissions",
              Number(toNumber(summary.total_submissions || 0)).toLocaleString()
            );
          }
          setText(
            "triage-date-range",
            formatDateRange(summary.date_range_start, summary.date_range_end)
          );
          if (
            state.activeDedupMode === "side_by_side" &&
            summary.overall_pro_rate_raw !== undefined &&
            summary.overall_pro_rate_exact_row_dedup !== undefined
          ) {
            setText(
              "triage-overall-procon",
              formatPercent(summary.overall_pro_rate_raw) +
                " -> " +
                formatPercent(summary.overall_pro_rate_exact_row_dedup) +
                " / " +
                formatPercent(summary.overall_con_rate_raw) +
                " -> " +
                formatPercent(summary.overall_con_rate_exact_row_dedup)
            );
          } else {
            setText(
              "triage-overall-procon",
              formatPercent(summary.overall_pro_rate) + " / " + formatPercent(summary.overall_con_rate)
            );
          }

          const tierCounts = summary.window_tier_counts || {};
          setText(
            "triage-top-tier-count",
            Number(toNumber(tierCounts.high || 0)).toLocaleString()
          );
        }

        function renderDataQualityPanel() {
          const summaryHost = document.getElementById("data-quality-summary");
          const warningHost = document.getElementById("data-quality-warning-host");
          const metricsHost = document.getElementById("data-quality-dedup-metrics-host");

          const panelStatus = String(dataQualityPanel.status || "ok");
          const warnings = Array.isArray(dataQualityPanel.warnings) ? dataQualityPanel.warnings : [];
          const metrics = Array.isArray(dataQualityPanel.triage_raw_vs_dedup_metrics)
            ? dataQualityPanel.triage_raw_vs_dedup_metrics
            : [];

          if (summaryHost) {
            summaryHost.classList.toggle("ok", panelStatus === "ok");
            summaryHost.textContent =
              typeof dataQualityPanel.summary === "string" && dataQualityPanel.summary.trim()
                ? dataQualityPanel.summary
                : "Data-quality checks unavailable for this run.";
          }
          if (warningHost) {
            mountTable(warningHost, warnings, { pagination: false, maxHeight: "260px" });
          }
          if (metricsHost) {
            mountTable(metricsHost, metrics, { pagination: false, maxHeight: "260px" });
          }
        }

        function renderCrossHearingComparator() {
          const summaryHost = document.getElementById("cross-hearing-comparator-summary");
          const comparatorHost = document.getElementById("cross-hearing-comparator-host");
          if (!summaryHost && !comparatorHost) {
            return;
          }

          const available = !!(crossHearingBaseline && crossHearingBaseline.available);
          const reportCount = Number(toNumber(crossHearingBaseline.report_count || 0));
          const rowsRaw = Array.isArray(crossHearingBaseline.metric_comparators)
            ? crossHearingBaseline.metric_comparators
            : [];
          const rows = rowsRaw.map((row) => {
            const p10 = toFiniteNumberOrNull(row.band_p10);
            const p50 = toFiniteNumberOrNull(row.band_p50);
            const p90 = toFiniteNumberOrNull(row.band_p90);
            return Object.assign({}, row, {
              percentile_label: formatPercent(row.percentile, 0),
              comparator_band:
                p10 !== null && p50 !== null && p90 !== null
                  ? "p10/p50/p90: " +
                    formatTooltipValue(p10) +
                    " / " +
                    formatTooltipValue(p50) +
                    " / " +
                    formatTooltipValue(p90)
                  : "n/a",
            });
          });

          if (summaryHost) {
            if (available && rows.length) {
              summaryHost.textContent =
                "Compared against " +
                reportCount.toLocaleString() +
                " hearing run(s). Percentiles and p10/p50/p90 bands are corpus-relative.";
            } else {
              const reason =
                typeof crossHearingBaseline.reason === "string" && crossHearingBaseline.reason.trim()
                  ? crossHearingBaseline.reason.trim()
                  : "Run the global baseline aggregator to enable cross-hearing comparisons.";
              summaryHost.textContent = reason;
            }
          }
          if (comparatorHost) {
            mountTable(comparatorHost, rows, { pagination: false, maxHeight: "280px" });
          }
        }

        function applyCrossHearingNameCues(rows) {
          const cueRows = Array.isArray(crossHearingBaseline.top_name_cues)
            ? crossHearingBaseline.top_name_cues
            : [];
          if (!cueRows.length) {
            return rows;
          }
          const cueByCanonical = new Map(
            cueRows
              .filter((row) => row && typeof row.canonical_name === "string")
              .map((row) => [String(row.canonical_name), row])
          );
          return rows.map((row) => {
            const canonical = String((row || {}).canonical_name || "");
            const cue = cueByCanonical.get(canonical);
            if (!cue) {
              return row;
            }
            return Object.assign({}, row, {
              cross_hearing_report_count: Number(toNumber(cue.report_count || 0)),
              cross_hearing_report_share: toFiniteNumberOrNull(cue.report_share),
              cross_hearing_max_n_records: Number(toNumber(cue.max_n_records_across_reports || 0)),
              cross_hearing_max_records_percentile: toFiniteNumberOrNull(
                cue.max_n_records_percentile
              ),
              cross_hearing_recurrent_name: Number(toNumber(cue.report_count || 0)) > 1,
            });
          });
        }

        function applyCrossHearingClusterCues(rows) {
          const cueRows = Array.isArray(crossHearingBaseline.top_cluster_cues)
            ? crossHearingBaseline.top_cluster_cues
            : [];
          if (!cueRows.length) {
            return rows;
          }
          const cueByCluster = new Map(
            cueRows
              .filter((row) => row && typeof row.cluster_id === "string")
              .map((row) => [String(row.cluster_id), row])
          );
          return rows.map((row) => {
            const clusterId = String((row || {}).cluster_id || "");
            const cue = cueByCluster.get(clusterId);
            if (!cue) {
              return row;
            }
            return Object.assign({}, row, {
              cross_hearing_cluster_size_percentile: toFiniteNumberOrNull(
                cue.cluster_size_percentile
              ),
              cross_hearing_n_records_percentile: toFiniteNumberOrNull(cue.n_records_percentile),
            });
          });
        }

        function renderHearingContextPanel() {
          const summaryHost = document.getElementById("hearing-context-summary");
          const metadataHost = document.getElementById("hearing-context-metadata-host");
          const rampHost = document.getElementById("hearing-deadline-ramp-host");
          const stanceHost = document.getElementById("hearing-stance-by-deadline-host");

          const isAvailable = !!(hearingContextPanel && hearingContextPanel.available);
          const metadataRows = Array.isArray(hearingContextPanel.metadata_rows)
            ? hearingContextPanel.metadata_rows
            : [];
          const stanceRows = Array.isArray(hearingContextPanel.stance_by_deadline)
            ? hearingContextPanel.stance_by_deadline
            : [];
          const ramp = hearingContextPanel.deadline_ramp_metrics || {};

          if (summaryHost) {
            if (!isAvailable) {
              const reason =
                typeof hearingContextPanel.reason === "string" && hearingContextPanel.reason.trim()
                  ? hearingContextPanel.reason
                  : "No hearing metadata sidecar was provided for this run.";
              summaryHost.textContent = reason;
            } else {
              const hearingId =
                typeof hearingContextPanel.hearing_id === "string" &&
                hearingContextPanel.hearing_id.trim()
                  ? hearingContextPanel.hearing_id.trim()
                  : "unknown";
              summaryHost.textContent =
                "Hearing " +
                hearingId +
                " (" +
                reportTimezoneLabel +
                "). Process markers are overlaid on linked absolute-time charts.";
            }
          }

          if (metadataHost) {
            mountTable(metadataHost, metadataRows, { pagination: false, maxHeight: "280px" });
          }

          const rampRows = [];
          if (ramp && typeof ramp === "object") {
            Object.keys(ramp)
              .filter((key) => key !== "status")
              .forEach((key) => {
                rampRows.push({
                  metric: key.replace(/_/g, " "),
                  value: ramp[key],
                });
              });
          }
          if (rampHost) {
            mountTable(rampHost, rampRows, { pagination: false, maxHeight: "280px" });
          }

          if (stanceHost) {
            mountTable(stanceHost, stanceRows, { pagination: false, maxHeight: "320px" });
          }
        }

        function renderInvestigationTables() {
          if (isOffHoursFocusOnly) {
            return;
          }
          const view = getActiveTriageView();
          const summary = view.triage_summary || {};
          const windowQueue = Array.isArray(view.window_evidence_queue) ? view.window_evidence_queue : [];
          const recordQueue = Array.isArray(view.record_evidence_queue) ? view.record_evidence_queue : [];
          const clusterQueue = Array.isArray(view.cluster_evidence_queue) ? view.cluster_evidence_queue : [];

          const windowHost = document.getElementById("triage-window-queue-host");
          const recordHost = document.getElementById("triage-record-queue-host");
          const clusterHost = document.getElementById("triage-cluster-queue-host");
          const forensicsNamesHost = document.getElementById("forensics-top-names-host");
          const forensicsClustersHost = document.getElementById("forensics-top-clusters-host");
          const comparatorHost = document.getElementById("cross-hearing-comparator-host");
          const taxonomyHost = document.getElementById("methodology-evidence-taxonomy-host");
          const artifactRowsHost = document.getElementById("methodology-artifact-rows-host");

          const windowMount = mountTable(windowHost, windowQueue, {
            paginationSize: 12,
            maxHeight: "420px",
            selectableRows: true,
            rowClick: (_event, row) => {
              const data = row && typeof row.getData === "function" ? row.getData() : null;
              if (data) {
                renderWindowDrilldown(data);
              }
            },
          });
          if (windowMount && windowMount.kind === "tabulator") {
            drilldownState.windowTable = windowMount.table;
            if (
              drilldownState.windowTable &&
              typeof drilldownState.windowTable.on === "function"
            ) {
              drilldownState.windowTable.on("rowClick", (_event, row) => {
                const data = row && typeof row.getData === "function" ? row.getData() : null;
                if (data) {
                  renderWindowDrilldown(data);
                }
              });
            }
          }

          mountTable(recordHost, recordQueue, {
            paginationSize: 10,
            maxHeight: "380px",
          });
          mountTable(clusterHost, clusterQueue, {
            paginationSize: 10,
            maxHeight: "380px",
          });

          const topNames = Array.isArray(summary.top_repeated_names) && summary.top_repeated_names.length
            ? summary.top_repeated_names
            : recordQueue.slice(0, 10);
          const topClusters =
            Array.isArray(summary.top_near_dup_clusters) &&
            summary.top_near_dup_clusters.length
              ? summary.top_near_dup_clusters
              : clusterQueue.slice(0, 10);
          const topNamesWithCues = applyCrossHearingNameCues(topNames);
          const topClustersWithCues = applyCrossHearingClusterCues(topClusters);

          mountTable(forensicsNamesHost, topNamesWithCues, {
            paginationSize: 8,
            maxHeight: "340px",
          });
          mountTable(forensicsClustersHost, topClustersWithCues, {
            paginationSize: 8,
            maxHeight: "340px",
          });
          if (comparatorHost) {
            renderCrossHearingComparator();
          }

          const taxonomyRows = Array.isArray(methodology.evidence_taxonomy)
            ? methodology.evidence_taxonomy
            : Array.isArray(controls.evidence_taxonomy)
              ? controls.evidence_taxonomy
              : [];
          mountTable(taxonomyHost, taxonomyRows, {
            pagination: false,
            maxHeight: "280px",
          });

          const artifactRows = Object.entries(reportData.artifact_rows || {})
            .map((entry) => ({
              artifact: entry[0],
              rows: toNumber(entry[1]),
            }))
            .sort((left, right) => {
              const rowDelta = Number(toNumber(right.rows)) - Number(toNumber(left.rows));
              if (rowDelta !== 0) {
                return rowDelta;
              }
              return String(left.artifact).localeCompare(String(right.artifact));
            });
          mountTable(artifactRowsHost, artifactRows, {
            paginationSize: 10,
            maxHeight: "300px",
          });
          renderMethodologyPanel();

          const currentWindowId = String((drilldownState.activeWindow || {}).window_id || "");
          const nextActiveWindow =
            windowQueue.find((row) => String((row || {}).window_id || "") === currentWindowId) ||
            (windowQueue.length ? windowQueue[0] : null);
          if (nextActiveWindow) {
            renderWindowDrilldown(nextActiveWindow);
          } else {
            renderWindowDrilldown(null);
          }

          if (!investigationActionsBound) {
            const selectedButton = document.getElementById("download-selected-window-rows");
            if (selectedButton) {
              selectedButton.addEventListener("click", () => {
                let selectedWindows = [];
                if (
                  drilldownState.windowTable &&
                  typeof drilldownState.windowTable.getSelectedData === "function"
                ) {
                  selectedWindows = drilldownState.windowTable.getSelectedData() || [];
                }
                if (!selectedWindows.length && drilldownState.activeWindow) {
                  selectedWindows = [drilldownState.activeWindow];
                }
                const rows = selectedWindows.flatMap((windowRow) =>
                  getWindowSpanRows(windowRow).map((row) =>
                    Object.assign({ window_id: windowRow.window_id || "" }, row)
                  )
                );
                if (!downloadCsv("selected_window_rows.csv", rows)) {
                  window.alert("No selected window rows available to export.");
                }
              });
            }

            const topWindowsButton = document.getElementById("download-top-evidence-windows");
            if (topWindowsButton) {
              topWindowsButton.addEventListener("click", () => {
                const activeView = getActiveTriageView();
                const activeRows = Array.isArray(activeView.window_evidence_queue)
                  ? activeView.window_evidence_queue
                  : [];
                if (!downloadCsv("top_evidence_windows.csv", activeRows)) {
                  window.alert("No window evidence rows available to export.");
                }
              });
            }

            const topRecordsButton = document.getElementById("download-top-evidence-records");
            if (topRecordsButton) {
              topRecordsButton.addEventListener("click", () => {
                const activeView = getActiveTriageView();
                const activeRows = Array.isArray(activeView.record_evidence_queue)
                  ? activeView.record_evidence_queue
                  : [];
                if (!downloadCsv("top_evidence_records.csv", activeRows)) {
                  window.alert("No record evidence rows available to export.");
                }
              });
            }
            investigationActionsBound = true;
          }
        }

        function initDedupModeControl() {
          const select = document.getElementById("triage-dedup-mode");
          const note = document.getElementById("triage-dedup-note");
          if (!select) {
            return;
          }

          const modes = dedupModes.length ? dedupModes : ["raw"];
          if (!modes.includes(state.activeDedupMode)) {
            state.activeDedupMode = modes[0];
          }

          select.innerHTML = "";
          modes.forEach((mode) => {
            const option = document.createElement("option");
            option.value = mode;
            option.textContent = dedupModeLabel(mode);
            select.appendChild(option);
          });
          select.value = state.activeDedupMode;

          const updateNote = () => {
            if (!note) {
              return;
            }
            const lensNote =
              typeof dataQualityPanel.lens_note === "string" ? dataQualityPanel.lens_note.trim() : "";
            const materialMetricCount = Number(toNumber(dataQualityPanel.material_metric_count || 0));
            const impactNote =
              materialMetricCount > 0
                ? materialMetricCount.toLocaleString() + " raw-vs-dedup metric(s) changed materially."
                : "No material raw-vs-dedup metric deltas detected.";
            note.textContent = dedupModeLabel(state.activeDedupMode) + " lens. " + lensNote + " " + impactNote;
          };

          select.addEventListener("change", () => {
            const nextMode = String(select.value || "").trim();
            if (!nextMode || nextMode === state.activeDedupMode) {
              updateNote();
              return;
            }
            state.activeDedupMode = nextMode;
            runWithBusyIndicator("Applying " + dedupModeLabel(nextMode) + " lens...", () => {
              renderTriageSummary();
              renderInvestigationTables();
            });
            updateNote();
          });

          updateNote();
        }

        function renderTablesForAnalysis(section, analysis) {
          const container = section.querySelector('[data-analysis-tables-for="' + analysis.id + '"]');
          if (!container) {
            return;
          }
          container.innerHTML = "";

          const detectorKey = analysis.detector;
          const detectorTables = detectorKey ? (reportData.table_previews || {})[detectorKey] || {} : {};
          let tableNames = Object.keys(detectorTables).sort();
          if (isOffHoursFocusOnly && analysis.id === "off_hours") {
            const preferred = [
              "off_hours_summary",
              "model_fit_diagnostics",
              "flag_channel_summary",
              "flagged_window_diagnostics",
              "window_control_profile",
              "date_hour_primary_residual_distribution",
              "date_hour_distribution",
            ];
            tableNames = preferred.filter((name) =>
              Object.prototype.hasOwnProperty.call(detectorTables, name)
            );
          }

          if (analysis.id === "composite_score" && Array.isArray(reportData.evidence_bundle_preview || [])) {
            const evidenceDetails = document.createElement("details");
            evidenceDetails.className = "table-group";
            evidenceDetails.open = true;
            const evidenceSummary = document.createElement("summary");
            evidenceSummary.textContent = "evidence_bundle_preview";
            evidenceDetails.appendChild(evidenceSummary);
            const evidenceWrap = document.createElement("div");
            evidenceWrap.className = "table-wrap";
            const evidenceHost = document.createElement("div");
            evidenceHost.className = "table-host";
            const evidenceRows = reportData.evidence_bundle_preview || [];
            renderTableHelpCard(
              evidenceWrap,
              "composite_score.evidence_bundle_preview",
              evidenceRows
            );
            evidenceWrap.appendChild(evidenceHost);
            evidenceDetails.appendChild(evidenceWrap);
            mountTable(evidenceHost, evidenceRows, {
              paginationSize: 10,
              maxHeight: "380px",
              tableKey: "composite_score.evidence_bundle_preview",
            });
            container.appendChild(evidenceDetails);
          }

          if (analysis.id === "rare_names") {
            const rarityTables = [
              ["rarity_coverage_preview", reportData.rarity_coverage_preview || []],
              ["rarity_unmatched_first_preview", reportData.rarity_unmatched_first_preview || []],
              ["rarity_unmatched_last_preview", reportData.rarity_unmatched_last_preview || []],
            ];
            const rarityTableKeys = {
              rarity_coverage_preview: "rare_names.rarity_coverage_preview",
              rarity_unmatched_first_preview: "rare_names.rarity_unmatched_first_preview",
              rarity_unmatched_last_preview: "rare_names.rarity_unmatched_last_preview",
            };
            rarityTables.forEach((entry, index) => {
              const rows = Array.isArray(entry[1]) ? entry[1] : [];
              if (!rows.length) {
                return;
              }
              const details = document.createElement("details");
              details.className = "table-group";
              details.open = index === 0;
              const summary = document.createElement("summary");
              summary.textContent = entry[0];
              details.appendChild(summary);
              const wrap = document.createElement("div");
              wrap.className = "table-wrap";
              const host = document.createElement("div");
              host.className = "table-host";
              renderTableHelpCard(wrap, rarityTableKeys[entry[0]] || "", rows);
              wrap.appendChild(host);
              details.appendChild(wrap);
              mountTable(host, rows, {
                paginationSize: 8,
                maxHeight: "320px",
                tableKey: rarityTableKeys[entry[0]] || "",
              });
              container.appendChild(details);
            });
          }

          if (analysis.id === "periodicity" && Array.isArray(reportData.clockface_top_preview || [])) {
            const rows = reportData.clockface_top_preview || [];
            if (rows.length) {
              const details = document.createElement("details");
              details.className = "table-group";
              details.open = true;
              const summary = document.createElement("summary");
              summary.textContent = "clockface_top_preview";
              details.appendChild(summary);
              const wrap = document.createElement("div");
              wrap.className = "table-wrap";
              const host = document.createElement("div");
              host.className = "table-host";
              renderTableHelpCard(wrap, "periodicity.clockface_top_preview", rows);
              wrap.appendChild(host);
              details.appendChild(wrap);
              mountTable(host, rows, {
                paginationSize: 8,
                maxHeight: "300px",
                tableKey: "periodicity.clockface_top_preview",
              });
              container.appendChild(details);
            }
          }

          tableNames.forEach((tableName, index) => {
            const details = document.createElement("details");
            details.className = "table-group";
            details.open = index === 0 && container.childElementCount === 0;

            const summary = document.createElement("summary");
            summary.textContent = tableName;
            details.appendChild(summary);

            const wrap = document.createElement("div");
            wrap.className = "table-wrap";
            details.appendChild(wrap);

            const host = document.createElement("div");
            host.className = "table-host";
            wrap.appendChild(host);

            const rows = detectorTables[tableName] || [];
            const tableKey = detectorKey ? detectorKey + "." + tableName : tableName;
            renderTableHelpCard(wrap, tableKey, rows);
            mountTable(host, rows, {
              paginationSize: 8,
              maxHeight: "340px",
              tableKey: tableKey,
            });

            container.appendChild(details);
          });

          if (!container.childElementCount) {
            const empty = document.createElement("p");
            empty.className = "empty-message";
            empty.textContent = "No preview tables available for this analysis.";
            container.appendChild(empty);
          }
        }

        async function renderChartMount(mount) {
          if (!mount || !mount.chartId) {
            return;
          }
          const analysisId = String(chartToAnalysis.get(mount.chartId) || "").trim();
          if (analysisId) {
            const needsLoad = analysisNeedsShardLoad(analysisId);
            if (needsLoad) {
              setChartLoading(mount.chartId, true, "Loading chart data...");
            }
            try {
              await ensureAnalysisDataLoaded(analysisId);
            } catch (error) {
              setChartLoading(mount.chartId, false);
              setEmptyForChart(mount.chartId, true);
              setChartNote(mount.chartId, "Unable to load chart data for this section.");
              showDataLoadError(
                "Unable to load report data files. Serve this report directory over HTTP and refresh.",
                error
              );
              return;
            }
            if (needsLoad) {
              setChartLoading(mount.chartId, false);
            }
          }

          const rawRows = getChartRows(mount.chartId);
          if (!rawRows.length) {
            setEmptyForChart(mount.chartId, true);
            setChartNote(mount.chartId, "");
            return;
          }

          const bucketSelection = filterRowsByBucket(rawRows, mount.chartId);
          const zoomSelection = filterRowsByLinkedZoom(mount, bucketSelection.rows);
          const rows = zoomSelection.rows;
          mount.activeBucket = bucketSelection.bucket;
          const preRenderNote = [bucketSelection.note, zoomSelection.note]
            .map((value) => String(value || "").trim())
            .filter((value) => !!value)
            .join(" ");
          setChartNote(mount.chartId, preRenderNote);

          if (!rows.length) {
            setEmptyForChart(mount.chartId, true);
            return;
          }
          setEmptyForChart(mount.chartId, false);

          if (!hasEcharts) {
            return;
          }

          clearChartInteractionState(mount);
          const didRender = renderAutoChart(mount, rows);
          setEmptyForChart(mount.chartId, !didRender);
          if (!didRender) {
            return;
          }
          setChartNote(mount.chartId, composeChartNote(mount, preRenderNote));
          if (mount.isAbsoluteTime) {
            applyZoomToChart(mount);
          }
        }

        async function mountChartHost(host) {
          const chartId = String(host.getAttribute("data-chart-id") || "").trim();
          if (!chartId || chartMounts.has(chartId)) {
            return;
          }

          const mount = {
            chartId: chartId,
            host: host,
            chart: createChartInstance(host),
            isTimeSeries: false,
            isAbsoluteTime: false,
            legendDockMode: "",
            hasFunnelClickHandler: false,
            seriesId: null,
            baseMarkLines: state.absoluteTimeSet.has(chartId) ? buildProcessMarkerLines() : [],
            crossHearingComparatorNote: null,
            customChartNote: null,
            timeExtent: null,
            activeBucket: null,
          };
          chartMounts.set(chartId, mount);
          if (mount.chart) {
            chartInstances.push(mount.chart);
          }

          await renderChartMount(mount);

          if (mount.chart && mount.isTimeSeries) {
            attachCursorHandlers(mount);
            attachZoomHandlers(mount);
            state.timeCharts.add(chartId);
          } else {
            attachFunnelCursorHandler(mount);
          }
        }

        async function mountSection(section, analysis) {
          if (!section || !analysis) {
            return;
          }
          const sectionId = String(analysis.id || "");
          if (!sectionId || mountedSections.has(sectionId)) {
            return;
          }

          const needsLoad = analysisNeedsShardLoad(sectionId);
          if (needsLoad) {
            setSectionLoading(section, true, "Loading analysis data...");
          }
          try {
            await ensureAnalysisDataLoaded(sectionId);
          } catch (error) {
            setSectionLoading(section, false);
            const hosts = Array.from(section.querySelectorAll("[data-chart-id]"));
            hosts.forEach((host) => {
              const chartId = String(host.getAttribute("data-chart-id") || "").trim();
              if (!chartId) {
                return;
              }
              setEmptyForChart(chartId, true);
              setChartNote(chartId, "Unable to load chart data for this section.");
            });
            showDataLoadError(
              "Unable to load report data files. Serve this report directory over HTTP and refresh.",
              error
            );
            return;
          }

          const hosts = Array.from(section.querySelectorAll("[data-chart-id]"));
          await Promise.all(hosts.map((host) => mountChartHost(host)));
          if (needsLoad) {
            setSectionLoading(section, false);
          }
          renderTablesForAnalysis(section, analysis);
          mountedSections.add(sectionId);
        }

        async function rerenderBucketAwareCharts() {
          const analysisIds = new Set();
          chartMounts.forEach((mount) => {
            const chartRows = getChartRows(mount.chartId);
            const options = getChartBucketOptions(mount.chartId, chartRows);
            if (!options.length) {
              return;
            }
            const analysisId = String(chartToAnalysis.get(mount.chartId) || "").trim();
            if (analysisId) {
              analysisIds.add(analysisId);
            }
          });
          await Promise.all(
            Array.from(analysisIds).map((analysisId) => ensureAnalysisDataLoaded(analysisId))
          );
          const renders = [];
          chartMounts.forEach((mount) => {
            const rows = getChartRows(mount.chartId);
            if (!rows.length) {
              return;
            }
            if (!getChartBucketOptions(mount.chartId, rows).length) {
              return;
            }
            renders.push(renderChartMount(mount));
          });
          await Promise.all(renders);
        }

        function rerenderLinkedZoomAwareCharts(sourceChartId) {
          chartMounts.forEach((mount, chartId) => {
            if (!mount || chartId === sourceChartId || state.absoluteTimeSet.has(chartId)) {
              return;
            }
            const rows = getChartRows(chartId);
            if (!rows.length) {
              return;
            }
            if (!chartUsesLinkedZoomRowFilter(mount, rows)) {
              return;
            }
            renderChartMount(mount);
          });
        }

        function initBucketTabs() {
          const root = document.getElementById("bucket-sync-tabs");
          const panel = document.getElementById("bucket-sync-panel");
          const optionsRaw = Array.isArray(controls.global_bucket_options) ? controls.global_bucket_options : [];
          const options = Array.from(
            new Set(optionsRaw.map((value) => toFiniteNumberOrNull(value)).filter((value) => value !== null))
          ).sort((left, right) => left - right);

          if (!root || !panel || !options.length) {
            if (panel) {
              panel.classList.add("hidden");
            }
            return;
          }

          panel.classList.remove("hidden");
          const preferredDefault = toFiniteNumberOrNull(controls.default_bucket_minutes);
          state.defaultBucket =
            preferredDefault !== null && options.includes(preferredDefault)
              ? preferredDefault
              : options.includes(30)
                ? 30
                : options[0];
          const queryBucket = parseBucketFromQueryParams(options);
          state.activeBucket =
            queryBucket !== null && options.includes(queryBucket)
              ? queryBucket
              : state.defaultBucket;

          root.innerHTML = "";
          options.forEach((bucket) => {
            const tab = document.createElement("button");
            tab.type = "button";
            tab.className = "bucket-tab";
            tab.setAttribute("role", "tab");
            tab.setAttribute("aria-selected", state.activeBucket === bucket ? "true" : "false");
            tab.textContent = String(bucket) + "m";
            tab.addEventListener("click", () => {
              state.activeBucket = bucket;
              Array.from(root.querySelectorAll(".bucket-tab")).forEach((node) => {
                node.setAttribute("aria-selected", node.textContent === String(bucket) + "m" ? "true" : "false");
              });
              syncControlOverridesToUrl();
              runWithBusyIndicator("Applying " + bucket + "m bucket...", async () =>
                rerenderBucketAwareCharts()
              );
            });
            root.appendChild(tab);
          });
        }

        function initZoomControls() {
          const panel = document.getElementById("zoom-sync-panel");
          const resetButton = document.getElementById("zoom-reset-button");
          const banner = document.getElementById("zoom-active-banner");
          const bannerResetButton = document.getElementById("zoom-banner-reset-button");
          const bannerCopyButton = document.getElementById("zoom-banner-copy-button");
          if (!panel || !resetButton) {
            return;
          }
          if (!state.absoluteTimeSet.size) {
            panel.classList.add("hidden");
            if (banner) {
              banner.classList.add("hidden");
            }
            return;
          }
          panel.classList.remove("hidden");
          const resetZoom = () => {
            runWithBusyIndicator("Resetting linked zoom...", () => {
              propagateZoom(null, null, null, true);
            });
          };
          resetButton.addEventListener("click", resetZoom);
          if (bannerResetButton) {
            bannerResetButton.addEventListener("click", resetZoom);
          }
          if (bannerCopyButton) {
            bannerCopyButton.addEventListener("click", () => {
              if (!hasActiveZoomRange()) {
                return;
              }
              copyTextToClipboard(window.location.href)
                .then(() => {
                  bannerCopyButton.textContent = "Copied";
                  window.setTimeout(() => {
                    bannerCopyButton.textContent = "Copy link";
                  }, 1200);
                })
                .catch(() => {
                  bannerCopyButton.textContent = "Copy failed";
                  window.setTimeout(() => {
                    bannerCopyButton.textContent = "Copy link";
                  }, 1600);
                });
            });
          }
          updateZoomRangeLabel();
        }

        function initSidebarToggle() {
          const shell = document.getElementById("page-shell");
          const sidebar = document.getElementById("toc-sidebar");
          const toggle = document.getElementById("sidebar-toggle");
          const launcher = document.getElementById("sidebar-launcher");
          const backdrop = document.getElementById("sidebar-backdrop");
          if (!shell || !sidebar || !toggle || !launcher || !backdrop) {
            return;
          }

          const isMobile = () => window.matchMedia("(max-width: 1220px)").matches;
          let previousIsMobile = isMobile();
          const applyState = (open) => {
            shell.classList.toggle("sidebar-open", open);
            toggle.setAttribute("aria-expanded", open ? "true" : "false");
            launcher.setAttribute("aria-expanded", open ? "true" : "false");
            toggle.setAttribute("aria-label", open ? "Hide menu" : "Show menu");
            toggle.textContent = open ? "←" : "→";
            scheduleChartResizeSequence();
          };

          applyState(!previousIsMobile);

          toggle.addEventListener("click", () => {
            applyState(!shell.classList.contains("sidebar-open"));
          });
          launcher.addEventListener("click", () => applyState(true));
          backdrop.addEventListener("click", () => applyState(false));

          window.addEventListener("resize", () => {
            const nowMobile = isMobile();
            if (nowMobile !== previousIsMobile) {
              previousIsMobile = nowMobile;
              applyState(!nowMobile);
            } else {
              scheduleChartResizeSequence();
            }
          });
        }

        function initSidebarToc() {
          const sidebar = document.getElementById("toc-sidebar");
          const tocRoot = document.getElementById("report-toc");
          const contentRoot = document.getElementById("toc-content");
          if (!sidebar || !tocRoot || !contentRoot) {
            return;
          }

          const topHeadings = Array.from(contentRoot.querySelectorAll("h2.toc-heading"));
          if (!topHeadings.length) {
            sidebar.classList.add("hidden");
            return;
          }

          const slugify = (value) =>
            String(value || "")
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, "-")
              .replace(/^-+|-+$/g, "");

          const usedIds = new Set(
            Array.from(document.querySelectorAll("[id]"))
              .map((node) => String(node.id || "").trim())
              .filter((id) => !!id)
          );

          const ensureHeadingId = (heading, fallbackPrefix) => {
            if (!heading) {
              return "";
            }
            const existing = String(heading.id || "").trim();
            if (existing) {
              usedIds.add(existing);
              return existing;
            }
            const slug = slugify(heading.textContent || "");
            const base = slug ? fallbackPrefix + "-" + slug : fallbackPrefix + "-item";
            let candidate = base;
            let counter = 2;
            while (usedIds.has(candidate)) {
              candidate = base + "-" + counter;
              counter += 1;
            }
            heading.id = candidate;
            usedIds.add(candidate);
            return candidate;
          };

          const topEntries = topHeadings
            .map((heading, index) => {
              const topId = ensureHeadingId(heading, "section-" + (index + 1));
              const sectionRoot = heading.closest("section");
              const children = sectionRoot
                ? Array.from(sectionRoot.querySelectorAll("h3, h4"))
                    .filter((child) => {
                      const childText = String(child.textContent || "").trim();
                      return !!childText;
                    })
                    .map((child, childIndex) => {
                      ensureHeadingId(child, topId + "-sub-" + (childIndex + 1));
                      return child;
                    })
                : [];
              return {
                heading: heading,
                topId: topId,
                sectionRoot: sectionRoot,
                children: children,
              };
            })
            .filter((entry) => !!entry.topId);

          if (!topEntries.length) {
            sidebar.classList.add("hidden");
            return;
          }

          const topById = new Map(topEntries.map((entry) => [entry.topId, entry]));
          const childToTop = new Map();
          topEntries.forEach((entry) => {
            entry.children.forEach((child) => {
              childToTop.set(child.id, entry.topId);
            });
          });

          const trackedHeadings = topEntries.flatMap((entry) => [entry.heading].concat(entry.children));
          if (!trackedHeadings.length) {
            sidebar.classList.add("hidden");
            return;
          }

          const topForHeading = (headingId) => {
            const normalized = normalizeHashId(headingId);
            if (!normalized) {
              return topEntries[0].topId;
            }
            if (topById.has(normalized)) {
              return normalized;
            }
            const parentTop = childToTop.get(normalized);
            if (parentTop && topById.has(parentTop)) {
              return parentTop;
            }
            return topEntries[0].topId;
          };

          const renderToc = (activeHeadingId) => {
            const activeHeading = normalizeHashId(activeHeadingId) || topEntries[0].topId;
            const activeTop = topForHeading(activeHeading);
            const list = document.createElement("ul");
            list.className = "toc-list";

            topEntries.forEach((entry) => {
              const topItem = document.createElement("li");
              topItem.className = "toc-list-item";
              const topLink = document.createElement("a");
              topLink.className = "toc-link";
              topLink.href = "#" + entry.topId;
              topLink.textContent = String(entry.heading.textContent || "").trim() || entry.topId;

              const topIsActive = entry.topId === activeHeading;
              topLink.classList.toggle("is-active-link", topIsActive);
              if (topIsActive) {
                topLink.setAttribute("aria-current", "true");
              }
              topItem.appendChild(topLink);

              if (entry.topId === activeTop && entry.children.length) {
                const childList = document.createElement("ul");
                childList.className = "toc-list-children";
                entry.children.forEach((child) => {
                  const childItem = document.createElement("li");
                  childItem.className = "toc-list-item";
                  const childLink = document.createElement("a");
                  childLink.className = "toc-link toc-link-child";
                  childLink.href = "#" + child.id;
                  childLink.textContent = String(child.textContent || "").trim() || child.id;
                  const childIsActive = child.id === activeHeading;
                  childLink.classList.toggle("is-active-link", childIsActive);
                  if (childIsActive) {
                    childLink.setAttribute("aria-current", "true");
                  }
                  childItem.appendChild(childLink);
                  childList.appendChild(childItem);
                });
                topItem.appendChild(childList);
              }

              list.appendChild(topItem);
            });

            tocRoot.innerHTML = "";
            tocRoot.appendChild(list);
          };

          state.renderToc = renderToc;

          const pickActiveHeading = () => {
            const topOffset = 120;
            const lastHeading = trackedHeadings[trackedHeadings.length - 1];
            const doc = document.documentElement;
            const hashHeadingId = normalizeHashId(window.location.hash);
            const hashHeading = hashHeadingId ? document.getElementById(hashHeadingId) : null;
            if (hashHeading && trackedHeadings.includes(hashHeading)) {
              const rect = hashHeading.getBoundingClientRect();
              if (rect.top >= -24 && rect.top <= window.innerHeight * 1.5) {
                return hashHeading.id;
              }
            }
            if (window.scrollY + window.innerHeight >= doc.scrollHeight - 4) {
              return lastHeading ? lastHeading.id : "";
            }

            let active = trackedHeadings[0];
            let foundAboveOffset = false;
            trackedHeadings.forEach((heading) => {
              if (heading.getBoundingClientRect().top <= topOffset) {
                active = heading;
                foundAboveOffset = true;
              }
            });
            if (!foundAboveOffset) {
              const nearest = trackedHeadings
                .slice()
                .sort(
                  (left, right) =>
                    Math.abs(left.getBoundingClientRect().top - topOffset) -
                    Math.abs(right.getBoundingClientRect().top - topOffset)
                )[0];
              active = nearest || active;
            }
            return active ? active.id : "";
          };

          tocRoot.addEventListener("click", async (event) => {
            const link = event.target.closest('a[href^="#"]');
            if (!link) {
              return;
            }
            if (event.button !== 0 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {
              return;
            }

            const headingId = normalizeHashId(link.getAttribute("href"));
            const target = headingId ? document.getElementById(headingId) : null;
            if (!target) {
              return;
            }
            event.preventDefault();

            const targetSection = target.closest("[data-analysis-id]");
            if (targetSection) {
              const allSections = Array.from(document.querySelectorAll("[data-analysis-id]"));
              for (const section of allSections) {
                const analysisId = String(section.getAttribute("data-analysis-id") || "");
                await mountSection(section, analysisById.get(analysisId));
                if (section === targetSection) {
                  break;
                }
              }
            }
            const alignToTarget = (behavior) => {
              const nextTop = Math.max(0, target.getBoundingClientRect().top + window.scrollY - 76);
              window.scrollTo({ top: nextTop, behavior: behavior });
            };
            alignToTarget("smooth");
            window.setTimeout(() => alignToTarget("auto"), 320);
            window.setTimeout(() => alignToTarget("auto"), 920);
            setActiveTocHeading(headingId, true);
          });

          let ticking = false;
          const updateActiveHeading = () => {
            const headingId = pickActiveHeading();
            if (headingId) {
              setActiveTocHeading(headingId, true);
            }
          };
          const onScroll = () => {
            if (ticking) {
              return;
            }
            ticking = true;
            window.requestAnimationFrame(() => {
              ticking = false;
              updateActiveHeading();
            });
          };

          window.addEventListener("scroll", onScroll, { passive: true });
          window.addEventListener("hashchange", () => {
            const headingId = normalizeHashId(window.location.hash);
            if (headingId && document.getElementById(headingId)) {
              setActiveTocHeading(headingId, false);
            }
          });

          const initialHash = normalizeHashId(window.location.hash);
          if (initialHash && document.getElementById(initialHash)) {
            setActiveTocHeading(initialHash, false);
          } else {
            updateActiveHeading();
          }
        }

        function collectDetectorStats() {
          const summaries = reportData.detector_summaries || {};
          return Object.keys(summaries)
            .sort()
            .map((detectorName) => {
              const summary = summaries[detectorName] || {};
              const flaggedKeys = [
                "n_significant_windows",
                "n_anomaly_buckets",
                "n_high_priority_windows",
                "n_time_bucket_flags",
                "n_day_slot_outliers",
              ];
              const lowPowerKeys = [
                "n_low_power_windows",
                "n_low_power_buckets",
                "n_low_power_match_buckets",
                "n_low_power_time_buckets",
                "n_low_power_day_slots",
              ];
              return {
                detectorName: detectorName,
                flagged: flaggedKeys.reduce((acc, key) => (Object.prototype.hasOwnProperty.call(summary, key) ? toNumber(summary[key]) : acc), 0),
                lowPower: lowPowerKeys.reduce((acc, key) => (Object.prototype.hasOwnProperty.call(summary, key) ? toNumber(summary[key]) : acc), 0),
              };
            });
        }

        function updateReportTimezoneSummary() {
          const host = document.getElementById("report-timezone-summary");
          if (!host) {
            return;
          }
          host.textContent = "All times in this report are shown in " + reportTimezoneLabel + ".";
        }

        function buildKpis() {
          const artifactRows = Object.values(reportData.artifact_rows || {}).map((value) => toNumber(value));
          const detectorStats = collectDetectorStats();

          const setText = (id, value) => {
            const element = document.getElementById(id);
            if (element) {
              element.textContent = String(value);
            }
          };
          const setMeta = (id, value) => {
            const element = document.getElementById(id);
            if (element) {
              element.textContent = value || "";
            }
          };

          if (isOffHoursFocusOnly) {
            const artifactEntries = Object.entries(reportData.artifact_rows || {}).filter((entry) =>
              String(entry[0] || "").startsWith("off_hours.")
            );
            const offHoursArtifactFallback = artifactEntries.reduce(
              (acc, entry) => acc + toNumber(entry[1]),
              0
            );
            const offHoursSummaryRows = getChartRows("off_hours_summary_compare");
            const offHoursSummary = offHoursSummaryRows.length ? offHoursSummaryRows[0] : {};
            const offHoursRecords = toNumber(offHoursSummary.off_hours);
            const primaryBucket = toFiniteNumberOrNull(offHoursSummary.primary_bucket_minutes);
            const offHoursTimelineRows = getChartRows("off_hours_control_timeline");
            const primaryBucketRows = offHoursTimelineRows.filter((row) => {
              const rowBucket = toFiniteNumberOrNull(row.bucket_minutes);
              if (primaryBucket === null || rowBucket === null) {
                return false;
              }
              return rowBucket === primaryBucket;
            });
            let lowPowerOffHoursWindows = primaryBucketRows.filter((row) => {
              const alertWindow = Object.prototype.hasOwnProperty.call(row, "is_alert_off_hours_window")
                ? toBool(row.is_alert_off_hours_window)
                : toBool(row.is_off_hours_window);
              return alertWindow && toBool(row.is_low_power);
            }).length;
            const robustAlerts = toNumber(offHoursSummary.off_hours_windows_primary_alert);
            const twoSidedFlags = toNumber(
              offHoursSummary.off_hours_windows_significant_primary_two_sided
            );
            const lowerTailFlags = toNumber(offHoursSummary.off_hours_windows_significant_primary);
            const fallbackBreaches = toNumber(
              offHoursSummary.off_hours_windows_below_primary_control_998
            );
            const alertEligibleSummary = toFiniteNumberOrNull(
              offHoursSummary.off_hours_windows_alert_eligible
            );
            const alertEligibleFallback = primaryBucketRows.filter((row) => {
              const alertWindow = Object.prototype.hasOwnProperty.call(row, "is_alert_off_hours_window")
                ? toBool(row.is_alert_off_hours_window)
                : toBool(row.is_off_hours_window);
              return alertWindow && toFiniteNumberOrNull(row.pro_rate) !== null;
            }).length;
            const alertEligibleWindows = Math.max(
              0,
              Math.round(
                alertEligibleSummary !== null ? alertEligibleSummary : alertEligibleFallback
              )
            );
            const lowPowerSummary = toFiniteNumberOrNull(
              offHoursSummary.off_hours_windows_alert_eligible_low_power
            );
            if (lowPowerSummary !== null) {
              lowPowerOffHoursWindows = Math.max(0, Math.round(lowPowerSummary));
            }
            const testedSummary = toFiniteNumberOrNull(offHoursSummary.off_hours_windows_tested);
            const testedOffHoursWindows = Math.max(
              0,
              Math.round(
                testedSummary !== null
                  ? testedSummary
                  : Math.max(0, alertEligibleWindows - lowPowerOffHoursWindows)
              )
            );
            const offHoursRatio = toFiniteNumberOrNull(offHoursSummary.off_hours_ratio);
            const onHoursRecords = toNumber(offHoursSummary.on_hours);
            const totalRecords = Math.max(
              0,
              Math.round((offHoursRecords > 0 ? offHoursRecords : 0) + Math.max(0, onHoursRecords))
            );
            const primaryBaselineMethod =
              typeof offHoursSummary.primary_baseline_method === "string"
                ? offHoursSummary.primary_baseline_method.replace(/_/g, " ")
                : "";
            const flaggedKpiValue =
              robustAlerts > 0
                ? robustAlerts
                : twoSidedFlags > 0
                  ? twoSidedFlags
                  : lowerTailFlags > 0
                    ? lowerTailFlags
                    : fallbackBreaches;

            setText(
              "kpi-artifacts",
              Math.round(offHoursRecords > 0 ? offHoursRecords : offHoursArtifactFallback).toLocaleString()
            );
            setText("kpi-detectors", "1");
            setText("kpi-flagged", Math.round(flaggedKpiValue).toLocaleString());
            setText("kpi-low-power", Math.round(lowPowerOffHoursWindows).toLocaleString());

            setMeta(
              "kpi-artifacts-meta",
              offHoursRatio !== null && totalRecords > 0
                ? "Share of all records: " +
                    formatPercent(offHoursRatio, 1) +
                    " (" +
                    totalRecords.toLocaleString() +
                    " total)."
                : ""
            );
            setMeta(
              "kpi-detectors-meta",
              primaryBaselineMethod ? "Primary baseline: " + primaryBaselineMethod + "." : ""
            );
            setMeta(
              "kpi-flagged-meta",
              alertEligibleWindows > 0
                ? "Tested windows: " +
                    testedOffHoursWindows.toLocaleString() +
                    "/" +
                    alertEligibleWindows.toLocaleString() +
                    " (" +
                    formatRatio(testedOffHoursWindows, alertEligibleWindows, 1) +
                    ")."
                : "No alert-eligible windows in the primary bucket."
            );
            setMeta(
              "kpi-low-power-meta",
              alertEligibleWindows > 0
                ? "Low-power among alert-eligible: " +
                    lowPowerOffHoursWindows.toLocaleString() +
                    "/" +
                    alertEligibleWindows.toLocaleString() +
                    " (" +
                    formatRatio(lowPowerOffHoursWindows, alertEligibleWindows, 1) +
                    ")."
                : "No alert-eligible windows in the primary bucket."
            );

            const tierHost = document.getElementById("off-hours-evidence-tier");
            if (tierHost) {
              let tierClass = "tier-none";
              let tierText = "Evidence tier: No off-hours support";
              if (offHoursRecords > 0 && alertEligibleWindows > 0) {
                if (robustAlerts > 0) {
                  tierClass = "tier-strong";
                  tierText =
                    "Evidence tier: Strong (" +
                    Math.round(robustAlerts).toLocaleString() +
                    " robust primary alerts)";
                } else {
                  tierClass = "tier-descriptive";
                  tierText = "Evidence tier: Descriptive-only (no robust primary alerts)";
                }
              }
              tierHost.classList.remove("hidden", "tier-strong", "tier-descriptive", "tier-none");
              tierHost.classList.add(tierClass);
              tierHost.textContent = tierText;
            }

            const inferenceBanner = document.getElementById("off-hours-inference-banner");
            if (inferenceBanner) {
              const noInferentialSupport =
                alertEligibleWindows > 0 && testedOffHoursWindows === 0;
              inferenceBanner.classList.toggle("hidden", !noInferentialSupport);
              if (noInferentialSupport) {
                inferenceBanner.classList.remove("ok");
                inferenceBanner.textContent =
                  "Inferential scan unavailable in the primary bucket: 0/" +
                  alertEligibleWindows.toLocaleString() +
                  " alert-eligible windows passed low-power support. Treat off-hours results as descriptive-only for this run.";
              } else {
                inferenceBanner.textContent = "";
              }
            }
            return;
          }

          setMeta("kpi-artifacts-meta", "");
          setMeta("kpi-detectors-meta", "");
          setMeta("kpi-flagged-meta", "");
          setMeta("kpi-low-power-meta", "");

          setText(
            "kpi-artifacts",
            artifactRows.reduce((acc, value) => acc + value, 0).toLocaleString()
          );
          setText("kpi-detectors", detectorStats.length.toLocaleString());
          setText(
            "kpi-flagged",
            detectorStats.reduce((acc, item) => acc + toNumber(item.flagged), 0).toLocaleString()
          );
          setText(
            "kpi-low-power",
            detectorStats.reduce((acc, item) => acc + toNumber(item.lowPower), 0).toLocaleString()
          );
        }

        async function ensureHeaderDataLoaded() {
          const requiredAnalysisIds = new Set();
          if (isOffHoursFocusOnly) {
            ["off_hours_summary_compare", "off_hours_control_timeline"].forEach((chartId) => {
              const analysisId = String(chartToAnalysis.get(chartId) || "").trim();
              if (analysisId) {
                requiredAnalysisIds.add(analysisId);
              }
            });
            requiredAnalysisIds.add("off_hours");
          }
          if (!requiredAnalysisIds.size) {
            return;
          }
          await Promise.all(
            Array.from(requiredAnalysisIds).map((analysisId) => ensureAnalysisDataLoaded(analysisId))
          );
        }

        async function mountAllSections() {
          const sections = Array.from(document.querySelectorAll("[data-analysis-id]"));
          if (!sections.length) {
            return;
          }
          for (const section of sections) {
            const analysisId = String(section.getAttribute("data-analysis-id") || "");
            await mountSection(section, analysisById.get(analysisId));
          }
        }

        async function preloadAllChartShardFiles() {
          const urlsRaw = Array.isArray(chartDataManifest.all_urls) ? chartDataManifest.all_urls : [];
          const urls = Array.from(
            new Set(
              urlsRaw
                .map((value) => (typeof value === "string" ? value.trim() : ""))
                .filter((value) => !!value)
            )
          );
          if (!urls.length) {
            return;
          }
          await Promise.all(
            urls.map(async (url) => {
              const payload = await fetchJsonPayload(url, "chart shard " + url);
              const analysisId = String(payload && payload.analysis_id ? payload.analysis_id : "").trim();
              const bucketKey = normalizeBucketKey(payload ? payload.bucket_minutes : null);
              mergeChartShardPayload(payload, bucketKey);
              if (analysisId) {
                if (bucketKey === null) {
                  loadedAnalysisBase.add(analysisId);
                } else {
                  analysisBucketSet(analysisId).add(bucketKey);
                }
              }
            })
          );
        }

        async function ensureWindowDrilldownDataLoaded() {
          if (isOffHoursFocusOnly) {
            return;
          }
          const requiredAnalyses = [
            "baseline_profile",
            "bursts",
            "procon_swings",
            "duplicates_exact",
            "duplicates_near",
            "rare_names",
          ];
          const available = requiredAnalyses.filter((analysisId) =>
            !!chartShardEntryForAnalysis(analysisId)
          );
          await Promise.all(available.map((analysisId) => ensureAnalysisDataLoaded(analysisId)));
        }

        function initLazySectionMounting() {
          const sections = Array.from(document.querySelectorAll("[data-analysis-id]"));
          if (!sections.length) {
            return;
          }
          if (typeof window.IntersectionObserver === "undefined") {
            mountAllSections();
            return;
          }
          const observer = new window.IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (!entry.isIntersecting) {
                  return;
                }
                observer.unobserve(entry.target);
                const section = entry.target;
                const analysisId = String(section.getAttribute("data-analysis-id") || "");
                mountSection(section, analysisById.get(analysisId));
              });
            },
            {
              root: null,
              rootMargin: "420px 0px 420px 0px",
              threshold: 0.02,
            }
          );
          sections.forEach((section) => observer.observe(section));
          const first = sections[0];
          if (first) {
            observer.unobserve(first);
            const firstAnalysisId = String(first.getAttribute("data-analysis-id") || "");
            mountSection(first, analysisById.get(firstAnalysisId));
          }
        }

        updateReportTimezoneSummary();
        await ensureHeaderDataLoaded();
        buildKpis();
        initThemeControl();
        initSidebarTooltips();
        if (!isOffHoursFocusOnly) {
          initDedupModeControl();
          renderDataQualityPanel();
          renderHearingContextPanel();
          renderTriageSummary();
          await ensureWindowDrilldownDataLoaded();
          renderInvestigationTables();
        }
        initSidebarToggle();
        initBucketTabs();
        initZoomControls();
        initSidebarToc();
        if (forcePreloadAllData) {
          await runWithBusyIndicator("Preloading all chart data...", async () => {
            await preloadAllChartShardFiles();
            await mountAllSections();
          });
        } else {
          initLazySectionMounting();
        }
        initializeLinkedZoomOnLoad();
        syncControlOverridesToUrl();
        updateCursorAcrossTimeCharts();
        updateZoomRangeLabel();
        scheduleChartResizeSequence();

        window.addEventListener("resize", () => {
          scheduleChartResizeSequence();
        });
      })();
    </script>
  </body>
</html>